

resource "wiz_cloud_configuration_rule" "op-acc-1-2" {
  description              = "It is highly recommended to use an identity provider that allows you to manage identities in a centralized location, rather than using AWS IAM."
  enabled                  = true
  function_as_control      = false
  name                     = "Check if there are SAML Providers then STS can be used"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\n# Check if the user has AWS CLI or API access (indicated by active access keys)\nhas_cli_or_api_access {\n    lower(input.userCredentials.AccessKey1Active) == \"true\"\n} {\n    lower(input.userCredentials.AccessKey2Active) == \"true\"\n}\n\n# Check if the user has console access\nhas_console_access {\n    lower(input.userCredentials.PasswordEnabled) == \"true\"\n}\n\nresult = \"fail\" {\n    has_cli_or_api_access\n    not has_console_access\n}\n\ncurrentConfiguration := sprintf(\"User '%s' has AWS CLI or API access without console access, which may indicate the use of static IAM credentials\", [input.UserName])\nexpectedConfiguration := \"Users should authenticate via SAML and assume roles for AWS access, avoiding the use of static IAM credentials\"\n\n# Additional context\nfinding := {\n    \"user\": input.UserName,\n    \"has_cli_or_api_access\": has_cli_or_api_access,\n    \"has_console_access\": has_console_access\n}"
  remediation_instructions = null
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["user"]
}


resource "wiz_cloud_configuration_rule" "op-exp-8-1" {
  description              = "This rule checks whether the CloudTrail trail is configured to log management events.  \nThis rule fails if the Basic or Advanced event selectors don't include management events with both read and write logging. Management events provide visibility into the management operations performed on or within a resource. These are also known as control plane events.  \nIt is recommended to enable management events to proactively monitor problems, issues, and operations that occur when working with AWS cloud resources.\n>**Note**  \nAdditional charges apply to logging management events when there is more than one copy of management events in the account."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail trail should be configured with management events"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\tlower(readOrWrite.Field) == \"readonly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tlower(currSelector.Field) == lower(currField)\n\tlower(currSelector.Equals[_]) == lower(currValue)\n}\n\n#check event selector for basic and advanced resources\nconfiguredWithManagementEvents {\n# Basic \n\teventSelector := input.EventSelectors[_]\n \teventSelector.IncludeManagementEvents == true\n\tlower(eventSelector.ReadWriteType) == \"all\"\n }{ \n# Advanced\n\tAdvancedEventSelector := input.AdvancedEventSelectors[_]\n  \tcheckFieldSelector(AdvancedEventSelector.FieldSelectors[_], \"eventCategory\", \"Management\")\n   \tnot advanReadAndWrite(AdvancedEventSelector.FieldSelectors)\n }\n\nresult = \"fail\" {\n\tnot configuredWithManagementEvents\n}\n\ncurrentConfiguration := \"Cloudtrail is not configured with management events\"\nexpectedConfiguration := \"Cloudtrail should be configured with management events\"\n"
  remediation_instructions = "Perform the following commands to configure CloudTrail to log management events via AWS CLI:\n\n1. Use the following command to enable basic management events:\n```\naws cloudtrail put-event-selectors \\\n--trail-name {{trailName}} \\\n--event-selectors '[\n{ \n    \"ReadWriteType\": \"All\", \n    \"DataResources\": [\n    { \n        \"Type\": \"AWS::S3::Object\",\n        \"Values\": [\n            \"arn:aws:s3:::\"\n        ] \n    }\n    ],\n    \"IncludeManagementEvents\": true\n  }\n]'\n```\n\n2. Use the following command to enable Advanced management events:\n```\naws cloudtrail put-event-selectors \\\n  --trail-name {{trailName}} \\\n  --advanced-event-selectors '[ \n    { \n        \"FieldSelectors\": [ \n        {\n            \"Field\": \"eventCategory\",\n            \"Equals\": [ \"Management\" ]\n        }    \n        ]\n    },\n    { \n        \"FieldSelectors\": [ \n        {\n            \"Field\": \"eventCategory\",\n            \"Equals\": [ \"Data\" ]\n        },\n        {\n            \"Field\": \"resources.type\",\n            \"Equals\": [ \"AWS::S3::Object\" ]\n        }  \n        ]\n    }    \n  ]'\n  ```\n>**Note**  \n>* You can use either `AdvancedEventSelectors` or `EventSelectors`, but not both. If you apply `AdvancedEventSelectors` to a trail, any existing `EventSelectors` are overwritten.\n>* These remediations also enable S3 data events since creating a new `EventSelector` would overwrite any current configuration. This is a best practice but might cause additional charges. Please see rule CloudTrail-011 for more info."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\n\n#check for read and write permissions in basic event selectors\nbasicReadAndWrite(eventSel) {\n\teventSel.read_write_type == \"All\"\n}\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\treadOrWrite.field == \"readOnly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tcurrSelector.field == currField\n\tcurrSelector.equals[_] == currValue\n}\n\nadvancedEventSelectorWithManagementEvents(currEventSel) {\n  \tcheckFieldSelector(currEventSel[_], \"eventCategory\", \"Management\")\n  \tnot advanReadAndWrite(currEventSel)\n}\n\nbasicResourcesWithManagementEvents(eventSel) {\n\teventSel.include_management_events == true\n}\n\n#seperate checks for advanced single and multi selectors\nadvancedEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.advanced_event_selector[_]\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.advanced_event_selector\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\t\n}\n\n#seperate checks for basic single and multi event selectors\nbasicEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.event_selector[_]\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.event_selector\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}\n\n#check event selector for basic and advanced resources\nconfiguredWithManagementEvents(cloudtrailResource) {\n\t# Basic \n  \tbasicEventSelc(cloudtrailResource)\n}{ \n\t# Advanced\n\tadvancedEventSelc(cloudtrailResource)\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[cloudtrailName]  \n\tnot configuredWithManagementEvents(cloudtrailResource)\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, cloudtrailName),\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [cloudtrailName]),\n\t\t\"keyExpectedValue\": sprintf(\"cloudtrail %v should be configured with management events\",[cloudtrailName]),\n\t\t\"keyActualValue\": sprintf(\"cloudtrail %v is not configured with management events\",[cloudtrailName]),\n  \t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {})\n\t}\n}\n"
    remediation_instructions = "resource \"aws_cloudtrail\" \"example_cloudtrail\" {\n  event_selector {\n    include_management_events = true\n    read_write_type           = \"All\"\n  }\n}"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "mp-com-1-5" {
  description              = "This rule checks if the Security Group allows unrestricted ingress traffic to high-risk ports.  \nThis rule fails if at least one security group rule allows unrestricted traffic - `0.0.0.0/0` for IPv4 or `::/0` for IPv6 - on ports that are considered to be high risk - see the Rego for the list of ports.  \nExposing these ports to the Internet can increase opportunities for malicious activities.  \nIt is recommended to configure the Security Group to limit ingress traffic to known and trusted IP addresses only.\n>**Note**  \n>See Cloud Configuration Rule `VPC-034` if you require checking specificity for administration ports `22` and `3389`."
  enabled                  = true
  function_as_control      = false
  name                     = "EC2 Security Group should restrict access to risk ports from ENS "
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nips := {\"0.0.0.0/0\", \"::/0\"}\n\nrestrictProtocols := {\n\t\"tcpAdministrationPorts\": {\n\t\t\"protocols\": {\"tcp\",\"-1\",\"6\"},\n\t\t\"ports\": {22,1521,2483,3306,3389,5432,6379,7199,8888,9160,27017,27018,11211}\n    \t}\n}\n\nunrestrictedSourceIPs(rule) {\n\tips[rule.IpRanges[_].CidrIp]\n}{\n\tips[rule.Ipv6Ranges[_].CidrIpv6]\n}\n\nportAllowed(rule, ports) {\n\trule.FromPort <= ports[port]\n\trule.ToPort >= ports[port]\n}{\n\tis_null(rule.FromPort)\n}\n\nprotocolAllowed(rule, protocols) {\n\tprotocols[rule.IpProtocol]\n}\n\nresult := \"fail\" {\n\trule := input.IpPermissions[permission]\n\tunrestrictedSourceIPs(rule)\n\tportAllowed(rule, restrictProtocols[i].ports)\n\tprotocolAllowed(rule, restrictProtocols[i].protocols)\n}\n\ncurrentConfiguration := \"Security Group allows unrestricted access to high risk ports\"\nexpectedConfiguration := \"Security Group should not allow unrestricted access to high risk ports\"\n"
  remediation_instructions = "Perform the following commands to modify or delete the Security Group rule via AWS CLI:\n\nUse the following command to modify the non-compliant rule(s):\n```\naws ec2 modify-security-group-rules \\\n\t--group-id {{groupId}} \\\n\t--security-group-rules SecurityGroupRuleId=<SecurityGroupRuleId>,SecurityGroupRule=\"{FromPort=<FromPort>,ToPort=<ToPort>,IpProtocol=<IpProtocol>,CidrIpv4=<CidrIp>}\"  \n```\n\nAlternatively, use the following command to delete the non-compliant rule(s):\n```\naws ec2 revoke-security-group-ingress \\\n\t--group-id {{groupId}} \\\n\t--security-group-rule-ids <value>\n```\n>**Note**  \n>You can find your rule ID on the Security Group page in the AWS Console or by using the command `describe-security-group-rules` on the AWS CLI."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["securityGroup"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\nimport data.generic.common as commonLib\n\nisSecGroupMatch(ec2Instance, secGroup) {\n\tec2Instance.properties.Properties.SecurityGroups[_].Ref == secGroup.name\n}{\n\tec2Instance.properties.Properties.SecurityGroups[_] == secGroup.name\t\n}\n\nisAccessibleFromEntireNetwork(ingress) {\n\tendswith(ingress.CidrIp, \"/0\")\n}\n\ngetProtocolList(protocol) = list {\n\tupper(protocol) == [\"-1\", \"ALL\"][_]\n\tlist = [\"TCP\", \"UDP\"]\n} else = list {\n\tupper(protocol) == \"TCP\"\n\tlist = [\"TCP\"]\n} else = list {\n\tupper(protocol) == \"UDP\"\n\tlist = [\"UDP\"]\n}\n\ngetProtocolPorts(protocols, tcpPortsMap, udpPortsMap) = portsMap {\n\tsprintf(\"%v\", protocols[_]) == [\"-1\", \"ALL\"][_]\n\tportsMap = object.union(tcpPortsMap, udpPortsMap)\n} else = portsMap {\n\tprotocols[_] == \"UDP\"\n\tportsMap = udpPortsMap\n} else = portsMap {\n\tprotocols[_] == \"TCP\"\n\tportsMap = tcpPortsMap\n}\n\nWizPolicy[result] {\n\t#############\tdocument and resource\n\tresources := input.document[i].Resources\n\n\tec2InstanceList = [{\"name\": key, \"properties\": ec2Instance} |\n\t\tec2Instance := resources[key]\n\t\tec2Instance.Type == \"AWS::EC2::Instance\"\n\t]\n\n\tec2Instance := ec2InstanceList[j]\n\n\tsecurityGroupList = [{\"name\": key, \"properties\": secGroup} |\n\t\tsecGroup := resources[key]\n\t\tsecGroup.Type == \"AWS::EC2::SecurityGroup\"\n\t]\n\n\tsecGroup := securityGroupList[k]\n\tisSecGroupMatch(ec2Instance, secGroup)\n\n\tingress := secGroup.properties.Properties.SecurityGroupIngress[l]\n\n\tprotocols := getProtocolList(ingress.IpProtocol)\n\tprotocol := protocols[m]\n\tportsMap = getProtocolPorts(protocols, commonLib.tcpPortsMap, cloudFormationLib.udpPortsMap)\n\n\t#############\tChecks\n\tisAccessibleFromEntireNetwork(ingress)\n\n\t# is in ports range\n\tportRange := numbers.range(ingress.FromPort, ingress.ToPort)\n\tportsMap[portRange[idx]]\n\tportNumber = portRange[idx]\n\tportName := portsMap[portNumber]\n\n\t#############\tResult\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(secGroup.properties, secGroup.name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.SecurityGroupIngress\", [secGroup.name]),\n\t\t\"searchValue\": sprintf(\"%s,%d\", [protocol, portNumber]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"%s (%s:%d) should not be allowed in EC2 security group for instance %s\", [portName, protocol, portNumber, ec2Instance.name]),\n\t\t\"keyActualValue\": sprintf(\"%s (%s:%d) is allowed in EC2 security group for instance %s\", [portName, protocol, portNumber, ec2Instance.name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resources),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as commonLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_security_group[name]\n\n\tportContent := commonLib.tcpPortsMap[port]\n\tportNumber = port\n\tportName = portContent\n\tingress := terraLib.getValueArrayOrObject(resource.ingress)\n\tprotocol := terraLib.getProtocolList(ingress.protocol)[_]\n\n\tendswith(ingress.cidr_blocks[_], \"/0\")\n\tterraLib.containsPort(ingress, portNumber)\n\tisTCPorUDP(protocol)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_security_group\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_security_group[%s].ingress\", [name]),\n\t\t\"searchValue\": sprintf(\"%s,%d\", [protocol, portNumber]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"%s (%s:%d) should not be allowed\", [portName, protocol, portNumber]),\n\t\t\"keyActualValue\": sprintf(\"%s (%s:%d) is allowed\", [portName, protocol, portNumber]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nisTCPorUDP(\"TCP\") = true\n\nisTCPorUDP(\"UDP\") = true\n"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-8-r4-3" {
  description              = "This rule checks whether all S3 Block Public Access settings are enabled at the account level.  \nThis rule fails if any of the following S3 Block Public Access settings are not enabled: `BlockPublicAcls`, `BlockPublicPolicy`, `IgnorePublicAcls`, `RestrictPublicBuckets`.  \nEnabling S3 Block Public Access settings at the account level helps ensure that there is no public access to any S3 buckets and objects, unless explicitly intended, thus safeguarding against accidental public exposure of data.  \nIt is recommended to ensure all 'Block Public Access' settings are enabled to ensure that any S3 bucket and its objects are not publicly accessible."
  enabled                  = true
  function_as_control      = false
  name                     = "S3 Bucket Account level 'Block Public Access' setting should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nsettings := {\"BlockPublicAcls\", \"BlockPublicPolicy\", \"IgnorePublicAcls\", \"RestrictPublicBuckets\"}\n\ninvalidSettings[setting] {\n\tsetting := settings[i]\n\tnot input.accountPublicAccessBlockConfiguration[setting]\n}\n\nresult = \"fail\" {\n\tcount(invalidSettings) > 0\n}\n\ncurrentConfiguration := sprintf(\"The following S3 Block Public Access settings are not enabled at the account level: %v\", [invalidSettings])\nexpectedConfiguration := \"All S3 Block Public Access settings should be enabled at the account level\"\n"
  remediation_instructions = "Perform the following command to enable S3 Block Public Access settings on the account level via AWS CLI:\n\n```\naws s3control put-public-access-block \\\n    --account-id <AccountId> \\\n    --public-access-block-configuration 'BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true'\n```\n>**Note**  \nThis command enables all four S3 Block Public Access settings for the entire AWS account, which will block public access to all S3 buckets by default. Ensure that you understand the implications of this change as it may affect any buckets that are intended to be publicly accessible.\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["account"]
}


resource "wiz_cloud_configuration_rule" "op-exp-10-4" {
  description              = "This rule fails if the `KMSKeyArn` key does not exist.  \n\nThe rule skips if `Environment.Variables` field is missing, and there is no error message indicating that environment variables do exist but could not be decrypted due to an Access Denied error.  \nBy default, Lambda manages the encryption of the environment variables using a default service key (`aws/lambda`).  \nIt is recommended to add a KMS CMK so you are in control of the encryption."
  enabled                  = true
  function_as_control      = false
  name                     = "Lambda function environment variables should be encrypted at rest with a KMS customer managed key"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\naccessDeniedMessage := \"Lambda was unable to decrypt your environment variables because the KMS access was denied\"\n\n# check if the error message is the access denied message\ngotAccessDenied {\n\tstartswith(input.message, accessDeniedMessage)\n}{\n\tstartswith(input.Environment.Error.Message, accessDeniedMessage)\t\n}\n\nnoEnvVars {\n\tnot input.Environment.Variables\n\tnot gotAccessDenied\n}\n\nresult := \"skip\" {\n\tnoEnvVars\n} else := \"fail\" {\n\tnot input.KMSKeyArn\n}\n\ncurrentConfiguration := \"'KMSKeyArn' does not exist\"\nexpectedConfiguration := \"Environment variables should be encrypted with a KMS CMK\""
  remediation_instructions = "Perform the following command to configure the function's encryption key via AWS CLI:\n```\naws lambda update-function-configuration \\\n--function-name {{functionName}} \\\n--kms-key-arn <value>\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["lambda"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource = document.Resources[name]\n\tresource.Type == \"AWS::Serverless::Function\"\n\tproperties := resource.Properties\n\n\tproperties.Environment.Variables\n\tnot common_lib.valid_key(properties, \"KmsKeyArn\")\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KmsKeyArn' should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.KmsKeyArn' is undefined or null\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resources\", name, \"Properties\"], []),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource = document.Resources[name]\n\tresource.Type == \"AWS::Lambda::Function\"\n\tproperties := resource.Properties\n\n\tproperties.Environment.Variables\n\tnot common_lib.valid_key(properties, \"KmsKeyArn\")\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KmsKeyArn' should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.KmsKeyArn' is undefined or null\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resources\", name, \"Properties\"], []),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n    resource := input.document[i].resource.aws_lambda_function[name]\n    common_lib.valid_key(resource, \"environment\")\n    not common_lib.valid_key(resource, \"kms_key_arn\")\n\n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceType\": \"aws_lambda_function\",\n        \"resourceName\": terraLib.get_resource_name(resource, name),\n        \"searchKey\": sprintf(\"aws_lambda_function[%s]\", [name]),\n        \"issueType\": \"MissingAttribute\",\n        \"keyExpectedValue\": sprintf(\"'aws_lambda_function[%s].kms_key_arn' should be defined when environment variables are set\", [name]),\n        \"keyActualValue\": sprintf(\"'aws_lambda_function[%s].kms_key_arn' is not defined\", [name]),\n        \"resourceTags\": object.get(resource, \"tags\", {}),\n    }\n}\n\nWizPolicy[result] {\n    resource := input.document[i].resource.aws_lambda_function[name]\n    common_lib.valid_key(resource, \"environment\")\n    common_lib.valid_key(resource, \"kms_key_arn\")\n    terraLib.getValueArrayOrObject(resource.kms_key_arn) == \"\"\n\n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceType\": \"aws_lambda_function\",\n        \"resourceName\": terraLib.get_resource_name(resource, name),\n        \"searchKey\": sprintf(\"aws_lambda_function[%s].kms_key_arn\", [name]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"'aws_lambda_function[%s].kms_key_arn' should not be empty when environment variables are set\", [name]),\n        \"keyActualValue\": sprintf(\"'aws_lambda_function[%s].kms_key_arn' is empty\", [name]),\n        \"resourceTags\": object.get(resource, \"tags\", {}),\n    }\n}\n\nWizPolicy[result] {\n    resource := input.document[i].resource.aws_lambda_function[name]\n    not common_lib.valid_key(resource, \"environment\")\n    common_lib.valid_key(resource, \"kms_key_arn\")\n    count(resource.kms_key_arn) > 0\n\n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceType\": \"aws_lambda_function\",\n        \"resourceName\": terraLib.get_resource_name(resource, name),\n        \"searchKey\": sprintf(\"aws_lambda_function[%s].kms_key_arn\", [name]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"'aws_lambda_function[%s].kms_key_arn' should not be set when there are no environment variables\", [name]),\n        \"keyActualValue\": sprintf(\"'aws_lambda_function[%s].kms_key_arn' is set without environment variables\", [name]),\n        \"resourceTags\": object.get(resource, \"tags\", {}),\n    }\n}"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-8-2" {
  description              = "This rule checks if the CloudTrail Trail status is Logging.  \nThis rule fails if `CloudTrailStatus.IsLogging` is set to `false`.  \nIt is recommended to either start Trail logging or delete the Trail if you do not require it.\n>**Note**  \n>To check if CloudTrail logging is enabled in all regions in your AWS account, see Control `wc-id-844`."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail trail status should be logging"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nloggingStatus := input.CloudTrailStatus.IsLogging\n\nresult = \"fail\" {\n\tloggingStatus == false\n}\n\ncurrentConfiguration := sprintf(\"'IsLogging': '%v'\", [loggingStatus])\nexpectedConfiguration := \"Logging should be enabled\""
  remediation_instructions = "Perform the following command to enable logging on the CloudTrail Trail via AWS CLI:\n```\naws cloudtrail start-logging \\\n\t--name {{trailName}} \\\n\t--region {{trailRegion}}\n```\n>**Note**  \n>For a trail that is enabled in all regions, this operation must be called from the region in which the trail was created. This operation cannot be called on the shadow trails (replicated trails in other regions) of a trail that is enabled in all regions.\n\nIf you no longer require this trail, you can use the following command to delete it:\n```\naws cloudtrail delete-trail \\\n\t--name {{trailName}} \\\n\t--region {{trailRegion}}\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ansLib\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tmodules := {\"community.aws.cloudtrail\", \"cloudtrail\"}\n\tcloudtrail := task[modules[m]]\n\tansLib.checkState(cloudtrail)\n\n\tansLib.isAnsibleFalse(cloudtrail.enable_logging)\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}.enable_logging\", [task.name, modules[m]]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"cloudtrail.enable_logging should be true\",\n\t\t\"keyActualValue\": \"cloudtrail.enable_logging is false\",\n\t\t\"resourceTags\": object.get(cloudtrail, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tresource.Properties.IsLogging == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.IsLogging\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.IsLogging' should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.IsLogging' is false\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudtrail[name]\n\tresource.enable_logging == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail.%s.enable_logging\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_cloudtrail\", name, \"enable_logging\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail.%s.enable_logging should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail.%s.enable_logging is false\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "resource \"aws_cloudtrail\" \"example_cloudtrail\" {\n  enable_logging = true\n}"
    type                     = "TERRAFORM"
  }
}



resource "wiz_control" "op-exp-8-r4-2" {
  description               = "S3 bucket access logging generates logs of requests made to the bucket. This CloudTrail S3 bucket does not have logging enabled.\n\nCloudTrail buckets may contain sensitive information which should be protected from unauthorized access. CloudTrail without logging enabled won't be properly audited for unauthorized access."
  enabled                   = true
  name                      = "CloudTrail S3 Bucket logging disabled"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"select\":true,\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"EQUALS\":[\"S3-001\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"STORES_DATA_IN\"}],\"with\":{\"select\":true,\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"BUCKET\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"bucket\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"STORES_DATA_IN\"}],\"with\":{\"select\":true,\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"BUCKET\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"bucket\"]}}}"
  security_sub_categories   = []
  severity                  = "MEDIUM"
}


resource "wiz_cloud_configuration_rule" "mp-info-6-4" {
  description              = "This rule checks if the Backup Plan Rule includes a S3 Bucket resource.  \nThis rule fails if `Selections.BackupSelection.Resources` includes at least one `arn:aws:s3` resource or `*` - indicating that all resources are included.  It does not take into account any other factors such as conditions, tags, schedule settings, etc.  \nYou can view the resources included in the plan rule and its settings by inspecting the resource JSON in Wiz under `Selections`.\n>**Note**  \nThis rule is informational and does not indicate a misconfiguration."
  enabled                  = true
  function_as_control      = false
  name                     = "Backup Plan Rule includes S3 resources"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"fail\" {\n\tstartswith(input.Selections[_].BackupSelection.Resources[_], \"arn:aws:s3\")\n}{\n\tinput.Selections[_].BackupSelection.Resources[_] == \"*\"\n}\n\ncurrentConfiguration := \"At least one '%v' resource is in the backup plan rule\"\nexpectedConfiguration := \"This rule is informational and does not indicate a misconfiguration\"\n"
  remediation_instructions = "Perform the following steps to create a new backup plan rule via AWS CLI:\n\n1. If you do not already have a Backup Plan that you want to use, you can create one using the command below, otherwise, skip to the next step.  \n1a. Use this template to create a JSON file with your required Backup Plan configuration:\n```\n{\n  \"BackupPlan\":{\n    \"BackupPlanName\":\"test-plan\",\n    \"Rules\":[\n      {\n        \"RuleName\":<\"rule-name\">,\n        \"TargetBackupVaultName\":<\"vault-name>\",\n        \"ScheduleExpression\":<\"cron(0 1 ? * * *)>\",\n        \"ScheduleExpressionTimezone\":<\"America/Los_Angeles\">,\n        \"StartWindowMinutes\":<value>, // Value is integer in minutes\n        \"CompletionWindowMinutes\":<value>, // Value is integer in minutes\n        \"Lifecycle\":{\n          \"DeleteAfterDays\":<value>, // Value is integer in days\n        }\n      }\n    ]\n  }\n}\n```\nStore your JSON document locally with a name you choose.\n\n1b. Use the following command to create the new Backup Plan:\n```\naws backup create-backup-plan --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```\n\n2. In this step we will assign resources to the Backup Plan.  \n2a. Use this template to create a JSON file with your required plan rule configuration:\n```\n{\n  \"BackupPlanId\":<\"BACKUP-PLAN-ID\">, // The plan ID created in the previous command\n  \"BackupSelection\":{\n    \"SelectionName\":<\"selection-name\">, \n    \"IamRoleArn\":<\"arn:aws:iam::ACCOUNT-ID:role/IAM-ROLE-ARN\">,\n    \"Resources\":[\n      <\"arn:aws:ec2:*:*:instance/*\">,\n    ]\n  }\n}\n```\nFor more JSON examples, click [here](https://docs.aws.amazon.com/aws-backup/latest/devguide/assigning-resources.html#assigning-resources-json).  \nStore your JSON document locally with a name you choose.\n\n2b. Use the following command to create the new Backup Plan Rule:\n```\naws backup create-backup-selection --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "INFORMATIONAL"
  target_native_types      = ["backup#backuprule"]
}

resource "wiz_cloud_configuration_rule" "op-acc-6-r4-1" {
  description              = "This rule checks if the AWS Root account is configured with a Hardware Multi-Factor Authentication (MFA) device, and a hardware device only.  \nThis rule fails if `userCredentials.MfaActive` is `false`, indicating that no MFA is configured, or if `userCredentials.MfaActive` is `true` and `virtualMFA.SerialNumber` is configured with a Virtual MFA.  \nThis rule skips if there are no credantials suggesting the root user is managed in the organization.\nMFA adds an extra layer of protection on top of username and password; therefore, it is recommended to use it as a security best practice. Using Hardware MFA is even more efficient than a virtual MFA because it has a minimal attack surface and cannot be hacked unless the malicious actor gains physical access to the hardware device.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "Root account should be configured to use a hardware MFA device and only a hardware MFA device"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nmfaStatus := input.userCredentials.MfaActive\n\nhardwareMfaDisabled {\n\tlower(mfaStatus) == \"false\"\n}{\n\tlower(mfaStatus) == \"true\"\n\tcontains(lower(input.virtualMFA[_].SerialNumber), \":mfa/\")\n}\n\nresult := \"skip\" {\n\tinput.userCredentials.PasswordEnabled == \"false\"\n    \tinput.userCredentials.Cert1Active == \"false\"\n    \tinput.userCredentials.Cert2Active == \"false\"\n\tinput.userCredentials.AccessKey1Active == \"false\"\n    \tinput.userCredentials.AccessKey2Active == \"false\"\n} else := \"fail\" {\n\thardwareMfaDisabled\n}\n\ncurrentConfiguration := \"Root account does not have a Hardware MFA device configured, or a Virtaul MFA is configured\"\nexpectedConfiguration := \"Hardware (and only) MFA should be configured for the Root user\"\n"
  remediation_instructions = "This action is not available via AWS CLI. Use the AWS Management Console instead. Follow [this link](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_enable_physical.html#enable-hw-mfa-for-root) for the steps to enable MFA for the Root account."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["rootUser"]
}

resource "wiz_cloud_configuration_rule" "mp-s-2-1" {
  description              = "This rule checks whether the CloudFront distribution is associated with a WAF web ACL.  \nThis rule fails if the field 'WebACLId' is empty.  \nCloudFront and WAF integration will be able to block any malicious requests made to CloudFront CDN based on the criteria defined in the WAF Web ACL associated with the CDN distribution."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudFront distribution should be associated with a WAF web ACL"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tinput.WebACLId == \"\"\n}\n\ncurrentConfiguration := \"The field 'WebACLId' is empty\"\nexpectedConfiguration := \"The field 'WebACLId' should be set to a WAF web ACL that is associated with the CloudFront distribution\""
  remediation_instructions = "Perform the following commands to associate the CloudFront distribution with a WAF web ACL via AWS CLI:  \n1. Use the following command to get the `ETag` and save it for further steps:  \n```  \nexport ETag=$(aws cloudfront get-distribution-config --id {{distributionID}} --query='ETag' --output=text)  \n```  \n2. Use the following command to get the configuration of the CloudFront distribution and write it to a new file:  \n```  \naws cloudfront get-distribution-config --id {{distributionID}} --query='DistributionConfig' > DistributionConfig.json  \n```  \n3. Edit the ***DistributionConfig.json*** file:    \n&nbsp;&nbsp;&nbsp;&nbsp;**a.** Set the `WebACLId` value to a specific 'WebACL ARN'    \n4. Use the following command:  \n```  \naws cloudfront update-distribution --id {{distributionID}} --distribution-config file://DistributionConfig.json --if-match $ETag  \n```  \n5. Optional - Use the following command in order to delete the ***DistributionConfig.json*** file:  \n```  \nrm DistributionConfig.json  \n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["cloudfront"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::CloudFront::Distribution\"\n\tdistributionConfig := resource.Properties.DistributionConfig\n\n\tnot cloudFormationLib.isCloudFormationFalse(distributionConfig.Enabled)\n\tnot common_lib.valid_key(distributionConfig, \"WebACLId\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.DistributionConfig\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.DistributionConfig.WebACLId should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.DistributionConfig.WebACLId is undefined\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudfront_distribution[name]\n\tresource.enabled == true\n\tnot resource.web_acl_id\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudfront_distribution\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudfront_distribution[%s].web_acl_id\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"'web_acl_id'  should exist\",\n\t\t\"keyActualValue\": \"'web_acl_id' is missing\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudfront_distribution](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudfront_distribution)"
    type                     = "TERRAFORM"
  }
}



resource "wiz_control" "op-exp-8-r1-8" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor management console authentications without MFA.\n\nIt is recommended to set an alarm that will be triggered for every console sign-in request without multi-factor authentication. Monitoring single-factor authentication attempts help to detect account without MFA which affect the security posture."
  enabled                   = false
  name                      = "Subscription without CloudWatch monitoring for management console authentications wit no MFA"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 9\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}

resource "wiz_cloud_configuration_rule" "op-acc-4-11" {
  description              = "This rule checks whether the root user credentials have been used in the last 14 days.  \nThis rule fails if `AccessKey1LastUsedDate`, `AccessKey2LastUsedDate`, or `PasswordLastUsed` have been used in the last 14 days.  \nThe root user has full permissions across the entire account, therefore it is important to minimize its usage. To reduce the risk of accidental changes and unintended disclosure of highly privileged credentials, it is necessary to adopt the principle of least privilege (POLP).  \nFurthermore, it is recommended to limit the use of the root user and not use it for everyday or administrative tasks, along with deleting the root user access keys."
  enabled                  = true
  function_as_control      = false
  name                     = "Root account usage should be reduced as possible"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\ncreds := input.userCredentials\nnow_ns := time.now_ns()\nweek_days_ns := time.parse_duration_ns(\"336h\") # 14d in hours\n\ncheckTime(t) {\n\t(now_ns - time.parse_rfc3339_ns(creds[t[_]])) <= week_days_ns\n}\n\nresult = \"fail\" {\n\tlower(creds.AccessKey1Active) == \"true\"\n\tcheckTime([\"AccessKey1LastUsedDate\"])\n}{\n\tlower(creds.AccessKey2Active) == \"true\"\n\tcheckTime([\"AccessKey2LastUsedDate\"])\n}{\n\tcheckTime([\"PasswordLastUsed\"])\n}"
  remediation_instructions = "Perform the following steps, while being signed in as the Root user, in order to delete the root user's access keys via AWS CLI:    \n1. Use the following command to list the Root user's access keys.    \nCopy the `AccessKeyId` from the output and paste it into the `access-key-id` value in the next step.  \n```  \naws iam list-access-keys  \n```  \n2. Use the following command to delete the access key(s).  \n```  \naws iam delete-access-key \\\n    --access-key-id <value>  \n```  \n>**Note**    \nOnce an access key is removed, any application using it will not work until a new one is configured for it.    \nIn addition to access keys, this rule fails if the Root account has logged into the AWS Console using the root password. The remediation step above does not support that case. To change the Root user console password follow the steps [here](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_change-root.html)."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["rootUser"]
}

resource "wiz_control" "op-exp-8-r1-15" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor management console authentication failures.\n\nIt is recommended to set an alarm that will be triggered for every failed console login occurs. Monitoring failed console logins helps implement appropriate security measures and decreases the time to detect malicious activity."
  enabled                   = false
  name                      = "Subscription wit no CloudWatch monitoring for management console authentication failures"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 3\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}

resource "wiz_cloud_configuration_rule" "mp-com-2-1" {
  description              = "This rule checks if the Virtual Network Gateway is using the Basic SKU pricing tier.  \nThis rule skips `gatewayType` that are not `Vpn` (excludes ExpressRoute), and fails if `sku.tier` is set to `Basic`.  \nThe Basic SKU is a legacy SKU and has feature limitations. In order to move from Basic to another SKU, you must delete the Basic SKU VPN gateway and create a new gateway with the desired Generation and SKU size combination.\nIt is recommended to replace the VPN Gateway with a different SKU tier."
  enabled                  = true
  function_as_control      = false
  name                     = "VPN Gateway should not use 'basic' SKU"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"skip\" {\nlower(input.properties.gatewayType) != \"vpn\"\n} else = \"fail\" {\nlower(input.properties.sku.tier) == \"basic\"\n}\n\ncurrentConfiguration := \"VPN Gateway is using the 'Basic' SKU\"\nexpectedConfiguration := \"VPN Gateway should not use the 'Basic' SKU\""
  remediation_instructions = "In order to move from Basic to another SKU, you must delete the Basic SKU VPN gateway and create a new gateway with the desired Generation and SKU size combination.    \nClick [here](https://docs.microsoft.com/en-us/azure/vpn-gateway/tutorial-create-gateway-portal) to see Azure's tutorial for creating a new VPN gateway."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["Microsoft.Network/virtualNetworkGateways"]
}

resource "wiz_cloud_configuration_rule" "op-acc-6-3" {
  description              = "This rule checks whether the IAM password policy is set to expire passwords after 90 days.  \nThis rule fails if `MaxPasswordAge` is less than 90, or if `accountPasswordPolicy` does not exist.  \nEnforcing IAM password strength, pattern, and rotation is a critical security practice, as having a strong password policy significantly reduces the risk of brute-force attacks.  \nIt is recommended that the password policy be set to expire passwords after 90 days or less."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM password policy should expire passwords within 90 days"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nlongValidityPeriod {\n\tnot input.accountPasswordPolicy.MaxPasswordAge <= 90\n}{\n\tnot input.accountPasswordPolicy\n}\n\nresult = \"fail\" {\n\tlongValidityPeriod\n}\n\ncurrentConfiguration := \"'ExpirePasswords' is set to False\"\nexpectedConfiguration := \"Password should expire after 90 days\"\n"
  remediation_instructions = "Perform the following command to edit the IAM password policy enforcement/s via AWS CLI:  \n```  \naws iam update-account-password-policy \\\n  --max-password-age <recommended: 90 (days) or less> \\\n  [--minimum-password-length <recommended: 14 (characters) or more>] \\\n  [--require-symbols] \\\n  [--require-numbers] \\\n  [--require-uppercase-characters] \\\n  [--require-lowercase-characters] \\ \n  [--password-reuse-prevention <recommended: 10 or more>]  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["account"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\texpr := input.document[i].resource.aws_iam_account_password_policy[name]\n\tnot expr.max_password_age\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(expr, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s]\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name], []),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"'max_password_age' should exist\",\n\t\t\"keyActualValue\": \"'max_password_age' is missing\",\n\t\t\"remediation\": \"max_password_age = 90\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(expr, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\texpr := input.document[i].resource.aws_iam_account_password_policy[name]\n\texpr.max_password_age > 90\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(expr, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s].max_password_age\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name, \"max_password_age\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'max_password_age' should be lower than 90\",\n\t\t\"keyActualValue\": \"'max_password_age' is higher than 90\",\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": sprintf(\"%d\", [expr.max_password_age]),\n\t\t\t\"after\": \"90\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(expr, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_account_password_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_account_password_policy)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_threat_detection_rule" "op-exp-8-5" {
  cloud_providers                     = null
  description                         = "This rule detects if an API caller has not been authorized to perform an operation."
  enabled                             = true
  generate_findings                   = false
  generate_issues                     = false
  name                                = "AWS API caller unauthorized"
  perform_cloud_event_type_validation = null
  project                             = null
  security_sub_categories             = ["wsct-id-6533", "wsct-id-10681"]
  severity                            = "INFORMATIONAL"
  params {
    cloud_providers    = ["AWS"]
    filters            = "{\"and\":[{\"rawAuditLogRecordPath\":{\"equals\":[false],\"path\":\"readOnly\"}},{\"rawAuditLogRecordPath\":{\"equals\":[\"AwsApiCall\"],\"path\":\"eventType\"}},{\"rawAuditLogRecordPath\":{\"equals\":[\"NotAuthorizedException\"],\"path\":\"errorCode\"}},{\"rawAuditLogRecordPath\":{\"notEquals\":[\"User password cannot be reset in the current state.\",\"Refresh Token has expired\",\"User cannot be confirmed. Current status is CONFIRMED\"],\"path\":\"errorMessage\"}}]}"
    opa_matcher        = null
    target_event_names = []
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-6-r5-1" {
  description              = "This rule checks whether CloudTrail at the account level is configured as multi-region, global service logging is enabled, and management events are configured for all read/write operations.  \nEnsuring that a multi-region trail exists assists with detecting when unexpected activity occurs.  \nWhen global service logging is enabled, events on AWS global services are recorded as well. In addition, to ensure management operations performed on all resources are recorded as well, management events should be configured for all read/write operations."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail logging should be enabled in all regions - Account level"
  opa_policy               = "package wiz\n\ndefault result = \"fail\"\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\tlower(readOrWrite.Field) == \"readonly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tlower(currSelector.Field) == lower(currField)\n\tlower(currSelector.Equals[_]) == lower(currValue)\n}\n\n#returns value if configuration is good\nselectors[event] {\n\t#basic\n\tevent := input.EventSelectors[i]\n\tevent.IncludeManagementEvents\n\tlower(event.ReadWriteType) == \"all\"\n}{\n\t#advanced\n\tevent := input.AdvancedEventSelectors[i]\n  \tcheckFieldSelector(event.FieldSelectors[_], \"eventCategory\", \"Management\")\n\tnot advanReadAndWrite(event.FieldSelectors)\n}\n\nresult = \"skip\" { #if organiztion level\n\tinput.IsOrganizationTrail\n}\nelse = \"pass\" {\n\tinput.IsMultiRegionTrail\n\tinput.CloudTrailStatus.IsLogging\n\tcount(selectors) > 0\n}\ncurrentConfiguration := sprintf(\"IsMultiRegionTrail setting is set to: %s. IsLogging is set to: %s. Required event selector exists: %s\", [input.IsMultiRegionTrail, input.CloudTrailStatus.IsLogging, count(selectors) > 0])\nexpectedConfiguration := \"IsMultiRegionTrail and IsLogging should be set to true. There should be at least one event selector with IncludeManagementEvents set to true and ReadWriteType set to 'All'\"\n"
  remediation_instructions = "Perform the following commands in order to modify CloudTrail via CLI:  \n1. Use the following command in order to enable Multi-region CloudTrail logging:  \n```  \naws cloudtrail update-trail --name {{trailName}} --is-multi-region-trail  \n```  \n2. Use the following command in order to start CloudTrail logging:  \n```  \naws cloudtrail start-logging --name {{trailName}}  \n```  \n3. Use the following command in order to modify CloudTrail event selectors:  \n```  \naws cloudtrail put-event-selectors --trail-name {{trailName}} --event-selectors '[{\"ReadWriteType\": \"All\",\"IncludeManagementEvents\": true}]'  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tcommon_lib.valid_key(resource.Properties, \"IsMultiRegionTrail\")\n\tnot checkRegion(resource)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.IsMultiRegionTrail\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' is false\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tnot common_lib.valid_key(resource.Properties, \"IsMultiRegionTrail\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' should exist\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' is missing\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\ncheckRegion(cltr) {\n\tcltr.Properties.IsMultiRegionTrail == true\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nisOrganizationLevel(cloudtrailResource) {\n\tcloudtrailResource.is_organization_trail == true\n}\n\nisMultiRegionTrail(cloudtrailResource) {\n\tcloudtrailResource.is_multi_region_trail == true\n}\n\n#check for read and write permissions in basic event selectors\nbasicReadAndWrite(eventSel) {\n\teventSel.read_write_type == \"All\"\n}\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\treadOrWrite.field == \"readOnly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tcurrSelector.field == currField\n\tcurrSelector.equals[_] == currValue\n}\n\nadvancedEventSelectorWithManagementEvents(currEventSel) {\n  \tcheckFieldSelector(currEventSel[_], \"eventCategory\", \"Management\")\n  \tnot advanReadAndWrite(currEventSel)\n}\n\nbasicResourcesWithManagementEvents(eventSel) {\n\teventSel.include_management_events == true\n}\n\n#seperate checks for advanced single and multi selectors\nadvancedEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.advanced_event_selector[_]\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.advanced_event_selector\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\t\n}\n\n#seperate checks for basic single and multi event selectors\nbasicEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.event_selector[_]\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.event_selector\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}\n\n#check event selector for basic and advanced resources\nconfiguredWithManagementEvents(cloudtrailResource) {\n\t# Basic \n\tbasicEventSelc(cloudtrailResource)\n}{ \n\t# Advanced\n\tadvancedEventSelc(cloudtrailResource)\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[cloudtrailName]\n    \n\tnot configuredWithManagementEvents(cloudtrailResource)\n\tnot isOrganizationLevel(cloudtrailResource)\n\tisMultiRegionTrail(cloudtrailResource)\n\t\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, cloudtrailName),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [cloudtrailName]),\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s] should be configured with management events and multi region\",[cloudtrailName]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s] is not configured with management events and multi region\",[cloudtrailName]),\n  \t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {})\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\n\tnot common_lib.valid_key(cloudtrailResource, \"is_multi_region_trail\")\n\tnot isOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].is_multi_region_trail' should be defined (and not null)\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].is_multi_region_trail' is undefined or null\", [name]),\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\n\tcloudtrailResource.is_multi_region_trail == false\n\tnot isOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].is_multi_region_trail' should be 'true'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].is_multi_region_trail' is set to 'false'\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\n\tcloudtrailResource.enable_logging == false\n\tnot isOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].enable_logging\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].enable_logging' should be 'true'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].enable_logging' is set to 'false'\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\n\tcloudtrailResource.include_global_service_events == false\n\tnot isOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].include_global_service_events\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].include_global_service_events' should be 'true'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].include_global_service_events' is set to 'false'\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudtrail](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudtrail)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-6-1" {
  description              = "This rule checks if there is more than one active access key for a single user.  \nThis rule fails if both `AccessKey1Active` and `AccessKey2Active` are set to `true`.  \nEach IAM user can have up to two access keys. Having two access keys (instead of one) increases the risk of unauthorized access and compromise of credentials.  \nIt is recommended to delete any unused access keys."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM User should have only one active access key"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tlower(input.userCredentials.AccessKey1Active) == \"true\"\n    lower(input.userCredentials.AccessKey2Active) == \"true\"\n}\n\ncurrentConfiguration := \"Both access keys are active\"\nexpectedConfiguration := \"Only one access key should be enabled\""
  remediation_instructions = "Perform the following steps to delete one of the active access keys via AWS CLI:    \n1. Use the following command to list the access keys of the user:    \n```  \naws iam list-access-keys \\\n\t--user-name {{userName}}  \n```  \n2. Use the following command to delete one of the user's access keys.    \nCopy the `AccessKeyId` output of one of the access keys, and paste the value into the `access-key` parameter.  \n```  \naws iam delete-access-key \\\n\t--access-key <value> \\\n\t--user-name {{userName}}  \n```  \n>**Note**    \nOnce an access key is removed, any application using it will not work until a new one is configured for it."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["rootUser", "user"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::IAM::AccessKey\"\n\tuser := resource.Properties.UserName\n\tfindAnotherAccessKey(name, user)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s' is the only AccessKey of user '%s'\", [name, user]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s' is not the only AccessKey of user '%s'\", [name, user]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nfindAnotherAccessKey(firstKey, userName) {\n\tkey := input.document[_].Resources[secondKey]\n\tfirstKey != secondKey\n\tkey.Properties.UserName == userName\n} else = false {\n\ttrue\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_iam_user[name]\n    \n    hasMoreThanOneAccessKey(resource, name)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_user\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_user[%s].name\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"One Access Key associated with the same IAM User\",\n\t\t\"keyActualValue\": \"More than one Access Key associated with the same IAM User\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\n\nhasMoreThanOneAccessKey(user, userName) {\n\tcount({x | r := input.document[_].resource.aws_iam_access_key[x]; split(r.user, \".\")[1] == userName}) > 1 \n} {\n\tcount({x | r := input.document[_].resource.aws_iam_access_key[x]; r.user == user.name}) > 1 \n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_user](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user), [aws_iam_access_key](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_access_key)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-6-r7-1" {
  description              = "This rule checks whether the IAM user's access keys have been used in the past 30 days.  \nThis rule fails if an active access key was not used in this timeframe. Unnecessary credentials increase the window of opportunity for compromised accounts to be used.  \nIf one or more access key sets are older than 30 days, the keys are most likely associated with a compromised or abandoned IAM user account; therefore, it is recommended that these credentials are disabled or removed."
  enabled                  = true
  function_as_control      = false
  name                     = "Access keys unused for 30 days or more should be disabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nnow_ns := time.now_ns()\ndays_30_ns := time.parse_duration_ns(\"720h\") # 30 days\n\nunusedCredentials[credential] {\n\tnot now_ns - time.parse_rfc3339_ns(input.userCredentials.AccessKey1LastUsedDate) < days_30_ns\n\tlower(input.userCredentials.AccessKey1Active) == \"true\"\n\tcredential = \"access key 1\"\n}\n\nunusedCredentials[credential] {\n\tinput.userCredentials.AccessKey1LastUsedDate = \"N/A\"\n\tnot now_ns - time.parse_rfc3339_ns(input.userCredentials.AccessKey1LastRotated) < days_30_ns\n\tlower(input.userCredentials.AccessKey1Active) == \"true\"\n\tcredential = \"access key 1\"\n}\n\nunusedCredentials[credential] {\n\tinput.userCredentials.AccessKey2LastUsedDate = \"N/A\"\n\tnot now_ns - time.parse_rfc3339_ns(input.userCredentials.AccessKey2LastRotated) < days_30_ns\n\tlower(input.userCredentials.AccessKey2Active) == \"true\"\n\tcredential = \"access key 2\"\n}\n\nunusedCredentials[credential] {\n\tnot now_ns - time.parse_rfc3339_ns(input.userCredentials.AccessKey2LastUsedDate) < days_30_ns\n\tlower(input.userCredentials.AccessKey2Active) == \"true\"\n\tcredential = \"access key 2\"\n}\n\nresult = \"fail\" {\n\tnow_ns - time.parse_rfc3339_ns(input.CreateDate) > days_30_ns\n    count(unusedCredentials) > 0\n}\n\ncurrentConfiguration := concat(\"\",[\"Access keys have not been used in the past 30 days: \",concat(\", \", unusedCredentials)])\nexpectedConfiguration := \"Access keys unused for 30 days or more should be disabled or removed\"\n"
  remediation_instructions = "Perform the following steps to disable access keys and\\or disable console access via AWS CLI:    \n### Disable access keys  \n1. Use the following command to list the access keys of the user:  \n```  \naws iam list-access-keys \\\n    --user-name {{userName}}  \n```  \n2. Use the following command to disable the access keys.    \nCopy the `AccessKeyId` output of active access keys, and paste the value into the `access-key` parameter. If there is more than one, run the next command twice, once for each Key ID.  \n```  \naws iam update-access-key \\\n    --access-key <value> \\\n    --status Inactive \\\n    --user-name {{userName}}  \n```  \n>**Note**   \nOnce an access key is disabled, any application using it will not work until a new one is configured for it.  \n### Disable console access  \nUse the following command to disable the user's console access:  \n```  \naws iam delete-login-profile \\\n    --user-name {{userName}}  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["user"]
}

resource "wiz_cloud_configuration_rule" "mp-info-6-3" {
  description              = "This rule checks if the Backup Plan Rule includes an EC2 instance resource.  \nThis rule fails if `Selections.BackupSelection.Resources` includes at least one `arn:aws:ec2*instance` resource or `*` - indicating that all resources are included. It does not take into account any other factors such as conditions, tags, schedule settings, etc.  \nYou can view the resources included in the plan rule and its settings by inspecting the resource JSON in Wiz under `Selections`.\n>**Note**  \nThis rule is informational and does not indicate a misconfiguration."
  enabled                  = true
  function_as_control      = false
  name                     = "Backup Plan Rule includes EC2 resources"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"fail\" {\n\tregex.match(\"^arn:aws:ec2:.*:instance\", input.Selections[_].BackupSelection.Resources[_])\n}{\n\tinput.Selections[_].BackupSelection.Resources[_] == \"*\"\n}\n\ncurrentConfiguration := \"At least one EC2 instance resource is included in the backup plan rule\"\nexpectedConfiguration := \"This rule is informational and does not indicate a misconfiguration\"\n"
  remediation_instructions = "Perform the following steps to create a new backup plan rule via AWS CLI:\n\n1. If you do not already have a Backup Plan that you want to use, you can create one using the command below, otherwise, skip to the next step.  \n1a. Use this template to create a JSON file with your required Backup Plan configuration:\n```\n{\n  \"BackupPlan\":{\n    \"BackupPlanName\":\"test-plan\",\n    \"Rules\":[\n      {\n        \"RuleName\":<\"rule-name\">,\n        \"TargetBackupVaultName\":<\"vault-name>\",\n        \"ScheduleExpression\":<\"cron(0 1 ? * * *)>\",\n        \"ScheduleExpressionTimezone\":<\"America/Los_Angeles\">,\n        \"StartWindowMinutes\":<value>, // Value is integer in minutes\n        \"CompletionWindowMinutes\":<value>, // Value is integer in minutes\n        \"Lifecycle\":{\n          \"DeleteAfterDays\":<value>, // Value is integer in days\n        }\n      }\n    ]\n  }\n}\n```\nStore your JSON document locally with a name you choose.\n\n1b. Use the following command to create the new Backup Plan:\n```\naws backup create-backup-plan --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```\n\n2. In this step we will assign resources to the Backup Plan.  \n2a. Use this template to create a JSON file with your required plan rule configuration:\n```\n{\n  \"BackupPlanId\":<\"BACKUP-PLAN-ID\">, // The plan ID created in the previous command\n  \"BackupSelection\":{\n    \"SelectionName\":<\"selection-name\">, \n    \"IamRoleArn\":<\"arn:aws:iam::ACCOUNT-ID:role/IAM-ROLE-ARN\">,\n    \"Resources\":[\n      <\"arn:aws:ec2:*:*:instance/*\">,\n    ]\n  }\n}\n```\nFor more JSON examples, click [here](https://docs.aws.amazon.com/aws-backup/latest/devguide/assigning-resources.html#assigning-resources-json).  \nStore your JSON document locally with a name you choose.\n\n2b. Use the following command to create the new Backup Plan Rule:\n```\naws backup create-backup-selection --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "INFORMATIONAL"
  target_native_types      = ["backup#backuprule"]
}

resource "wiz_cloud_configuration_rule" "op-acc-6-r1-3" {
  description              = "This rule checks whether the IAM password policy is set to require at least one lowercase letter.  \nThis rule fails if `RequireLowercaseCharacters` is set to `false`,\nor if `accountPasswordPolicy` does not exist.  \nEnforcing IAM password strength, pattern, and rotation is a critical security practice, as having a strong password policy significantly reduces the risk of brute-force attacks.  \nAs a security best practice, it is recommended that users are required to have a strong password."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM password policy should require at least one lowercase letter"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tnot input.accountPasswordPolicy.RequireLowercaseCharacters\n} {\n\tnot input.accountPasswordPolicy\n}\n\ncurrentConfiguration := \"'RequireLowercaseCharacters' is set to False\"\nexpectedConfiguration := \"Lowercase characters should be required\""
  remediation_instructions = "Perform the following command to edit the IAM password policy enforcement/s via AWS CLI:  \n```  \naws iam update-account-password-policy \\\n  --require-lowercase-characters \\\n  [--password-reuse-prevention <recommended: 10 or more>] \\\n  [--max-password-age <recommended: 90 (days) or less>] \\\n  [--minimum-password-length <recommended: 14 (characters) or more>] \\\n  [--require-symbols] \\\n  [--require-numbers] \\\n  [--require-uppercase-characters]  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["account"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tpassword := resource.Properties.LoginProfile.Password\n\tis_string(password)\n\tnot contains(lower(password), \"secretsmanager\")\n\tnot regex.match(\".*[a-z]\", password)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.LoginProfile.Password\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'Resources.Properties.LoginProfile.Password' should contain lowercase letter\",\n\t\t\"keyActualValue\": \"'Resources.Properties.LoginProfile.Password' doesn't contain lowercase letter\",\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tpassword_policy := input.document[i].resource.aws_iam_account_password_policy[name]\n\tnot common_lib.valid_key(password_policy, \"require_lowercase_characters\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(password_policy, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s]\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name], []),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"'require_lowercase_characters' should be set with true value\",\n\t\t\"keyActualValue\": \"'require_lowercase_characters' is undefined\",\n\t\t\"remediation\": \"require_lowercase_characters = true\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(password_policy, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tpassword_policy := input.document[i].resource.aws_iam_account_password_policy[name]\n\tpassword_policy.require_lowercase_characters == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(password_policy, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s].require_lowercase_characters\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name, \"require_lowercase_characters\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'require_lowercase_characters' should be true\",\n\t\t\"keyActualValue\": \"'require_lowercase_characters' is false\",\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(password_policy, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_account_password_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_account_password_policy)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-6-r1-4" {
  description              = "This rule checks whether the IAM password policy is set to require at least one number.  \nThis rule fails if `RequireNumbers` is set to `false`, or if `accountPasswordPolicy` does not exist.  \nEnforcing IAM password strength, pattern, and rotation is a critical security practice, as having a strong password policy significantly reduces the risk of brute-force attacks.  \nIt is recommended that users are required to have a strong password."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM password policy should require at least one number"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tnot input.accountPasswordPolicy.RequireNumbers\n}\n\ncurrentConfiguration := \"'RequireNumbers' is set to False\"\nexpectedConfiguration := \"Digits should be required\""
  remediation_instructions = "Perform the following command to edit the IAM password policy enforcement/s via AWS CLI:  \n```  \naws iam update-account-password-policy \\\n  --require-numbers \\\n  [--require-uppercase-characters] \\\n  [--require-lowercase-characters] \\\n  [--password-reuse-prevention <recommended: 10>] \\\n  [--max-password-age <recommended: 90 (days) or less>] \\\n  [--minimum-password-length <recommended: 14>] \\\n  [--require-symbols]  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["account"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tpassword := resource.Properties.LoginProfile.Password\n\tis_string(password)\n\tnot contains(lower(password), \"secretsmanager\")\n\tnot regex.match(\".*\\\\d\", password)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.LoginProfile.Password\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'Resources.Properties.LoginProfile.Password' should contain number\",\n\t\t\"keyActualValue\": \"'Resources.Properties.LoginProfile.Password' doesn't contain number\",\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\npasswordDoesNotRequireNumbers(password_policy) {\n\tnot common_lib.valid_key(password_policy, \"require_numbers\")\n}{\n\tpassword_policy.require_numbers == false\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tpassword_policy := doc.resource.aws_iam_account_password_policy[name]\n\n\tpasswordDoesNotRequireNumbers(password_policy)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(password_policy, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s]\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name], []),\n\t\t\"keyExpectedValue\": \"'require_numbers' should be set to 'true'\",\n\t\t\"keyActualValue\": \"'require_numbers' is undefined or 'false'\",\n\t\t\"resourceTags\": object.get(password_policy, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "resource \"aws_iam_account_password_policy\" \"example_password_policy\" {\n  require_numbers = true\n}"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-exp-7-1" {
  description              = "This rule checks whether GuardDuty CloudTrail protection is enabled.  \nThis rule fails if the GuardDuty `CLOUD_TRAIL` within the `Features` list has `Status` set to `DISABLED`.  \nGuardDuty CloudTrail protection is a crucial security feature that analyzes AWS CloudTrail management events to detect potential security threats and malicious activities in your AWS environment. By enabling this feature, you enhance your ability to identify and respond to security issues, such as unauthorized API calls, changes to security groups, or modifications to IAM policies.  \nIt is recommended to enable GuardDuty CloudTrail protection to improve your overall security posture and maintain comprehensive threat detection capabilities across your AWS infrastructure.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty CloudTrail should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"CLOUD_TRAIL\"\n\nfeatureDisabled {\n\tupper(input.Features[i].Name) == protection\n\tupper(input.Features[i].Status) == \"DISABLED\"\n}\n\nresult = \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])\n"
  remediation_instructions = "Perform the following command to enable GuardDuty CloudTrail via AWS CLI:\n\n```\naws guardduty update-detector \\\n    --detector-id {{detectorId}} \\\n    --data-sources '{\"CloudTrail\": {\"Status\": \"ENABLED\"}}'\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tnot common_lib.valid_key(resource, \"datasources\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].datasources should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].datasources is undefined or null\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tdatasources := terraLib.getValueArrayOrObject(resource.datasources)\n\tnot common_lib.valid_key(datasources, \"cloudtrail\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s].datasources\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].datasources.cloudtrail should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].datasources.cloudtrail is undefined or null\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name, \"datasources\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tdatasources := terraLib.getValueArrayOrObject(resource.datasources)\n\tcloudtrail := terraLib.getValueArrayOrObject(datasources.cloudtrail)\n\tcloudtrail.enable == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s].datasources.cloudtrail.enable\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].datasources.cloudtrail.enable should be set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].datasources.cloudtrail.enable is set to false\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name, \"datasources\", \"cloudtrail\", \"enable\"], []),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "resource \"aws_guardduty_detector\" \"example_detector\" {\n  datasources {\n    cloudtrail {\n      enable = true\n    }\n  }\n}"
    type                     = "TERRAFORM"
  }
}

resource "wiz_control" "op-exp-8-r1-6" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor CloudTrail configuration changes.\n\nIt is recommended to set an alarm that will be triggered for every CloudTrail configuration change (create, delete, update, start, or stop). Monitoring changes to CloudTrail configurations helps preserve the service configuration and prevent unauthorized actions."
  enabled                   = true
  name                      = "Subscription with no CloudWatch monitoring for CloudTrails"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 6\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}

resource "wiz_cloud_configuration_rule" "op-exp-7-5" {
  description              = "This rule checks whether the RDS Protection feature in Amazon GuardDuty is enabled.  \nThis rule fails if the `RDS_LOGIN_EVENTS` status is disabled.  \nAmazon GuardDuty is a threat detection service that continuously monitors for malicious or unauthorized behavior to help protect AWS accounts and workloads. Enabling RDS Protection in GuardDuty enhances the monitoring and security of your RDS databases by identifying unusual and potentially unauthorized or malicious activity.\nIt is recommended to enable RDS Protection for better security monitoring of RDS database instances."
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty Detector RDS Protection should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"RDS_LOGIN_EVENTS\"\n\nfeatureDisabled {\n\tupper(input.Features[feature].Name) == protection\n\tupper(input.Features[feature].Status) == \"DISABLED\"\n}\n\n\nresult = \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])\n"
  remediation_instructions = "Perform the following command to enable RDS Protection for GuardDuty via AWS CLI:\n\n```\naws guardduty update-member-detectors \\\n--detector-id {{detectorID}} \\\n--account-ids {{accountID}} \\\n--features '[{\"Name\": \"RDS_LOGIN_EVENTS\", \"Status\": \"ENABLED\"}]'\n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\n\nrelatedFeature(document, detectorName){\n\tfeature := document.resource.aws_guardduty_detector_feature[featureName]\n\tfeature.name == \"RDS_LOGIN_EVENTS\"\n\tfeature.status == \"ENABLED\"\n\tterraLib.associatedResources(null, feature, detectorName, null, null, \"detector_id\")\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.resource.aws_guardduty_detector[detectorName]\n    \n\tnot relatedFeature(document, detectorName)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, detectorName),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s]\", [detectorName]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s] should have aws_guardduty_detector_feature with RDS_LOGIN_EVENTS associated and enabled\", [detectorName]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s] has no aws_guardduty_detector_feature with RDS_LOGIN_EVENTS associated and enabled\", [detectorName]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "resource \"aws_guardduty_detector_feature\" \"example_feature\" {\n  detector_id = aws_guardduty_detector.example_detector.id\n  name        = \"RDS_LOGIN_EVENTS\"\n  status      = \"ENABLED\"\n}"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-6-r2-1" {
  description              = "This rule checks whether the AWS root account has Multi-Factor Authentication (MFA) enabled.  \nThis rule fails if `MfaActive` is set to `false`. \nThis rule skips if either one of the following conditions is met:\n* There are no credentials at all\n* All possible authentication methods are disabled/inactive\n\nMFA adds an extra layer of protection on top of a username and password. With MFA enabled, when a user signs in to an AWS website, they will be prompted for their username and password as well as for an authentication code from their AWS MFA device. Enabling MFA provides increased security for console access as it requires the authenticating principals to possess a device that emits a time-sensitive key and have knowledge of a credential.  \nIt is recommended to enforce that MFA be enabled for all users who have a console password, but especially for the root account.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "Root account should have MFA enabled"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"skip\" {\n\tnot input.userCredentials\n} else := \"skip\" {\n\tinput.userCredentials.PasswordEnabled == \"false\"\n\tinput.userCredentials.Cert1Active == \"false\"\n\tinput.userCredentials.Cert2Active == \"false\"\n\tinput.userCredentials.AccessKey1Active == \"false\"\n\tinput.userCredentials.AccessKey2Active == \"false\"\n} else := \"fail\" {\n\tlower(input.userCredentials.MfaActive) == \"false\"\n}\n\ncurrentConfiguration := \"'MfaActive' is set to false\"\nexpectedConfiguration := \"Multi factor authentication should be enabled\"\n"
  remediation_instructions = "This action is not available via AWS CLI. Use the AWS Management Console instead. Follow [this link](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_enable_virtual.html#enable-virt-mfa-for-root) for the steps to enable MFA for the Root account."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["rootUser"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_iam_user_policy[name]\n\n\tpolicy := common_lib.json_unmarshal(resource.policy)\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tstatement.Action == \"sts:AssumeRole\"\n\tcommon_lib.is_allow_effect(statement)\n\tcheck_root(statement, resource)\n\tnot check_mfa(statement)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_user_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_user_policy[%s].policy\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'policy.Statement.Principal.AWS' should contain ':mfa/' or 'policy.Statement.Condition.BoolIfExists.aws:MultiFactorAuthPresent' should be set to true\",\n\t\t\"keyActualValue\": \"'policy.Statement.Principal.AWS' doesn't contain ':mfa/' or 'policy.Statement.Condition.BoolIfExists.aws:MultiFactorAuthPresent' is set to false\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_user_policy\", name, \"policy\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\ncheck_mfa(statement) {\n\tstatement.Condition.BoolIfExists[\"aws:MultiFactorAuthPresent\"] == \"true\"\n} else {\n\tuser := statement.Principal.AWS\n\tcontains(user, \":mfa/\")\n} else {\n\tuser := statement.Principal.AWS[_]\n\tcontains(user, \":mfa/\")\n}\n\ncheck_root(statement, resource) {\n\tuser := statement.Principal.AWS\n\tcontains(user, \"root\")\n} else {\n\tuser := statement.Principal.AWS[_]\n\tcontains(user, \"root\")\n} else {\n\tterraLib.anyPrincipal(statement)\n} else {\n\toptions := {\"user\", \"name\"}\n\tcontains(resource[options[_]], \"root\")\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_user_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_policy)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_control" "op-exp-8-r1-10" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor S3 bucket configuration changes. \n\nIt is recommended to set an alarm that will be triggered for every S3 bucket configuration change. Monitoring changes to S3 bucket configurations helps prevent accidental or undesirable data access and modification."
  enabled                   = false
  name                      = "Subscription with no CloudWatch monitoring for S3 Buckets"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 15\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}

resource "wiz_cloud_configuration_rule" "mp-com-3-2" {
  description              = "This rule checks whether the S3 Bucket policy does not deny HTTP requests.  \nThis rule fails if the `bucketPolicy` does *not* contain a `Statement` where:\n* `Effect` is set to `Deny`\n* `Action` contains a wildcard (`*` or `s3:*`)\n* `Principal` contains a wildcard (`*` or `AWS:*`)\n* `Condition` contains at least one of the following:\n    * `Bool.aws:SecureTransport` is set to `false`\n    * `NumericLessThan.s3:tlsversion` exists and `Bool.aws:SecureTransport` set to `true`does not exist.\n    \nTo allow access to HTTPS, you can use a condition that checks for the key `aws:SecureTransport: true`. This means that the request is sent through HTTPS, but HTTP can still be used. So, to make sure you do not allow HTTP access, confirm that there is a bucket policy that explicitly denies access for HTTP requests and that it contains the key `aws:SecureTransport: false`.  \nEnforcing the S3 bucket to accept only HTTPS requests would prevent potential attackers from eavesdropping on data in-transit or manipulating network traffic using man-in-the-middle or similar attacks.  \nIt is recommended to explicitly deny access to HTTP requests in the S3 bucket policy.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "S3 Bucket policy should deny HTTP requests"
  opa_policy               = "package wiz\n\nimport future.keywords.in\n\ndefault result := \"fail\"\n\npolicyPath := input.bucketPolicy\n\nresourcePolicy = policy {\n\t# for parsed policies:\n\tpolicyPath.Version\n\tpolicy := policyPath\n}{\n\t# for policies that require parsing:\n\tpolicy := json.unmarshal(policyPath)\n}\n\neffectDeny(statement) {\n\tstatement.Effect == \"Deny\"\n}\n\ns3Wildcard := {\"*\", \"s3:*\", \"s3*\"}\n\noverlyPermissiveActions(statement) {\n\tlower(statement.Action[_]) in s3Wildcard\n}{\n\tlower(statement.Action) in s3Wildcard\n}\n\nwildcardPrincipal(statement) {\n\tstatement.Principal == \"*\"\n}{\n\tstatement.Principal[_] == \"*\"\n}{\n\tstatement.Principal.AWS[_] == \"*\"\n}\n\nsecureTransportFalseCondition(statement) {\n\tcondition := statement.Condition.Bool[key]\n\tlower(key) == \"aws:securetransport\"\n\tlower(condition) == \"false\"\n}\n\nsecureTransportTrueCondition(statement) {\n\tcondition := statement.Condition.Bool[key]\n\tlower(key) == \"aws:securetransport\"\n\tlower(condition) == \"true\"\n}\n\ntlsVersionCondition(statement) {\n\tcondition := statement.Condition.NumericLessThan[key]\n\tlower(key) == \"s3:tlsversion\"\n    not secureTransportTrueCondition(statement)\n}\n\ndenyHttpCondition(statement) {\n\tsecureTransportFalseCondition(statement)\n}{\n\ttlsVersionCondition(statement)\n}\n\nstatementThatDenysHttpTrafficForAllPrincipals[statement] {\n\tstatement := resourcePolicy.Statement[s]\n\teffectDeny(statement)\n\toverlyPermissiveActions(statement)\n\twildcardPrincipal(statement)\n\tdenyHttpCondition(statement)\n}\n\nresult := \"skip\" {\n\tnot input.WizMetadata.objectFetchStatus.bucketPolicy.result == \"Success\"\n} else := \"pass\" {\n\tcount(statementThatDenysHttpTrafficForAllPrincipals) > 0\n}\n\ncurrentConfiguration := \"Bucket policy does not deny HTTP trafic for all principals\"\nexpectedConfiguration := \"Bucket policy should deny HTTP traffic\"\n"
  remediation_instructions = "Perform the following command to deny HTTP requests to the bucket via AWS CLI:\n```\naws s3api put-bucket-policy \\\n    --bucket {{bucketName}} \\\n    --policy '{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Deny\",\"Principal\":\"*\",\"Action\":\"s3:*\",\"Resource\":\"arn:aws:s3:::{{bucketName}}/*\",\"Condition\":{\"Bool\":{\"aws:SecureTransport\":\"false\"}}}]}'  \n```\n>**Note**  \nFor further remediation assistance, see [AWS video](https://www.youtube.com/watch?v=obCm_RMYMp8&ab_channel=AmazonWebServices) on this matter."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["bucket"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\nimport data.generic.common as common_lib\nimport future.keywords.in\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresources := document.Resources\n\n\tresources[resourceName].Type == \"AWS::S3::Bucket\"\n\n\tnot bucketHasPolicy(resources[resourceName], resourceName, resources)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resources[resourceName], resourceName),\n\t\t\"searchKey\": sprintf(\"Resources.%s\", [resourceName]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s bucket has a policy that enforces SSL\", [resourceName]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s bucket doesn't have a policy\", [resourceName]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resources\", resourceName], []),\n\t}\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresources := document.Resources\n\n\tresources[resourceName].Type == \"AWS::S3::Bucket\"\n\n\tbucketHasPolicy(resources[resourceName], resourceName, resources)\n\tnot bucketHasPolicyWithValidSslVerification(resources[resourceName], resourceName, resources)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resources[resourceName], resourceName),\n\t\t\"searchKey\": sprintf(\"Resources.%s\", [resourceName]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s bucket has a policy that enforces SSL\", [resourceName]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s bucket doesn't have a policy or has a policy that doesn't enforce SSL\", [resourceName]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resources\", resourceName], []),\n\t}\n}\n\nbucketHasPolicy(bucket, bucketLogicalName, resources) {\n\tresources[a].Type == \"AWS::S3::BucketPolicy\"\n\tcloudFormationLib.getBucketName(resources[a]) == bucket.Properties.BucketName\n} else {\n\tresources[a].Type == \"AWS::S3::BucketPolicy\"\n\tcloudFormationLib.getBucketName(resources[a]) == bucketLogicalName\n}\n\nbucketHasPolicyWithValidSslVerification(bucket, bucketLogicalName, resources) {\n\tresources[a].Type == \"AWS::S3::BucketPolicy\"\n\tcloudFormationLib.getBucketName(resources[a]) == bucket.Properties.BucketName\n\n\tisValidSslPolicyStatement(resources[a].Properties.PolicyDocument.Statement)\n} else {\n\tresources[a].Type == \"AWS::S3::BucketPolicy\"\n\tcloudFormationLib.getBucketName(resources[a]) == bucketLogicalName\n\n\tisValidSslPolicyStatement(resources[a].Properties.PolicyDocument.Statement)\n}\n\nallS3Actions := {\"*\", \"s3:*\", \"s3*\"}\n\nequalsFalse(\"false\") = true\n\nequalsFalse(false) = true\n\nisValidSslPolicyStatement(stmt) {\n\tis_array(stmt)\n\tst := stmt[s]\n\tst.Effect == \"Deny\"\n\tst.Action in allS3Actions\n\tequalsFalse(st.Condition.Bool[\"aws:SecureTransport\"])\n} else {\n\tis_array(stmt)\n\tst := stmt[s]\n\tst.Effect == \"Deny\"\n\tis_array(st.Action)\n\taction := st.Action[i]\n\tlower(action) in allS3Actions\n\tequalsFalse(st.Condition.Bool[\"aws:SecureTransport\"])\n} \nelse {\n\tis_object(stmt)\n\tstmt.Effect == \"Deny\"\n\tlower(stmt.Action) in allS3Actions\n\tequalsFalse(stmt.Condition.Bool[\"aws:SecureTransport\"])\n}\nelse {\n\tis_array(stmt)\n\tst := stmt[s]\n\tst.Effect == \"Allow\"\n\tlower(st.Action) in allS3Actions\n\tnot equalsFalse(st.Condition.Bool[\"aws:SecureTransport\"])\n} else {\n\tis_array(stmt)\n\tst := stmt[s]\n\tst.Effect == \"Allow\"\n\tis_array(st.Action)\n\taction := st.Action[i]\n\tlower(action) in allS3Actions\n\tnot equalsFalse(st.Condition.Bool[\"aws:SecureTransport\"])\n} \nelse {\n\tis_object(stmt)\n\tstmt.Effect == \"Allow\"\n\tlower(stmt.Action) in allS3Actions\n\tnot equalsFalse(stmt.Condition.Bool[\"aws:SecureTransport\"])\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\nimport future.keywords.in\n\n# The rule hecks if the S3 Policy does not explicitly deny HTTP requests.\n# It supports both methods - using 'aws_s3_bucket.policy' (used in older AWS Terraform versions)  \n# and the association of a 'aws_s3_bucket_policy' (newer versions). In the edge case of\n# having both methods defined, the rule will fail only if both methods are non-compliant.\n# The rule will not evaluate a standalone 'aws_s3_bucket_policy' resource.\n\nactionKeys := {\"Action\", \"Actions\", \"action\", \"actions\"}\nprincipalKeys := {\"Principal\", \"Principals\", \"principal\", \"principals\"}\nallS3Actions := {\"*\", \"s3:*\", \"s3*\"}\nisFalse := {false, \"false\", \"False\", \"FALSE\"}\nisTrue := {true, \"true\", \"True\", \"TRUE\"}\n\nactionContainsAllS3Actions(statement) {\n\tcommon_lib.equalsOrInArray(statement[actionKeys[_]], allS3Actions[_])\n}\n\nwildcardPrincipal(statement) {\n\tcommon_lib.equalsOrInArray(statement[principalKeys[_]].AWS, \"*\")\n}{\n\tcommon_lib.equalsOrInArray(statement[principalKeys[_]], \"*\")\n}{\n\tcommon_lib.equalsOrInArray(statement[principalKeys[_]][\"*\"], \"*\")\n}{\n\tprincipals := terraLib.getValueArrayOrObject(statement[principalKeys[_]])\n\tcommon_lib.equalsOrInArray(principals.identifiers, \"*\")\n}\n\ndenyEffect(statement) {\n\tlower(statement.Effect) == \"deny\"\n}{\n\tlower(statement.effect) == \"deny\"\n}\n\nsecureTransportFalseCondition(statement) {\n\tcondition := statement.Condition.Bool[key]\n\tlower(key) == \"aws:securetransport\"\n\tterraLib.getValueArrayOrObject(condition) in isFalse\n}{\n\tcondition := terraLib.getValueArrayOrObject(statement.condition)\n    \tvariable := terraLib.getValueArrayOrObject(condition.variable)\n    \tvalue := terraLib.getValueArrayOrObject(condition.values)\n    \tlower(variable) == \"aws:securetransport\"\n    \tlower(value) == \"false\"\n}\n\nsecureTransportTrueCondition(statement) {\n\tcondition := statement.Condition.Bool[key]\n\tlower(key) == \"aws:securetransport\"\n\tterraLib.getValueArrayOrObject(condition) in isTrue\n}{\n\tcondition := terraLib.getValueArrayOrObject(statement.condition)\n    \tvariable := terraLib.getValueArrayOrObject(condition.variable)\n    \tvalue := terraLib.getValueArrayOrObject(condition.values)\n    \tlower(variable) == \"aws:securetransport\"\n    \tlower(value) == \"true\"\n}\n\ntlsVersionCondition(statement) {\n\tcondition := statement.Condition.NumericLessThan[key]\n\tlower(key) == \"s3:tlsversion\"\n\tnot secureTransportTrueCondition(statement)\n}{\n\tcondition := terraLib.getValueArrayOrObject(statement.condition)\n    \tkey := terraLib.getValueArrayOrObject(condition.NumericLessThan)\n    \tlower(key) == \"s3:tlsversion\"\n    \tnot secureTransportTrueCondition(statement)\n}\n\ndenyHttpCondition(statement) {\n\tsecureTransportFalseCondition(statement)\n}{\n\ttlsVersionCondition(statement)\n}\n\npolicyDoesNotDenysHttpRequests(policy) {\n\tst := common_lib.get_statement(policy)\n\n\tstatmentDenyHttpRequests := [\n\t\tstatement | statement := st[_];\n\t\tactionContainsAllS3Actions(statement);\n\t\twildcardPrincipal(statement);\n\t\tdenyEffect(statement);\n\t\tdenyHttpCondition(statement)\n\t]\n\n\tcount(statmentDenyHttpRequests) == 0\n}\n\ns3PolicyExistsAndAssociatedToS3Bucket(document, s3Bucket, s3Name) {\n\ts3Policy := document.resource.aws_s3_bucket_policy[s3PolicyName]\n\tterraLib.associatedResources(s3Bucket, s3Policy, s3Name, s3PolicyName, \"bucket\", \"bucket\")\n}\n\ns3BucketPolicyDoesNotDenyHttpRequets(document, s3Bucket, s3Name) {\n\tterraLib.validKey(s3Bucket, \"policy\")\n\tpolicyDoesNotDenysHttpRequests(common_lib.json_unmarshal(s3Bucket.policy))\n\tnot s3PolicyExistsAndAssociatedToS3Bucket(document, s3Bucket, s3Name)\n}{\n\ts3Policy := document.resource.aws_s3_bucket_policy[policyName]\n\tterraLib.associatedResources(s3Bucket, s3Policy, s3Name, policyName, \"bucket\", \"bucket\")\n\tterraLib.validKey(s3Bucket, \"policy\")\n\tpolicyDoesNotDenysHttpRequests(common_lib.json_unmarshal(s3Bucket.policy))\n\tterraLib.validKey(s3Policy, \"policy\")\n\tpolicyDoesNotDenysHttpRequests(common_lib.json_unmarshal(s3Policy.policy))\n}{\n\tnot terraLib.validKey(s3Bucket, \"policy\")\n\ts3Policy := document.resource.aws_s3_bucket_policy[policyName]\n\tterraLib.associatedResources(s3Bucket, s3Policy, s3Name, policyName, \"bucket\", \"bucket\")\n\tterraLib.validKey(s3Policy, \"policy\")\n\tpolicyDoesNotDenysHttpRequests(common_lib.json_unmarshal(s3Policy.policy))\n}{\n\tnot terraLib.validKey(s3Bucket, \"policy\")\n\tnot s3PolicyExistsAndAssociatedToS3Bucket(document, s3Bucket, s3Name)\n}{\n\ts3Policy := document.resource.aws_s3_bucket_policy[policyName]\n\tterraLib.associatedResources(s3Bucket, s3Policy, s3Name, policyName, \"bucket\", \"bucket\")\n\tterraLib.validKey(s3Policy, \"policy\")\n\tassociatedAWSIAMPolicyDocument(document, s3Policy)\n}\n\nassociatedAWSIAMPolicyDocument(document, bucketPolicy) {\n\tresource := document.data.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(bucketPolicy, name, \"policy\")\n\tterraLib.validKey(resource, \"statement\")\n\tpolicyDoesNotDenysHttpRequests(resource)\n}{\n\tresource := document.resource.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(bucketPolicy, name, \"policy\")\n\tterraLib.validKey(resource, \"statement\")\n\tpolicyDoesNotDenysHttpRequests(resource)\n}{\n\tresource := document.data.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(bucketPolicy, name, \"policy\")\n\tsourceAWSIAMPolicyDocument(document, resource)\n}{\n\tresource := document.resource.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(bucketPolicy, name, \"policy\")\n\tsourceAWSIAMPolicyDocument(document, resource)\n}\n\nsourceAWSIAMPolicyDocument(document, docPolicy) {\n\tresource := document.data.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(docPolicy, name, \"source_policy_documents\")\n\tterraLib.validKey(resource, \"statement\")\n\tpolicyDoesNotDenysHttpRequests(resource)\n}{\n\tresource := document.resource.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(docPolicy, name, \"source_policy_documents\")\n\tterraLib.validKey(resource, \"statement\")\n\tpolicyDoesNotDenysHttpRequests(resource)\n}    \n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.resource.aws_s3_bucket[name]\n\n\ts3BucketPolicyDoesNotDenyHttpRequets(document, resource, name)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_iam_policy_document\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_s3_bucket[%s]\", [name]),\n\t\t\"keyExpectedValue\": sprintf(\"'aws_s3_bucket[%s]' should deny unseucre HTTP requesets\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_s3_bucket[%s]' does not explicitly deny HTTP requesets for all actions for all principals\", [name]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_s3_bucket_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket_policy), [aws_s3_bucket](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-exp-8-r4-1" {
  description              = "This rule checks whether the S3 Bucket policy allows all actions to all principals.  \nThis rule fails if the `bucketPolicy` contains a `Statement` where:  \n* `Action` contains a wildcard (`*` or `s3:*`)\n* `Principal` contains a wildcard (`*`, `AWS:*`)\n* `Effect` is set to `Allow`\n* `Condition` is `null` or does not exist\n\nSuch overly permissive Bucket policy may lead to unauthorized data tampering or deletion, as well as leakage of private information to the entire internet.  \nIt is recommended to follow the Principle of Least Privilege (PoLP) and restrict the Bucket policy."
  enabled                  = true
  function_as_control      = false
  name                     = "S3 Bucket policy should not allow all actions to all principals"
  opa_policy               = "package wiz\n\nimport future.keywords.in\n\ndefault result = \"pass\"\n\npolicyPath := input.bucketPolicy\nwildcardAction := {\"*\", \"s3:*\", \"s3*\"}\n\nresourcePolicy = policy {\n\t# for parsed policies:\n\tpolicyPath.Version\n\tpolicy := policyPath\n}{\n\t# for policies that require parsing:\n\tpolicy := json.unmarshal(policyPath)\n}\n\ns3WildcardActions(statement) {\n\tlower(statement.Action[_]) in wildcardAction\n}{\n\tlower(statement.Action) in wildcardAction\n}\n\neffectAllow(statement) {\n\tstatement.Effect == \"Allow\"\n}\n\nwildcardPrincipal(statement) {\n\tstatement.Principal == \"*\"\n}{\n\tstatement.Principal[_] == \"*\"\n}{\n\tstatement.Principal.AWS[_] == \"*\"\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\nstatementAllowsGlobalAccess[statement] {\n\tstatement := resourcePolicy.Statement[s]\n\ts3WildcardActions(statement)\n\teffectAllow(statement)\n\twildcardPrincipal(statement)\n\tnullCondition(statement)\n}\n\nresult = \"skip\" {\n\tnot input.WizMetadata.objectFetchStatus.bucketPolicy.result = \"Success\"\n} else = \"fail\" { \n\tcount(statementAllowsGlobalAccess) > 0\n}\n\ncurrentConfiguration := \"S3 Bucket policy allows all actions to all principals\"\nexpectedConfiguration := \"S3 Bucket policy should not allow all actions to all principals\"\n"
  remediation_instructions = "Perform the following commands to update an S3 policy statement via AWS CLI:  \n1. Create a file containing JSON with the policy statement configuration. This JSON will overwrite the current topic policy statement. If the principal is `\"AWS\": \"*\"` and the effect is `Allow`, the JSON must contain the following fields:  \n```  \n      \"Condition\": {  \n        \"StringEquals\": {  \n          \"AWS:SourceOwner\": \"<yourSourceOwner>\"  \n        }  \n      }  \n```  \nSee more examples [here](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.html).  \n2. Update the S3 policy configuration:  \n```  \naws s3api put-bucket-policy \\\n\t--region {{region}} \\\n\t--bucket {{bucket}} \\\n\t--policy <file://policy.json>  \n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["bucket"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ans_lib\nimport data.generic.common as common_lib\n\nmodules := {\"amazon.aws.s3_bucket\", \"s3_bucket\"}\n\nWizPolicy[result] {\n\ttask := ans_lib.tasks[id][t]\n\ts3_bucket := task[modules[m]]\n\tans_lib.checkState(s3_bucket)\n\n\tst := common_lib.get_statement(common_lib.get_policy(s3_bucket.policy))\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\n\tcommon_lib.containsOrInArrayContains(statement.Action, \"*\")\n\tcommon_lib.containsOrInArrayContains(statement.Principal, \"*\")\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}.policy\", [task.name, modules[m]]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'policy.Statement' should not allow all actions to all principal\",\n\t\t\"keyActualValue\": \"'policy.Statement' allows all actions to all principal\",\n\t\t\"searchLine\": common_lib.build_search_line([\"playbooks\", t, modules[m], \"policy\"], []),\n\t\t\"resourceTags\": object.get(s3_bucket, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\nimport data.generic.common as common_lib\n\nactionsContainingS3All := {\"*\", \"s3:*\", \"s3*\"}\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::S3::BucketPolicy\"\n\n\tpolicy := resource.Properties.PolicyDocument\n\tst := common_lib.get_statement(common_lib.get_policy(policy))\n\tstatement := st[_]\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.equalsOrInArray(statement.Principal, \"*\")\n\ts3AllActions(statement)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.PolicyDocument\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.PolicyDocument.Statement should not allow all actions from all principals\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.PolicyDocument.Statement allows all actions from all principals\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line(path, [name, \"Properties\", \"PolicyDocument\"]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\ns3AllActions(statement) {\n  startswith(lower(statement.Action[_]), actionsContainingS3All[_])\n}{\n  startswith(lower(statement.Action), actionsContainingS3All[_])\n}"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\n# This rule will pass if at least the 'aws_s3_bucket' or\n# its association configuration resource are properly configured.\n\nactionKeys := {\"Action\", \"Actions\", \"action\", \"actions\"}\nprincipalKeys := {\"Principal\", \"Principals\", \"principal\", \"principals\"}\nallS3Actions := {\"*\", \"s3:*\", \"s3*\"}\nconditionKeys := {\"Condition\", \"condition\"}\n\nactionContainsAllS3Actions(statement) {\n\tcommon_lib.equalsOrInArray(statement[actionKeys[_]], allS3Actions[_])\n}\n\nwildcardPrincipal(statement) {\n\tcommon_lib.equalsOrInArray(statement[principalKeys[_]].AWS, \"*\")\n}{\n\tcommon_lib.equalsOrInArray(statement[principalKeys[_]], \"*\")\n}{\n\tcommon_lib.equalsOrInArray(statement[principalKeys[_]][\"*\"], \"*\")\n}{\n\tprincipals := terraLib.getValueArrayOrObject(statement[principalKeys[_]])\n\tcommon_lib.equalsOrInArray(principals.identifiers, \"*\")\n}\n\nconditionExist(statement) {\n\tcondition := conditionKeys[_]\n\tterraLib.validKey(statement, condition)\n}\n\npolicyResourceAssociatedToBucket(document, s3Bucket, s3Name) {\n\ts3Policy := document.resource.aws_s3_bucket_policy[s3PolicyName]\n\tterraLib.associatedResources(s3Bucket, s3Policy, s3Name, s3PolicyName, \"bucket\", \"bucket\")\n}\n\nuncompliantPolicy(unmarshaledPolicy) {\n\tst := common_lib.get_statement(unmarshaledPolicy)\n\tstatement := st[_]\n    \n\tactionContainsAllS3Actions(statement)\n\twildcardPrincipal(statement)\n\tcommon_lib.is_allow_effect(statement)\n\tnot conditionExist(statement)\n}\n\nuncompliantPolicyOnBucket(document, s3Bucket, s3Name) {\n\tterraLib.validKey(s3Bucket, \"policy\")\n\tuncompliantPolicy(common_lib.json_unmarshal(s3Bucket.policy))\n\tnot policyResourceAssociatedToBucket(document, s3Bucket, s3Name)\n}{\n\ts3Policy := document.resource.aws_s3_bucket_policy[policyName]\n\tterraLib.associatedResources(s3Bucket, s3Policy, s3Name, policyName, \"bucket\", \"bucket\")\n\tterraLib.validKey(s3Bucket, \"policy\")\n\tuncompliantPolicy(common_lib.json_unmarshal(s3Bucket.policy))\n\tterraLib.validKey(s3Policy, \"policy\")\n\tuncompliantPolicy(common_lib.json_unmarshal(s3Policy.policy))\n}{\n\tnot terraLib.validKey(s3Bucket, \"policy\")\n\ts3Policy := document.resource.aws_s3_bucket_policy[policyName]\n\tterraLib.associatedResources(s3Bucket, s3Policy, s3Name, policyName, \"bucket\", \"bucket\")\n\tterraLib.validKey(s3Policy, \"policy\")\n\tuncompliantPolicy(common_lib.json_unmarshal(s3Policy.policy))\n}{\n\tnot terraLib.validKey(s3Bucket, \"policy\")\n\ts3Policy := document.resource.aws_s3_bucket_policy[policyName]\n\tterraLib.associatedResources(s3Bucket, s3Policy, s3Name, policyName, \"bucket\", \"bucket\")\n\tterraLib.validKey(s3Policy, \"policy\")\n\tassociatedAWSIAMPolicyDocument(document, s3Policy)\t\n}\n\nassociatedAWSIAMPolicyDocument(document, bucketPolicy) {\n\tresource := document.data.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(bucketPolicy, name, \"policy\")\n\tterraLib.validKey(resource, \"statement\")\n\tuncompliantPolicy(resource)\n}{\n\tresource := document.resource.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(bucketPolicy, name, \"policy\")\n\tterraLib.validKey(resource, \"statement\")\n\tuncompliantPolicy(resource)\n}{\n\tresource := document.data.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(bucketPolicy, name, \"policy\")\n\tsourceAWSIAMPolicyDocument(document, resource)\n}{\n\tresource := document.resource.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(bucketPolicy, name, \"policy\")\n\tsourceAWSIAMPolicyDocument(document, resource)\n}\n\nsourceAWSIAMPolicyDocument(document, docPolicy) {\n\tresource := document.resource.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(docPolicy, name, \"source_policy_documents\")\n\tterraLib.validKey(resource, \"statement\")\n   \tuncompliantPolicy(resource)\n}{\n\tresource := document.data.aws_iam_policy_document[name]\n\tterraLib.associatedResourcesData(docPolicy, name, \"source_policy_documents\")\n\tterraLib.validKey(resource, \"statement\")\n   \tuncompliantPolicy(resource)\n}\n \nWizPolicy[result] {    \n\tdocument := input.document[i]\n\tresource := document.resource.aws_s3_bucket[name]\n\n\tuncompliantPolicyOnBucket(document, resource, name)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_iam_policy_document\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_s3_bucket[%s]\", [name]),\n\t\t\"keyExpectedValue\": sprintf(\"'aws_s3_bucket[%s]' policy should not allow all actions for all principals without conditions\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_s3_bucket[%s]' policy allows all actions for all principals without a condition\", [name]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_s3_bucket_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket_policy), [aws_s3_bucket](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-6-r1-5" {
  description              = "This rule checks whether the IAM password policy is set to require at least one symbol.  \nThis rule fails if `RequireSymbols` is set to `false`, or if `accountPasswordPolicy` doesn't exist.  \nEnforcing IAM password strength, pattern, and rotation is a critical security practice, as having a strong password policy significantly reduces the risk of brute-force attacks.  \nIt is recommended that users are required to have a strong password."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM password policy should require at least one symbol"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tnot input.accountPasswordPolicy.RequireSymbols\n}\n\ncurrentConfiguration := \"'RequireSymbols' is not configured\"\nexpectedConfiguration := \"Symbols should be required\""
  remediation_instructions = "Perform the following command to edit the IAM password policy enforcement/s via AWS CLI:  \n```  \naws iam update-account-password-policy \\\n  --require-symbols  \n  [--minimum-password-length <14 (characters) or more>] \\\n  [--require-numbers] \\\n  [--require-uppercase-characters] \\\n  [--require-lowercase-characters] \\\n  [--password-reuse-prevention <recommended: 10 or more>] \\\n  [--max-password-age <recommended: 90 (days) or less>]  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["account"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tpassword := resource.Properties.LoginProfile.Password\n\tis_string(password)\n\tnot contains(lower(password), \"secretsmanager\")\n\tnot regex.match(\".*[-+_!@#$%^&*.,?]\", password)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.LoginProfile.Password\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'Resources.Properties.LoginProfile.Password' should contain symbol\",\n\t\t\"keyActualValue\": \"'Resources.Properties.LoginProfile.Password' doesnt contain symbol\",\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tpassword_policy := input.document[i].resource.aws_iam_account_password_policy[name]\n\tnot common_lib.valid_key(password_policy, \"require_symbols\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(password_policy, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s]\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name], []),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"'require_symbols' should be set with true value\",\n\t\t\"keyActualValue\": \"'require_symbols' is undefined\",\n\t\t\"remediation\": \"require_symbols = true\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(password_policy, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tpassword_policy := input.document[i].resource.aws_iam_account_password_policy[name]\n\tpassword_policy.require_symbols == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(password_policy, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s].require_symbols\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name, \"require_symbols\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'require_symbols' should be true\",\n\t\t\"keyActualValue\": \"'require_symbols' is false\",\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(password_policy, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_account_password_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_account_password_policy)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-3-1" {
  description              = "This rule checks if the IAM User has an IAM Policy attached.  \nThis rule fails if `AttachedManagedPolicies` (for managed policies) or `UserPolicyList` (for inline policies) contain at least one policy.  \nIAM policies are the means by which privileges are granted to users, groups, or roles. By default, IAM users, groups, and roles have no access to AWS resources. Assigning privileges at the group or role level reduces the complexity of access management as the number of users grows. Reducing access management complexity may in turn reduce the opportunity for a principal to inadvertently receive or retain excessive privileges.  \nIt is recommended that IAM policies are applied directly to groups or roles, but not to users.\n>**Note**  \nSee Cloud Configuration Rule `IAM-158` for users that are specifically using inline policies."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM User should not have any policies attached"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"skip\" {\n\tnot input.AttachedManagedPolicies\n} else = \"fail\" { # Cheking managed policies\n\tcount(input.AttachedManagedPolicies) > 0\n} else = \"fail\" { # Cheking inline policies\n\tcount(input.UserPolicyList) > 0\n}\n\ncurrentConfiguration := \"The user has policies directly attached\"\nexpectedConfiguration := \"The user should not have any policies directly attached\""
  remediation_instructions = "Perform the following commands to detach policies from users via AWS CLI:  \n```  \naws iam detach-user-policy \\\n    --user-name {{userName}} \\\n    --policy-arn <value>  \n```  \nRepeat the command for the following policy ARNs:  \n```  \n{{policies}}  \n```  \nOnce the policies are removed, assign the user to the correct role or group instead. In addition, it is advised to delete any policies that are left unused. You can use the `delete-policy` command to delete any unneeded policies."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["user"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ansLib\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tmodules := {\"community.aws.iam_policy\", \"iam_policy\"}\n\tawsApiGateway := task[modules[m]]\n\tansLib.checkState(awsApiGateway)\n\n\tlower(awsApiGateway.iam_type) == \"user\"\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}.iam_type\", [task.name, modules[m]]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"iam_policy.iam_type should be configured with group or role\",\n\t\t\"keyActualValue\": \"iam_policy.iam_type is configured with user\",\n\t\t\"resourceTags\": object.get(awsApiGateway, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::IAM::User\"\n\tpolicies := resource.Properties.Policies\n\tpolicies != []\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.Policies\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.Policies' should be undefined or empty\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.Policies' is not empty\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::IAM::User\"\n\tpolicies := resource.Properties.ManagedPoliciesArns\n\tpolicies != []\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.ManagedPoliciesArns\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.ManagedPoliciesArns' is undefined or empty\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.ManagedPoliciesArns' is not empty\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::IAM::ManagedPolicy\"\n\tcount(resource.Properties.Users) > 0\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.Users\", [name]),\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s is assigned to a set of users\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s should be assigned to a set of groups\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tsome policyName\n\tdocument.Resources[policyName].Type == \"AWS::IAM::Policy\"\n\tpolicy := document.Resources[policyName]\n\n\tcount(policy.Properties.Users) > 0\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(document.Resources[policyName], policyName),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.Users\", [policyName]),\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s is assigned to a set of users\", [policyName]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s should be assigned to a set of groups\", [policyName]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(policy),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::IAM::Policy\"\n\tusers := resource.Properties.Policies[_].Users\n\tusers != []\n\tusers != null\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.Policies.Users\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'Resources.Properties.Policies.Users should be replaced by Groups\",\n\t\t\"keyActualValue\": \"'Resources.Properties.Policies.Users' is not the correct definition.\",\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\n\nresourcesTest = [\"aws_iam_policy_attachment\", \"aws_iam_user_policy\", \"aws_iam_user_policy_attachment\"]\n\nWizPolicy[result] {\n\tresource := input.document[i].resource[resourcesTest[idx]][name]\n\tresource.user\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": resourcesTest[idx],\n\t\t\"searchKey\": sprintf(\"%s[%s].user\", [resourcesTest[idx], name]),\n\t\t\"issueType\": \"RedundantAttribute\",\n\t\t\"keyExpectedValue\": \"'user' is redundant\",\n\t\t\"keyActualValue\": \"'user' exists\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource[resourcesTest[idx]][name]\n\tresource.users != null\n\tis_array(resource.users)\n\tcount(resource.users) > 0\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": resourcesTest[idx],\n\t\t\"searchKey\": sprintf(\"%s[%s].users\", [resourcesTest[idx], name]),\n\t\t\"issueType\": \"RedundantAttribute\",\n\t\t\"keyExpectedValue\": \"'users' is redundant\",\n\t\t\"keyActualValue\": \"'users' exists\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-6-r1-6" {
  description              = "This rule checks if the IAM Password Policy is configured to prevent password reuse.  \nThis rule fails if `PasswordReusePrevention` is not set to `24`, or if `accountPasswordPolicy` does not exist.  \nEnforcing IAM password strength, pattern, and rotation is a critical security practice, as having a strong password policy significantly reduces the risk of brute-force attacks.  \nIt is recommended that the password policy is set to prevent the reuse of passwords.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "IAM password policy should not allow reuse of passwords"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\n# This rule will fail unless 'passwordReusePrevention' is configured\n# to '24'. 'null' will fail as well.\n# If you want to update the number of password reuse prevention,\n# duplicate the rule and update the variable below as required.\n\nnumberOfReusedPrevetionToEnforce := 24\npasswordReusePrevention := input.accountPasswordPolicy.PasswordReusePrevention\n\nresult := \"fail\" {\n\tnot  passwordReusePrevention == numberOfReusedPrevetionToEnforce\n}{\n\tnot input.accountPasswordPolicy\n}\n\ncurrentConfiguration := sprintf(\"'PasswordReusePrevention': '%v'\", [passwordReusePrevention])\nexpectedConfiguration := \"Reusing passwords should be prevented\"\n"
  remediation_instructions = "Perform the following command to edit the IAM password policy enforcement/s via AWS CLI:  \n```  \naws iam update-account-password-policy \\\n  --password-reuse-prevention 24 \\\n  [--max-password-age <recommended: 90 (days) or less>] \\\n  [--minimum-password-length <recommended: 14 (characters) or more>] \\\n  [--require-symbols] \\\n  [--require-numbers] \\\n  [--require-uppercase-characters] \\\n  [--require-lowercase-characters]  \n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["account"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tpassword_policy := input.document[i].resource.aws_iam_account_password_policy[name]\n\tnot common_lib.valid_key(password_policy, \"password_reuse_prevention\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(password_policy, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s]\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name], []),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"'password_reuse_prevention' should be set with value 24\",\n\t\t\"keyActualValue\": \"'password_reuse_prevention' is undefined\",\n\t\t\"remediation\": \"password_reuse_prevention = 24\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(password_policy, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tpassword_policy := input.document[i].resource.aws_iam_account_password_policy[name]\n\trp := password_policy.password_reuse_prevention\n\trp < 24\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(password_policy, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s].password_reuse_prevention\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name, \"password_reuse_prevention\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'password_reuse_prevention' should be 24\",\n\t\t\"keyActualValue\": \"'password_reuse_prevention' is lower than 24\",\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": sprintf(\"%d\", [rp]),\n\t\t\t\"after\": \"24\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(password_policy, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_account_password_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_account_password_policy)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_control" "mp-s-2-3" {
  description               = null
  enabled                   = true
  name                      = "Application Load Balancers Without WAF Attached"
  project_id                = "*"
  query                     = "{\"select\":true,\"type\":[\"LOAD_BALANCER\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"loadBalancerv2/application\"]},\"wafEnabled\":{\"EQUALS\":false}}}"
  resolution_recommendation = null
  scope_query               = "{\"type\":[\"LOAD_BALANCER\"]}"
  security_sub_categories   = []
  severity                  = "MEDIUM"
}

resource "wiz_cloud_configuration_rule" "op-mon-1-2" {
  description              = "This rule checks whether a VPC has Flow Logs enabled.  \nThis rule fails if the VPC does not have Flow Logs configured or does have Flow Logs configured but not as the following:  \n* `TrafficType` field should be set to `ALL` or `REJECT`.  \n* `FlowLogStatus` should be set to `ACTIVE`.  \n* `DeliverLogsStatus` should be set to `SUCCESS`.  \n\nVPC Flow Logs is a feature that enables you to capture information about the IP traffic going to and from network interfaces in your VPC. Flow log data can be published to the following locations: Amazon CloudWatch Logs, Amazon S3, or Amazon Kinesis Data Firehose. After you create a flow log, you can retrieve and view the flow log records in the log group, bucket, or delivery stream that you configured.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "VPC reject traffic Flow Logs should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\ntrafficType := {\"ALL\", \"REJECT\"}\n\ntrafficTypeExist {\n\tflowLogs := input.FlowLogs\n\tupper(flowLogs[i].DeliverLogsStatus) == \"SUCCESS\"\n\tupper(flowLogs[i].FlowLogStatus) == \"ACTIVE\"\n\ttrafficType[upper(flowLogs[i].TrafficType)]\n}\n\n\nresult = \"fail\" {\n\tnot trafficTypeExist\n}\n\ncurrentConfiguration := \"VPC flow logs is not fully enabled\"\nexpectedConfiguration := \"VPC flow logs should be enabled for 'Reject' traffic type\"\n"
  remediation_instructions = "Perform the following command to publish VPC Flow Logs to CloudWatch Logs via AWS CLI:   \n```\naws ec2 create-flow-logs \\\n--resource-type VPC \\\n--resource-ids {{vpcId}} \\\n--traffic-type ALL \\\n--log-group-name <The name of a CloudWatch Logs log group where Amazon EC2 publishes your flow logs> \\\n--deliver-logs-permission-arn <The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account>\n```  \n\n>**Note**  \n> This command publishes VPC Flow Logs to CloudWatch Logs, for more information about other options for storing Flow Logs follow this [link](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html)\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["vpc"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type = \"AWS::EC2::VPC\"\n\n\tnot CheckFlowLogExistance(name)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s has a FlowLogs resource associated\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s doesn't have a FlowLogs resource associated\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nCheckFlowLogExistance(service) = result {\n\tresult := [x |\n\t\tdocuments := input.document[index].Resources[a]\n\t\tdocuments.Type = \"AWS::EC2::FlowLog\"\n\t\tn := documents[_].ResourceId\n\t\tn == service\n\t\tx := true\n\t]\n\n\tcount(result) > 0\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nassociatedFlowlog(vpc, vpcName) {\n\tflowLog := input.document[i].resource.aws_flow_log[name]\n\tterraLib.associatedResources(vpc, flowLog, vpcName, null, null, \"vpc_id\")\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_vpc[name]\n\tnot associatedFlowlog(resource, name)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_vpc\",\n\t\t\"resourceName\": name,\n\t\t\"searchKey\": sprintf(\"aws_vpc[%s]\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_vpc[%s] should be the same as Flow Logs VPC id\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_vpc[%s] is not the same as Flow Logs VPC id\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_vpc\", name], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_flow_log[name]\n\tnot common_lib.valid_key(resource, \"vpc_id\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_vpc\",\n\t\t\"resourceName\": name,\n\t\t\"searchKey\": sprintf(\"aws_flow_log[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_flow_log[%s].vpc_id should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_flow_log[%s].vpc_id is undefined or null\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_flow_log\", name], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_flow_log](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/flow_log), [aws_vpc](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "mp-si-2-4" {
  description              = "This rule checks whether the database instance encryption is enabled.  \nThis rule fails when the `StorageEncrypted` field is set to `false`.  \nRDS encrypted instances use the AES-256 encryption algorithm to encrypt your data on the server that hosts your Amazon RDS DB instances. With RDS encryption enabled, the data stored on the instances' underlying storage, the automated backups, read replicas, and snapshots, are all encrypted.  \nIt is recommended to implement encryption in order to protect your data from unauthorized access or disclosure."
  enabled                  = true
  function_as_control      = false
  name                     = "Database instance encryption at rest should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tinput.StorageEncrypted == false\n}\n\ncurrentConfiguration := \"'StorageEncrypted: false'\"\nexpectedConfiguration := \"'StorageEncrypted' should be 'true'\""
  remediation_instructions = "Perform the following commands in order to encrypt RDS instance via AWS CLI:  \n1. Create a snapshot:  \n```  \n aws rds create-db-snapshot \\\n \t--region <region> \\\n \t--db-snapshot-identifier <DBSnapshotName> \\\n \t--db-instance-identifier <DBName>  \n```  \n2. Find the ID of the AWS default KMS key:  \n```  \naws kms list-aliases \\\n\t--region <region> \\\n\t--query 'Aliases[?AliasName==`alias/aws/rds`].TargetKeyId'  \n```  \n3. Copy the snapshot using the default KMSkeyID returned in the previous stage:   \n```  \naws rds copy-db-snapshot \\\n\t--region <region> \\\n\t--source-db-snapshot-identifier <DBSnapshotName> \\\n\t--target-db-snapshot-identifier <DBSnapshotNameEncrypted> \\\n\t--copy-tags \\\n\t--kms-key-id <KMSkeyID>  \n```  \n4. Restore the DB from the snapshot:  \n```  \naws rds restore-db-instance-from-db-snapshot \\\n\t--region <region> \\\n\t--db-instance-identifier <DBNameEncrypted> \\\n\t--db-snapshot-identifier <DBSnapshotNameEncrypted>  \n```\n>**Note**  \n> For encrypting Neptune databases click [here](https://docs.aws.amazon.com/neptune/latest/userguide/encrypt.html).  \n> For encrypting DocumentDB databases click [here](https://docs.aws.amazon.com/documentdb/latest/developerguide/encryption-at-rest.html)."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["rds/AmazonAuroraMySQL/instance", "rds/AmazonAuroraPostgreSQL/instance", "rds/AmazonDocDB/instance", "rds/AmazonNeptune/instance", "rds/Cluster/MySQL/instance", "rds/Cluster/PostgreSQL/instance", "rds/MSSQLServer/instance", "rds/MariaDB/instance", "rds/MySQL/instance", "rds/Oracle/instance", "rds/PostgreSQL/instance"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\nimport data.generic.common as common_lib\n\n# This rule will not detect Aurora, Neptune and DocumentDB instances as this configuration can be\n# configured only on the Cluster level. Cloud Configuration Rule 'RDS-028' will detect such cases.\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::RDS::DBInstance\"\n    \n\tnot auroraDb(resource)\n\tnot common_lib.valid_key(resource.Properties, \"StorageEncrypted\")\n\tnot instanceHasClusterIdentifier(resource, Resources)\n\t\n\t# Don't fail replicas\n\tnot resource.Properties.SourceDBInstanceIdentifier\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.StorageEncrypted should be defined and set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.StorageEncrypted is undefined\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::RDS::DBInstance\"\n    \n\tnot auroraDb(resource)\n\tproperties := resource.Properties\n\tproperties.StorageEncrypted == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.StorageEncrypted\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.StorageEncrypted should be set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.StorageEncrypted is set to false\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\ninstanceHasClusterIdentifier(instance, resources) {\n\tresources[clusterName].Type == \"AWS::RDS::DBCluster\"\n\tclusterName == getClusterName(instance)\n\tisStorageEncrypted(resources[clusterName].Properties)\n}\n\nisStorageEncrypted(properties) {\n\tcommon_lib.valid_key(properties, \"StorageEncrypted\")\n\tproperties.StorageEncrypted == true\n}\n\ngetClusterName(resource) = name {\n\tname := resource.Properties.DBClusterIdentifier\n\tnot common_lib.valid_key(name, \"Ref\")\n} else = name {\n\tname := resource.Properties.DBClusterIdentifier.Ref\n}\n\nauroraDb(resource) {\n\tcontains(lower(resource.Properties.Engine), \"aurora\")\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as commonLib\nimport data.generic.terraform as terraLib\nimport future.keywords.in\n\n# This rule will not detect Aurora, Neptune and DocumentDB instances as this configuration can be\n# configured only on the Cluster level. Cloud Configuration Rule 'RDS-028' will detect such cases.\n\nisFalse := {false, \"false\"}\n\nencryptionDisabled(resource) {\n\tnot commonLib.valid_key(resource, \"storage_encrypted\")\n}{\n\tresource.storage_encrypted in isFalse\n}\n\nauroraDb(resource) {\n\tcontains(lower(resource.engine), \"aurora\")\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.resource.aws_db_instance[name]\n\n\tnot auroraDb(resource)\n\tencryptionDisabled(resource)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_db_instance\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_db_instance[%s]\", [name]),\n\t\t\"keyExpectedValue\": sprintf(\"'aws_db_instance[%s].storage_encrypted' should be defined and 'true'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_db_instance[%s].storage_encrypted' is 'false' or undefined.\", [name]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_db_instance](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/db_instance)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-exp-7-10" {
  description              = "This rule checks whether the EKS Audit Logs feature in Amazon GuardDuty is enabled.  \nThis rule fails if the `EKS_AUDIT_LOGS` status is disabled.  \nEnabling EKS audit logs in GuardDuty enhances security monitoring for your Kubernetes clusters. It allows GuardDuty to analyze EKS audit logs for potential security threats, unauthorized access attempts, and other suspicious activities within your EKS environment.  \nIt is recommended to enable this feature to improve the overall security posture of your Kubernetes workloads in AWS."
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty EKS Audit Logs should be enabled"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nprotection := \"EKS_AUDIT_LOGS\"\n\nfeatureDisabled {\n\tupper(input.Features[feature].Name) == protection\n\tupper(input.Features[feature].Status) == \"DISABLED\"\n}\n\nresult := \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])"
  remediation_instructions = "Perform the following command to enable EKS Audit Logs for GuardDuty via AWS CLI:\n```\naws guardduty update-detector \\\n\t--detector-id {{DetectorID}} \\\n\t--features '[{\"Name\": \"EKS_AUDIT_LOGS\", \"Status\": \"ENABLED\"}]'\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
}

resource "wiz_cloud_configuration_rule" "op-acc-6-2" {
  description              = "This rule checks if the IAM access keys are rotated periodically.  \nThis rule fails if `AccessKey1LastRotated` or `AccessKey2LastRotated` are 90 or more days old.  \nAccess keys consist of an access key ID and a secret access key. Users need access keys to make programmatic calls to AWS from the AWS Command Line Interface (CLI), Tools for Windows PowerShell, the AWS SDKs, or direct HTTP calls using the APIs for individual AWS services.\nIt is recommended that all access keys be regularly rotated. Rotating access keys will reduce the window of opportunity for an access key that is associated with a compromised or terminated user to be used. Access keys should be rotated to ensure that data cannot be accessed with an old key that might have been lost, cracked, or stolen.  \nIt is recommended to disable or delete outdated access keys."
  enabled                  = true
  function_as_control      = false
  name                     = "Access keys should be rotated every 90 days"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nminRotationDate := time.now_ns() - 7776000000000000 # 90 days\ncredentials := input.userCredentials\n\nkey1NotRotated {\n\ttime.parse_rfc3339_ns(credentials.AccessKey1LastRotated) < minRotationDate\n    lower(credentials.AccessKey1Active) == \"true\"\n}\n\nkey2NotRotated {\n\ttime.parse_rfc3339_ns(credentials.AccessKey2LastRotated) < minRotationDate\n    lower(credentials.AccessKey2Active) == \"true\"\n}\n\n\n# check if at least one key was not rotated\nkeysNotRotated {\n\tkey1NotRotated\n} {\n\tkey2NotRotated\n}\n\nresult = \"skip\" {\n\tnot credentials\n} else = \"fail\" {\n\tkeysNotRotated\n}\n\ncurrentConfiguration := \"The access keys were not rotated in the past 90 days\"\nexpectedConfiguration := \"The access keys should be rotated\""
  remediation_instructions = "Perform the following commands to remove the outdated active access key pair via AWS CLI:    \n1. Use the following command to list the access keys of the user:    \n```  \naws iam list-access-keys \\\n\t--user-name {{userName}}  \n```  \n2. Use the following command to delete the access keys.    \nCopy the `AccessKeyId` output where the status is active and the `CreateDate` is 90 days or greater, and paste the value into the `access-key` parameter.  \n```  \naws iam delete-access-key \\\n\t--access-key <value> \\\n\t--user-name {{userName}}  \n```  \n>**Note**    \nOnce an access key is removed, any application using it will not work until a new one is configured for it."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["user"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::Config::ConfigRule\"\n\tnot hasAccessKeyRotationRule(resource)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s should have a ConfigRule defining rotation period on AccessKeys.\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s doesn't have a ConfigRule defining rotation period on AccessKeys.\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tconfigRule := document.Resources[name]\n\tconfigRule.Type == \"AWS::Config::ConfigRule\"\n\tconfigRule.Properties.Source.SourceIdentifier == \"ACCESS_KEYS_ROTATED\"\n\n\tnot common_lib.valid_key(configRule.Properties, \"InputParameters\")\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(configRule, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.InputParameters should be defined and contain 'maxAccessKeyAge' key.\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.InputParameters is undefined.\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(configRule),\n\t}\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tconfigRule := document.Resources[name]\n\tconfigRule.Type == \"AWS::Config::ConfigRule\"\n\tconfigRule.Properties.Source.SourceIdentifier == \"ACCESS_KEYS_ROTATED\"\n\n\tmaxDays := configRule.Properties.InputParameters.maxAccessKeyAge\n\n\tto_number(maxDays) > 90\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(configRule, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.InputParameters.maxAccessKeyAge\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.InputParameters.maxAccessKeyAge should be less or equal to 90 (days)\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.InputParameters.maxAccessKeyAge is more than 90 (days).\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(configRule),\n\t}\n}\n\nhasAccessKeyRotationRule(configRule) {\n\tconfigRule.Properties.Source.SourceIdentifier == \"ACCESS_KEYS_ROTATED\"\n} else = false {\n\ttrue\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
}

resource "wiz_cloud_configuration_rule" "op-exp-8-r3-1" {
  description              = "This rule checks if the CloudWatch Log Group has specified the log retention days.  \n`retention_in_days` specifies the number of days you want to retain log events in the specified log group.  \nPossible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1096, 1827, 2192, 2557, 2922, 3288, 3653, and 0. If you select `0`, the events in the log group are always retained and never expire.  \nBy default, log data is stored in CloudWatch Logs indefinitely. However, you can configure how long to store log data in a log group. Any data older than the current retention setting is deleted. You can change the log retention for each log group at any time.  \nIt is recommended to specify a retention period.  \nA CloudWatch Log Group without RetentionInDays set might generate high spending if not required."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudWatch Log Group retention period should be specified"
  opa_policy               = "package wiz\r\n\r\ndefault result = \"pass\"\r\n\r\nresult = \"fail\" {\r\n\tinput.RetentionInDays == null\r\n}\r\n\r\ncurrentConfiguration := \"'RetentionInDays': 'null'\"\r\nexpectedConfiguration := \"'RetentionInDays' should not be 'null'\"\r\n"
  remediation_instructions = "Perform the following command to configure a retention policy for a CloudWatch Log Group via AWS CLI:\n```\naws logs put-retention-policy \\\n  --log-group-name {{name}} \\\n  --retention-in-days 5\n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["logs#loggroup"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ansLib\nimport data.generic.common as commonLib\n\nmodules := {\"community.aws.cloudwatchlogs_log_group\", \"cloudwatchlogs_log_group\"}\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tcloudwatchlogs_log_group := task[modules[m]]\n\tansLib.checkState(cloudwatchlogs_log_group)\n\n\tnot commonLib.valid_key(cloudwatchlogs_log_group, \"retention\")\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}\", [task.name, modules[m]]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"cloudwatchlogs_log_group.retention should be set\",\n\t\t\"keyActualValue\": \"cloudwatchlogs_log_group.retention is undefined\",\n\t\t\"resourceTags\": object.get(cloudwatchlogs_log_group, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tcloudwatchlogs_log_group := task[modules[m]]\n\tansLib.checkState(cloudwatchlogs_log_group)\n\tvalue := cloudwatchlogs_log_group.retention\n\n\tvalidValues = [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]\n\n\tnot commonLib.inArray(validValues, value)\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}.retention\", [task.name, modules[m]]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"cloudwatchlogs_log_group.retention should be set and valid\",\n\t\t\"keyActualValue\": \"cloudwatchlogs_log_group.retention is set and invalid\",\n\t\t\"resourceTags\": object.get(cloudwatchlogs_log_group, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tlower(resource.Type) == \"aws::logs::loggroup\"\n\tnot common_lib.valid_key(resource.Properties, \"RetentionInDays\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"AWS::Logs::LogGroup\",\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.RetentionInDays' should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.RetentionInDays' is undefined\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudwatch_log_group[name]\n\tnot resource.retention_in_days\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudwatch_log_group\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudwatch_log_group[%s]\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_cloudwatch_log_group\", name], []),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"Attribute 'retention_in_days' should be set and valid\",\n\t\t\"keyActualValue\": \"Attribute 'retention_in_days' is undefined\",\n\t\t\"remediation\": \"retention_in_days = 7\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudwatch_log_group[name]\n\tvalue := resource.retention_in_days\n\tvalidValues := [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]\n\tcount({x | validValues[x]; validValues[x] == value}) == 0\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudwatch_log_group\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudwatch_log_group[%s].retention_in_days\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_cloudwatch_log_group\", name, \"retention_in_days\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"Attribute 'retention_in_days' should be set and valid\",\n\t\t\"keyActualValue\": \"Attribute 'retention_in_days' is set but invalid\",\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": sprintf(\"%d\",[value]),\n\t\t\t\"after\": \"7\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudwatch_log_group](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudwatch_log_group)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-exp-10-5" {
  description              = "This rule checks whether the SageMaker Notebook instance is encrypted with a KMS key.  \nThis rule fails if the `KmsKeyId` field is empty.  \nKMS ensures data protection and allows you to gain more control over access to the data that you encrypt and assures the durability of the keys."
  enabled                  = true
  function_as_control      = false
  name                     = "SageMaker Notebook instance should be encrypted using a KMS Key"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n    input.KmsKeyId == null\n}\n\nexpectedConfiguration := \"The SageMaker Notebook Instance encrypted using a KMS Key\"\ncurrentConfiguration := \"The SageMaker Notebook Instance not encrypted using a KMS Key\""
  remediation_instructions = "Perform the following command to configure the SageMaker Notebook instance to be encrypted with your KMS Key, by creating an encrypted duplicate of the instance via AWS CLI:  \n```  \naws sagemaker create-notebook-instance --region {{region}} --notebook-instance-name <newInstanceName> --instance-type {{instanceType}} --role-arn {{roleArn}} --kms-key-id <kmsKeyId>  \n```  \nNote: you should delete the old instance once the new one is active."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["sagemaker#notebookinstanceupdated"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::SageMaker::NotebookInstance\"\n\tnot common_lib.valid_key(resource.Properties, \"KmsKeyId\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' is not defined\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::SageMaker::NotebookInstance\"\n\tis_string(resource.Properties.KmsKeyId)\n\tresource.Properties.KmsKeyId == \"\"\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.KmsKeyId\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' should not be empty\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' is empty\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_sagemaker_notebook_instance[name]\n\tnot common_lib.valid_key(resource, \"kms_key_id\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_sagemaker_notebook_instance\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_sagemaker_notebook_instance[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"aws_sagemaker_notebook_instance.kms_key_id should be defined and not null\",\n\t\t\"keyActualValue\": \"aws_sagemaker_notebook_instance.kms_key_id is undefined or null\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_sagemaker_notebook_instance](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/sagemaker_notebook_instance)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_control" "op-exp-8-r1-3" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor root account usage.\n\nIt is recommended to set an alarm that will be triggered for every use in the AWS root account. Monitoring for root account logins provides real-time visibility into the use of the fully privileged account."
  enabled                   = true
  name                      = "Subscription with no CloudWatch monitoring for root account usage"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 1\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_cloud_configuration_rule" "op-mon-1-1" {
  description              = "This rule checks whether a VPC has Flow Logs enabled.  \nThis rule fails if the VPC does not have Flow Logs configured or does have Flow Logs configured but not as the following:  \n* `TrafficType` field should be set to `ALL` or `ACCEPT`.  \n* `FlowLogStatus` should be set to `ACTIVE`.  \n* `DeliverLogsStatus` should be set to `SUCCESS`.  \n\nVPC Flow Logs is a feature that enables you to capture information about the IP traffic going to and from network interfaces in your VPC. Flow log data can be published to the following locations: Amazon CloudWatch Logs, Amazon S3, or Amazon Kinesis Data Firehose. After you create a flow log, you can retrieve and view the flow log records in the log group, bucket, or delivery stream that you configured."
  enabled                  = true
  function_as_control      = false
  name                     = "VPC accept traffic flow logs should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\ntrafficType := {\"ALL\", \"ACCEPT\"}\n\ntrafficTypeExist {\n\tflowLogs := input.FlowLogs\n\tupper(flowLogs[i].DeliverLogsStatus) == \"SUCCESS\"\n\tupper(flowLogs[i].FlowLogStatus) == \"ACTIVE\"\n\ttrafficType[upper(flowLogs[i].TrafficType)]\n}\n\n\nresult = \"fail\" {\n\tnot trafficTypeExist\n}\n\ncurrentConfiguration := \"VPC flow logs is disabled\"\nexpectedConfiguration := \"VPC flow logs should be enabled for 'Accept' traffic type\"\n"
  remediation_instructions = "Perform the following command to publish VPC Flow Logs to CloudWatch Logs via AWS CLI:   \n```\naws ec2 create-flow-logs \\\n--resource-type VPC \\\n--resource-ids {{vpcId}} \\\n--traffic-type ALL \\\n--log-group-name <The name of a CloudWatch Logs log group where Amazon EC2 publishes your flow logs> \\\n--deliver-logs-permission-arn <The ARN of the IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account>\n```  \n\n>**Note**  \n> This command publishes VPC Flow Logs to CloudWatch Logs, for more information about other options for storing Flow Logs follow this [link](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html)"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["vpc"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type = \"AWS::EC2::VPC\"\n\n\tnot CheckFlowLogExistance(name)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s has a FlowLogs resource associated\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s doesn't have a FlowLogs resource associated\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nCheckFlowLogExistance(service) = result {\n\tresult := [x |\n\t\tdocuments := input.document[index].Resources[a]\n\t\tdocuments.Type = \"AWS::EC2::FlowLog\"\n\t\tn := documents[_].ResourceId\n\t\tn == service\n\t\tx := true\n\t]\n\n\tcount(result) > 0\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nassociatedFlowlog(vpc, vpcName) {\n\tflowLog := input.document[i].resource.aws_flow_log[name]\n\tterraLib.associatedResources(vpc, flowLog, vpcName, null, null, \"vpc_id\")\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_vpc[name]\n\tnot associatedFlowlog(resource, name)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_vpc\",\n\t\t\"resourceName\": name,\n\t\t\"searchKey\": sprintf(\"aws_vpc[%s]\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_vpc[%s] should be the same as Flow Logs VPC id\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_vpc[%s] is not the same as Flow Logs VPC id\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_vpc\", name], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_flow_log[name]\n\tnot common_lib.valid_key(resource, \"vpc_id\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_vpc\",\n\t\t\"resourceName\": name,\n\t\t\"searchKey\": sprintf(\"aws_flow_log[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_flow_log[%s].vpc_id should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_flow_log[%s].vpc_id is undefined or null\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_flow_log\", name], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_flow_log](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/flow_log), [aws_vpc](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-6-r1-2" {
  description              = "This rule checks whether the IAM password policy is set to require at least one uppercase letter.  \nThis rule fails if `RequireUppercaseCharacters` is set to `false`, or if `accountPasswordPolicy` does not exist.  \nEnforcing IAM password strength, pattern, and rotation is a critical security practice, as having a strong password policy significantly reduces the risk of brute-force attacks.  \nAs a security best practice, it is recommended that users are required to have a strong password."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM password policy should require at least one uppercase letter"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tnot input.accountPasswordPolicy.RequireUppercaseCharacters\n}\n\ncurrentConfiguration := \"'RequireUppercaseCharacters' is set to False\"\nexpectedConfiguration := \"Uppercase characters should be required\""
  remediation_instructions = "Perform the following command to edit the IAM password policy enforcement/s via AWS CLI:  \n```  \naws iam update-account-password-policy \\\n  --require-uppercase-characters \\\n  [--require-lowercase-characters] \\\n  [--password-reuse-prevention <recommended: 10 or more>] \\\n  [--max-password-age <recommended: 90 (days) or less>] \\\n  [--minimum-password-length <recommended: 14 (characters) or more>] \\\n  [--require-symbols] \\\n  [--require-numbers]  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["account"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tpassword := resource.Properties.LoginProfile.Password\n\tis_string(password)\n\tnot contains(lower(password), \"secretsmanager\")\n\tnot regex.match(\".*[A-Z]\", password)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.LoginProfile.Password\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'Resources.Properties.LoginProfile.Password' should contain uppercase letter\",\n\t\t\"keyActualValue\": \"'Resources.Properties.LoginProfile.Password' doesnt contains uppercase letter\",\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tpassword_policy := input.document[i].resource.aws_iam_account_password_policy[name]\n\tnot common_lib.valid_key(password_policy, \"require_uppercase_characters\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(password_policy, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s]\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name], []),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"'require_uppercase_characters' should be set with true value\",\n\t\t\"keyActualValue\": \"'require_uppercase_characters' is undefined\",\n\t\t\"remediation\": \"require_uppercase_characters = true\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(password_policy, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tpassword_policy := input.document[i].resource.aws_iam_account_password_policy[name]\n\tpassword_policy.require_uppercase_characters == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(password_policy, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s].require_uppercase_characters\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name, \"require_uppercase_characters\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'require_uppercase_characters' should be true\",\n\t\t\"keyActualValue\": \"'require_uppercase_characters' is false\",\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(password_policy, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_account_password_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_account_password_policy)"
    type                     = "TERRAFORM"
  }
}





resource "wiz_control" "op-exp-10-1" {
  description               = null
  enabled                   = true
  name                      = "Users / roles with privileges for key creation must be different from those who will use the keys for encryption operations."
  project_id                = "*"
  query                     = "{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ENTITLES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"ALLOWS\"}],\"with\":{\"select\":true,\"type\":[\"ACCESS_ROLE_PERMISSION\"],\"where\":{\"accessTypes\":{\"EQUALS\":[\"HighPrivilege\"]}}}},{\"type\":[{\"type\":\"ALLOWS_ACCESS_TO\"}],\"with\":{\"select\":true,\"type\":[\"ENCRYPTION_KEY\"]}}],\"select\":true,\"type\":[\"IAM_BINDING\"]}},{\"type\":[{\"reverse\":true,\"type\":\"ENTITLES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"ALLOWS\"}],\"with\":{\"select\":true,\"type\":[\"ACCESS_ROLE_PERMISSION\"],\"where\":{\"accessTypes\":{\"EQUALS\":[\"Data\"]}}}},{\"type\":[{\"type\":\"ALLOWS_ACCESS_TO\"}],\"with\":{\"select\":true,\"type\":[\"ENCRYPTION_KEY\"]}}],\"select\":true,\"type\":[\"IAM_BINDING\"]}}],\"select\":true,\"type\":[\"USER_ACCOUNT\",\"SERVICE_ACCOUNT\"]}"
  resolution_recommendation = null
  scope_query               = "{\"type\":[\"USER_ACCOUNT\",\"SERVICE_ACCOUNT\"]}"
  security_sub_categories   = []
  severity                  = "MEDIUM"
}


resource "wiz_cloud_configuration_rule" "op-mon-3-r1-1" {
  description              = "This rule checks whether the Malware Protection feature in Amazon GuardDuty is enabled.  \nThis rule fails if the `EBS_MALWARE_PROTECTION` status is disabled.  \nGuardDuty Malware Protection helps identify potential security threats by scanning EBS volumes for malware, which can compromise the EC2 instances and the data stored within. It is recommended to keep this feature enabled to enhance the security posture of your AWS environment."
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty Detector Malware Protection should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"EBS_MALWARE_PROTECTION\"\n\nfeatureDisabled {\n\tupper(input.Features[feature].Name) == protection\n\tupper(input.Features[feature].Status) == \"DISABLED\"\n}\n\n\nresult = \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])\n"
  remediation_instructions = "Perform the following command to enable Malware Protection for GuardDuty via AWS CLI:\n\n```\naws guardduty update-member-detectors \\\n--detector-id {{detectorID}} \\\n--account-ids {{accountID}} \\\n--features '[{\"Name\": \"EBS_MALWARE_PROTECTION\", \"Status\": \"ENABLED\"}]'\n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
}



resource "wiz_cloud_configuration_rule" "mp-sw-2-r1-1" {
  description              = "This rule checks whether the CodeBuild project has logging options enabled.  \nThis rule fails if both logging options, S3 and CloudWatch, are disabled.  \nEnsure at least one logging option is configured to be able to efficiently respond to incidents and maintain the reliability and availability of the AWS CodeBuild project."
  enabled                  = true
  function_as_control      = false
  name                     = "CodeBuild project should have logging enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\ndisabledStatus := \"DISABLED\"\n\nresult = \"fail\" {\n\tinput.LogsConfig.CloudWatchLogs.Status == disabledStatus\n\tinput.LogsConfig.S3Logs.Status == disabledStatus\n}\n\ncurrentConfiguration := sprintf(\"All logging options are set to %s\", [disabledStatus])\nexpectedConfiguration := sprintf(\"At least one logging option should be configured\", [])\n"
  remediation_instructions = "Perform the following command to enable CodeBuild project logging via AWS CLI:  \n```  \naws codebuild update-project --name {{projectName}} --logs-config cloudWatchLogs={status=ENABLED,groupName=<groupName>,streamName=<streamName>},s3Logs={status=ENABLED,location=<location>,encryptionDisabled=false,bucketOwnerAccess=<bucketOwnerAccess>}  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["codebuild#project"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as commonLib\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.resource.aws_codebuild_project[name]\n\n\tnot terraLib.validKey(resource, \"logs_config\")\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_codebuild_project\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_codebuild_project[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_codebuild_project[%s].logs_config 'cloudwatch_logs' and 's3_logs' - 'status' should be set to 'ENABLED'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_codebuild_project[%s].logs_config is undefined\", [name]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.resource.aws_codebuild_project[name]\n\n\tlogConfig := terraLib.getArray(resource.logs_config)\n\tnot loggingEnabled(logConfig)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_codebuild_project\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_codebuild_project[%s].logs_config\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_codebuild_project[%s].logs_config 'cloudwatch_logs' and 's3_logs' - 'status' should be set to 'ENABLED'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_codebuild_project[%s].logs_config 'cloudwatch_logs' or 's3_logs' - 'status' is disabled\", [name]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nloggingEnabled(logConfig) {\n\tcloudwatchLog := terraLib.getArray(logConfig[i].cloudwatch_logs)[_]\n\tnot terraLib.validKey(cloudwatchLog, \"status\")\n}\n{\n\tcloudwatchLog := terraLib.getArray(logConfig[i].cloudwatch_logs)[_]\n\tcloudwatchLog.status == \"ENABLED\"\n} \n{\n\ts3Log := terraLib.getArray(logConfig[i].s3_logs)[_]\n\ts3Log.status == \"ENABLED\"\n}\n\t\n"
    remediation_instructions = "resource \"aws_codebuild_project\" \"example_project\" {\n  logs_config {\n    cloudwatch_logs {\n      status = \"ENABLED\"\n    }\n    s3_logs {\n      status = \"ENABLED\"\n    }\n  }\n}"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-7-2" {
  description              = "This rule checks whether the S3 Protection feature in Amazon GuardDuty is enabled.  \nThis rule fails if the `S3_DATA_EVENTS` status is disabled.  \nEnabling S3 Protection in GuardDuty helps to monitor S3 buckets for suspicious activities and protects sensitive data stored in S3 from unauthorized access or potential threats.  \nIt is recommended to enable S3 Protection in GuardDuty to enhance the security posture of your S3 buckets."
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty Detector S3 Protection should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"S3_DATA_EVENTS\"\n\nfeatureDisabled {\n\tupper(input.Features[feature].Name) == protection\n\tupper(input.Features[feature].Status) == \"DISABLED\"\n}\n\n\nresult = \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])\n"
  remediation_instructions = "Perform the following command to enable S3 Protection for GuardDuty via AWS CLI:\n\n```\naws guardduty update-member-detectors \\\n--detector-id {{detectorID}} \\\n--account-ids {{accountID}} \\\n--features '[{\"Name\": \"S3_DATA_EVENTS\", \"Status\": \"ENABLED\"}]'\n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\n\nrelatedFeature(document, detectorName){\n\tfeature := document.resource.aws_guardduty_detector_feature[featureName]\n\tfeature.name == \"S3_DATA_EVENTS\"\n\tfeature.status == \"ENABLED\"\n\tterraLib.associatedResources(null, feature, detectorName, null, null, \"detector_id\")\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.resource.aws_guardduty_detector[detectorName]\n    \n\tnot relatedFeature(document, detectorName)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, detectorName),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s]\", [detectorName]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s] should have aws_guardduty_detector_feature with S3_DATA_EVENTS associated and enabled\", [detectorName]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s] has no aws_guardduty_detector_feature with S3_DATA_EVENTS associated and enabled\", [detectorName]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "resource \"aws_guardduty_detector_feature\" \"example_feature\" {\n  detector_id = aws_guardduty_detector.example_detector.id\n  name        = \"S3_DATA_EVENTS\"\n  status      = \"ENABLED\"\n}"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-8-r1-16" {
  description              = "This rule checks whether CloudTrail at the organization level is configured as multi-region, global service logging is enabled, and management events are configured for all read/write operations.  \nEnsuring that a multi-region trail exists assists with detecting when unexpected activity occurs.  \nWhen global service logging is enabled, events on AWS global services are recorded as well. In addition, to ensure management operations performed on all resources are recorded as well, management events should be configured for all read/write operations."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail management events and global service logging should be enabled in all regions - Organization level"
  opa_policy               = "package wiz\n\ndefault result = \"fail\"\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\tlower(readOrWrite.Field) == \"readonly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tlower(currSelector.Field) == lower(currField)\n\tlower(currSelector.Equals[_]) == lower(currValue)\n}\n\n#returns value if configuration is good\nselectors[event] {\n\t#basic\n\tevent := input.EventSelectors[i]\n    event.IncludeManagementEvents\n    lower(event.ReadWriteType) == \"all\"\n}{\n\t#advanced\n\tevent := input.AdvancedEventSelectors[i]\n  \tcheckFieldSelector(event.FieldSelectors[_], \"eventCategory\", \"Management\")\n\tnot advanReadAndWrite(event.FieldSelectors)\n}\n\nresult = \"skip\" { #if account level\n\tnot input.IsOrganizationTrail\n}\nelse = \"pass\" {\n\tinput.IsMultiRegionTrail\n    input.CloudTrailStatus.IsLogging\n    count(selectors) > 0\n}\ncurrentConfiguration := sprintf(\"IsMultiRegionTrail setting is set to: %s. IsLogging is set to: %s. Required event selector exists: %s\", [input.IsMultiRegionTrail, input.CloudTrailStatus.IsLogging, count(selectors) > 0])\nexpectedConfiguration := \"IsMultiRegionTrail and IsLogging should be set to true. There should be at least one event selector with IncludeManagementEvents set to true and ReadWriteType set to 'All'\""
  remediation_instructions = "Perform the following commands in order to modify CloudTrail via CLI:  \n1. Use the following command in order to enable Multi-region CloudTrail logging:  \n```  \naws cloudtrail update-trail --name {{trailName}} --is-multi-region-trail  \n```  \n2. Use the following command in order to start CloudTrail logging:  \n```  \naws cloudtrail start-logging --name {{trailName}}  \n```  \n3. Use the following command in order to modify CloudTrail event selectors:  \n```  \naws cloudtrail put-event-selectors --trail-name {{trailName}} --event-selectors '[{\"ReadWriteType\": \"All\",\"IncludeManagementEvents\": true}]'  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tcommon_lib.valid_key(resource.Properties, \"IsMultiRegionTrail\")\n\tnot checkRegion(resource)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.IsMultiRegionTrail\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' is false\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tnot common_lib.valid_key(resource.Properties, \"IsMultiRegionTrail\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' should exist\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' is missing\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\ncheckRegion(cltr) {\n\tcltr.Properties.IsMultiRegionTrail == true\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nisOrganizationLevel(cloudtrailResource) {\n\tcloudtrailResource.is_organization_trail == true\n}\n\nisMultiRegionTrail(cloudtrailResource) {\n\tnot common_lib.valid_key(cloudtrailResource, \"is_multi_region_trail\")\t\n}{\n\tcloudtrailResource.is_multi_region_trail == false\n}\n\n#check for read and write permissions in basic event selectors\nbasicReadAndWrite(eventSel) {\n\teventSel.read_write_type == \"All\"\n}\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\treadOrWrite.field == \"readOnly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tcurrSelector.field == currField\n\tcurrSelector.equals[_] == currValue\n}\n\nadvancedEventSelectorWithManagementEvents(currEventSel) {\n  \tcheckFieldSelector(currEventSel[_], \"eventCategory\", \"Management\")\n  \tnot advanReadAndWrite(currEventSel)\n}\n\nbasicResourcesWithManagementEvents(eventSel) {\n\teventSel.include_management_events == true\n}\n\n#seperate checks for advanced single and multi selectors\nadvancedEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.advanced_event_selector[_]\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.advanced_event_selector\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\t\n}\n\n#seperate checks for basic single and multi event selectors\nbasicEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.event_selector[_]\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.event_selector\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}\n\n#check event selector for basic and advanced resources\nconfiguredWithManagementEvents(cloudtrailResource) {\n\t# Basic \n  \tbasicEventSelc(cloudtrailResource)\n}{ \n\t# Advanced\n\tadvancedEventSelc(cloudtrailResource)\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[cloudtrailName]  \n\tnot configuredWithManagementEvents(cloudtrailResource)\n \tisOrganizationLevel(cloudtrailResource)\n\tisMultiRegionTrail(cloudtrailResource)\n\t\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, cloudtrailName),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [cloudtrailName]),\n\t\t\"keyExpectedValue\": sprintf(\"cloudtrail %v should be configured with management events and multi region\",[cloudtrailName]),\n\t\t\"keyActualValue\": sprintf(\"cloudtrail %v is not configured with management events and multi region\",[cloudtrailName]),\n  \t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {})\n\t}\n}\n\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\tnot common_lib.valid_key(cloudtrailResource, \"is_multi_region_trail\")\n\tisOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail is defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail is undefined or null\", [name]),\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\tcloudtrailResource.is_multi_region_trail == false\n\tisOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail is set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail is set to false\", [name]),\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\tcloudtrailResource.enable_logging == false\n\tisOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].enable_logging\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s].enable_logging undefined or is set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s].enable_logging is set to false\", [name]),\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudtrail](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudtrail)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-2-1" {
  description              = "This rule checks whether the EC2 instance only allows the use of the Instance Metadata Service Version 2 (IMDSv2).  \nThis rule fails if `HttpTokens` is set to `optional`.  \nThis rule skips if `HttpTokens` is not present which indicates that IMDS is disabled altogether.\nThe Instance Metadata Service allows EC2s to query a private link address for their own metadata and data input by the user.  \nThis has many benefits, including better credential safety - since the need to hard-code credentials or distribute sensitive credentials to instances is eliminated by the use of this service.  \nThe first version of this service was prone to several forms of attack, which allowed attackers access to instances' sensitive metadata and credentials.  \nFor this reason, AWS developed an enhanced version of this service - helping protect instances from forms of attack previously made possible.  \nIt is recommended to only allow the use of IMDSv2 on EC2 instances, to help protect them from attacks exploiting the older version of the service.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "EC2 instance should use IMDSv2"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nincompliantIMDS {\n\tlower(input.MetadataOptions.HttpTokens) != \"required\"\n}\n\nMetadataAccessibleDisabled{\n\tnot input.MetadataOptions.HttpTokens\n}\n\nresult := \"skip\"{\n\tMetadataAccessibleDisabled\n}\nelse := \"fail\" {\n\tincompliantIMDS\n}\n\ncurrentConfiguration := \"'HttpTokens': 'optional'\"\nexpectedConfiguration := \"'HttpTokens' should be set to 'required'\"\n"
  remediation_instructions = "Perform the following command to configure EC2 to only allow the use of IMDSv2 via AWS CLI:  \n```  \naws ec2 modify-instance-metadata-options --instance-id {{instanceId}} --http-tokens required --http-endpoint enabled  \n```\n>**Note**  \n>It is recommended to make sure the EC2's software supports IMDSv2 prior to performing this command.  \n>Follow [this link](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-cfg-ec2-imds.html) for things to take into consideration before switching over to using only IMDSv2, and [this link](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-metadata-transition-to-version-2.html) for tools and recommendations for performing the transition."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["virtualMachine"]

  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n    document := input.document[i]\n    resource := document.Resources[key]\n    lower(resource.Type) == \"aws::ec2::launchtemplate\"\n\n    properties := resource.Properties\n    launchTemplateData := properties.LaunchTemplateData\n    \n    not common_lib.valid_key(launchTemplateData, \"MetadataOptions\")\n    \n    result := {\n        \"documentId\": document.id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, key),\n        \"resourceType\": \"AWS::EC2::LaunchTemplate\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.LaunchTemplateData\", [key]),\n        \"issueType\": \"MissingAttribute\",\n        \"keyExpectedValue\": sprintf(\"Resources.%s.Properties.LaunchTemplateData.MetadataOptions should be defined with HttpEndpoint set to 'disabled' or HttpTokens set to 'required'\", [key]),\n        \"keyActualValue\": sprintf(\"Resources.%s.Properties.LaunchTemplateData.MetadataOptions is not defined\", [key]),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}\n\nWizPolicy[result] {\n    document := input.document[i]\n    resource := document.Resources[key]\n    lower(resource.Type) == \"aws::ec2::launchtemplate\"\n\n    properties := resource.Properties\n    metadataOptions := properties.LaunchTemplateData.MetadataOptions\n    \n    common_lib.valid_key(metadataOptions, \"HttpEndpoint\")\n    lower(metadataOptions.HttpEndpoint) != \"disabled\"\n\n    not common_lib.valid_key(metadataOptions, \"HttpTokens\")\n    \n    result := {\n        \"documentId\": document.id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, key),\n        \"resourceType\": \"AWS::EC2::LaunchTemplate\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.LaunchTemplateData.MetadataOptions\", [key]),\n        \"issueType\": \"MissingAttribute\",\n        \"keyExpectedValue\": sprintf(\"Resources.%s.Properties.LaunchTemplateData.MetadataOptions.HttpTokens should be set to 'required' when HttpEndpoint is not 'disabled'\", [key]),\n        \"keyActualValue\": sprintf(\"Resources.%s.Properties.LaunchTemplateData.MetadataOptions.HttpTokens is missing and HttpEndpoint is not 'disabled'\", [key]),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}\n\nWizPolicy[result] {\n    document := input.document[i]\n    resource := document.Resources[key]\n    lower(resource.Type) == \"aws::ec2::launchtemplate\"\n\n    properties := resource.Properties\n    metadataOptions := properties.LaunchTemplateData.MetadataOptions\n    \n    common_lib.valid_key(metadataOptions, \"HttpEndpoint\")\n    lower(metadataOptions.HttpEndpoint) != \"disabled\"\n\n    common_lib.valid_key(metadataOptions, \"HttpTokens\")\n    lower(metadataOptions.HttpTokens) != \"required\"\n\n    result := {\n        \"documentId\": document.id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, key),\n        \"resourceType\": \"AWS::EC2::LaunchTemplate\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.LaunchTemplateData.MetadataOptions.HttpTokens\", [key]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"Resources.%s.Properties.LaunchTemplateData.MetadataOptions.HttpTokens should be set to 'required' when HttpEndpoint is not 'disabled'\", [key]),\n        \"keyActualValue\": sprintf(\"Resources.%s.Properties.LaunchTemplateData.MetadataOptions.HttpTokens is set to '%s' and HttpEndpoint is not 'disabled'\", [key, metadataOptions.HttpTokens]),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
}

resource "wiz_cloud_configuration_rule" "mp-info-6-2" {
  description              = "This rule checks if the Backup Plan Rule includes an RDS database, Aurora cluster, DocumentDB cluster, or Neptune database resource.  \nThis rule fails if `Selections.BackupSelection.Resources` includes at least one `arn:aws:rds` resource or `*` - indicating that all resources are included.  It does not take into account any other factors such as conditions, tags, schedule settings, etc.  \nYou can view the resources included in the plan rule and its settings by inspecting the resource JSON in Wiz under `Selections`.\n>**Note**  \nThis rule is informational and does not indicate a misconfiguration."
  enabled                  = true
  function_as_control      = false
  name                     = "Backup Plan Rule includes RDS resources"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"fail\" {\n\tstartswith(input.Selections[_].BackupSelection.Resources[_], \"arn:aws:rds:\")\n}{\n\tinput.Selections[_].BackupSelection.Resources[_] == \"*\"\n}\n\ncurrentConfiguration := \"At least one RDS/Aurora/Neptune/DocumentDB resource is included in the backup plan rule\"\nexpectedConfiguration := \"This rule is informational and does not indicate a misconfiguration\"\n"
  remediation_instructions = "Perform the following steps to create a new backup plan rule via AWS CLI:\n\n1. If you do not already have a Backup Plan that you want to use, you can create one using the command below, otherwise, skip to the next step.  \n1a. Use this template to create a JSON file with your required Backup Plan configuration:\n```\n{\n  \"BackupPlan\":{\n    \"BackupPlanName\":\"test-plan\",\n    \"Rules\":[\n      {\n        \"RuleName\":<\"rule-name\">,\n        \"TargetBackupVaultName\":<\"vault-name>\",\n        \"ScheduleExpression\":<\"cron(0 1 ? * * *)>\",\n        \"ScheduleExpressionTimezone\":<\"America/Los_Angeles\">,\n        \"StartWindowMinutes\":<value>, // Value is integer in minutes\n        \"CompletionWindowMinutes\":<value>, // Value is integer in minutes\n        \"Lifecycle\":{\n          \"DeleteAfterDays\":<value>, // Value is integer in days\n        }\n      }\n    ]\n  }\n}\n```\nStore your JSON document locally with a name you choose.\n\n1b. Use the following command to create the new Backup Plan:\n```\naws backup create-backup-plan --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```\n\n2. In this step we will assign resources to the Backup Plan.  \n2a. Use this template to create a JSON file with your required plan rule configuration:\n```\n{\n  \"BackupPlanId\":<\"BACKUP-PLAN-ID\">, // The plan ID created in the previous command\n  \"BackupSelection\":{\n    \"SelectionName\":<\"selection-name\">, \n    \"IamRoleArn\":<\"arn:aws:iam::ACCOUNT-ID:role/IAM-ROLE-ARN\">,\n    \"Resources\":[\n      <\"arn:aws:ec2:*:*:instance/*\">,\n    ]\n  }\n}\n```\nFor more JSON examples, click [here](https://docs.aws.amazon.com/aws-backup/latest/devguide/assigning-resources.html#assigning-resources-json).  \nStore your JSON document locally with a name you choose.\n\n2b. Use the following command to create the new Backup Plan Rule:\n```\naws backup create-backup-selection --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "INFORMATIONAL"
  target_native_types      = ["backup#backuprule"]
}

resource "wiz_control" "op-exp-8-r1-13" {
  description               = "The CloudWatch Log Group, which is storing Step Functions State Machine logs, does not have a Metric Alert configured.\n\nIt is recommended to set an alarm that will be triggered for every execution of the workflow. Monitoring executions helps detect and respond to unapproved actions."
  enabled                   = true
  name                      = "CloudWatch Log Group of a Step Functions State Machine has no Monitor Alert configured"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"type\":\"HAS\"}],\"with\":{\"type\":[\"MONITOR_ALERT\"]}},{\"type\":[{\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"as\":\"scoped_entity\",\"select\":true,\"type\":[\"SERVICE_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"statemachine\"]}}}}],\"select\":true,\"type\":[\"CLOUD_LOG_CONFIGURATION\"]}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SERVICE_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"statemachine\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_cloud_configuration_rule" "op-exp-7-12" {
  description              = "This rule checks whether the CloudFront distribution logging is enabled and logs to an S3 bucket.  \nThis rule fails if the key `distribution.Logging` is disabled.  \nIt is recommended to enable the distribution logging feature to track all viewer requests from the Content Delivery Network (CDN). Combining distribution logging with other AWS services such as AWS Lambda and AWS WAF can block requests that are aimed at finding vulnerabilities in the network.\n>**Note:**\n>this CCR checks for legacy logging only and not V2\n"
  enabled                  = true
  function_as_control      = false
  name                     = "CloudFront distribution logging should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tinput.distribution.DistributionConfig.Logging.Enabled == false\n}\n\ncurrentConfiguration := \"The distribution logging is not enabled\"\nexpectedConfiguration := \"The distribution logging should be set to enabled\""
  remediation_instructions = "Perform the following commands in order to modify CloudFront to enable distribution logging via AWS CLI:  \n1. Use the following command to get the `ETag` and save it for further steps:  \n  \n```  \nexport ETag=$(aws cloudfront get-distribution-config \\\n    --id {{distributionID}} \\\n    --query='ETag' --output=text)  \n```  \n  \n2. Use the following command to get the configuration of the CloudFront distribution and write it to a new file:  \n  \n```  \naws cloudfront get-distribution-config \\\n    --id {{distributionID}} \\\n    --query='DistributionConfig' > DistributionConfig.json  \n```  \n  \n3. Edit the ***DistributionConfig.json*** file:    \n    3a. Set the `Logging.Enabled` value to `true`.    \n    3b. Set the `Logging.Bucket` to a specific S3 bucket.    \n  \n4. Use the following command:  \n```  \naws cloudfront update-distribution \\\n    --id {{distributionID}} \\\n    --distribution-config file://DistributionConfig.json \\\n    --if-match $ETag  \n```  \n5. Optional - Use the following command in order to delete the ***DistributionConfig.json*** file:  \n```  \nrm DistributionConfig.json  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["cloudfront"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::CloudFront::Distribution\"\n\n\tdistributionConfig := resource.Properties.DistributionConfig\n\tnot cloudFormationLib.isCloudFormationFalse(distributionConfig.Enabled)\n\tnot common_lib.valid_key(distributionConfig, \"Logging\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.DistributionConfig.Logging should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.DistributionConfig.Logging is undefined\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::CloudFront::Distribution\"\n\n\tdistributionConfig := resource.Properties.DistributionConfig\n\tnot cloudFormationLib.isCloudFormationFalse(distributionConfig.Enabled)\n\n\tbucketCorrect := resource.Properties.DistributionConfig.Logging.Bucket\n\tendswith(bucketCorrect, \".s3.amazonaws.com\") == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.DistributionConfig.Logging.Bucket\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.DistributionConfig.Logging.Bucket should have the domain '.s3.amazonaws.com'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.DistributionConfig.Logging.Bucket does not have the correct domain\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as commonLib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource\n\tcloudfront := resource.aws_cloudfront_distribution[name]\n\tcloudfront.enabled == true\n\tnot terraLib.validKey(cloudfront, \"logging_config\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudfront_distribution\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudfront_distribution[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudfront_distribution[%s].logging_config should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudfront_distribution[%s].logging_config is undefined\", [name]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}




resource "wiz_control" "mp-com-2-r5-1" {
  description               = null
  enabled                   = true
  name                      = "Database or bucket with sensitive data  not encrypted data in transit"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"HAS_DATA_FINDING\"}],\"with\":{\"as\":\"scoped_entity\",\"select\":true,\"type\":[\"DB_SERVER\",\"BUCKET\",\"AI_DATASET\"],\"where\":{\"requiresSSL\":{\"EQUALS\":false}}}}],\"select\":true,\"type\":[\"DATA_FINDING\"]}"
  resolution_recommendation = null
  scope_query               = "{\"type\":[\"DB_SERVER\",\"BUCKET\",\"AI_DATASET\"]}"
  security_sub_categories   = []
  severity                  = "MEDIUM"
}


resource "wiz_cloud_configuration_rule" "op-acc-4-1" {
  description              = "This rule checks whether the IAM policy (customer-managed or inline) allows actions on all resources.  \nThis rule fails if the policy contains at least one statement where:  \n* `Effect` is `Allow`\n* `Resource` is`*` \n* `Condition` is null or does not exist  \n\nIt is generally not recommended to allow actions for all resources.  \nIt is recommended to follow the principle of least privilege (PoLP) and restrict the policy to only the required resources."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM policy should not allow actions on all resources"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\niamPolicy := policy {\n# for parsed policies:\n\tinput.Version\n\tpolicy := input\n}{\n# for policies that require parsing:\n\tpolicy := json.unmarshal(input)\n}\n\nallResources(statement) {\n\tstatement.Resource == \"*\"\n}{\n\tstatement.Resource[_] == \"*\"\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\nstatementAllowsAllResources[statement] {\n\tstatement := iamPolicy.Statement[_]\n\tallResources(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n}\n\nresult := \"fail\" {\n\tcount(statementAllowsAllResources) > 0\n}\n\ncurrentConfiguration := \"Policy allows all resources\"\nexpectedConfiguration := \"Policy should limit the resource element\""
  remediation_instructions = "Perform the following commands to delete or modify the IAM policy via AWS CLI:    \n1. First, use the following command to list the IAM entities (Users\\Roles\\Groups) that have the policy attached (if any):  \n```  \naws iam list-entities-for-policy \\  \n    --policy-arn <value>  \n```  \n* If the policy **is not attached** to IAM entities - proceed to 2a.    \n* If the policy **is attached** to one or more IAM entities - proceed to 2b.    \n\n2a. As this policy is not in use, it is recommended to delete it. Use the following command to delete the policy:  \n```  \naws iam delete-policy \\  \n    --policy-arn <value>  \n```  \n2b. It is recommended to edit the policy and remove the permissive statement.    \nFirst, use the following command to view the policy and locate the overly-permissive statement/s.    \n**Note:** You can also view the policy in the native object JSON in Wiz.  \n```  \naws iam get-policy \\  \n    --policy-arn <value> \\  \n    --version-id <value>  \n```  \nIf you are not sure what the policy version id is, use the following command to check. It is the 'DefaultVersionId' in the output:  \n```  \naws iam get-policy-version \\  \n    --policy-arn <value>  \n```  \nNext, create a new policy in a JSON file locally which replaces the wildcards `*` with the required actions and resources only.    \nUse the following command to create a new policy version with the new policy created and set it as default:  \n```  \naws iam create-policy-version \\  \n    --policy-arn <value> \\  \n    --policy-document file://<NewPolicyVersion.json> \\  \n    --set-as-default  \n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["customerManagedPolicy", "inlinePolicy"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as tf_lib\n\nWizPolicy[result] {\n\tresourceType := {\"aws_iam_role_policy\", \"aws_iam_user_policy\", \"aws_iam_group_policy\", \"aws_iam_policy\", \"aws_ssoadmin_permission_set_inline_policy\"}\n\tresource := input.document[i].resource[resourceType[idx]][name]\n\n\tpolicy := common_lib.json_unmarshal(resource.policy)\n\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.equalsOrInArray(statement.Resource, \"*\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": resourceType[idx],\n\t\t\"resourceName\": tf_lib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s[%s].policy\", [resourceType[idx], name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'policy.Statement.Resource' shouldn't contain '*'\",\n\t\t\"keyActualValue\": \"'policy.Statement.Resource' contains '*'\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", resourceType[idx], name, \"policy\"], []),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].data.aws_iam_policy_document[name]\n\n    policy := {\"Statement\": resource.statement}\n\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.equalsOrInArray(statement.resources, \"*\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_policy_document\",\n\t\t\"resourceName\": tf_lib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_policy_document[%s].policy\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'policy.Statement.resources' shouldn't contain '*'\",\n\t\t\"keyActualValue\": \"'policy.Statement.resources' contains '*'\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_policy_document\", name, \"policy\"], []),\n\t}\n}"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-exp-3-r4-1" {
  description              = "This rule checks if the EC2 Instance is managed by AWS Systems Manager (SSM) and the agent is online.  \nThis rule fails if `SsmInstanceInformation` is `null` or if `PingStatus` is not `Online`.  \nAWS Systems Manager is a management service that helps you automatically collect software inventory, apply OS patches, create system images, and configure Windows and Linux operating systems. These capabilities help you define and track system configurations, prevent drift, and maintain software compliance of your EC2 and on-premises configurations. By using SSM to manage EC2 instances, you can simplify resource and application management, shorten the time to detect and resolve operational problems, and make it easier to operate and manage your infrastructure at scale.  \nIt is recommended to manage EC2 instances with SSM for improved operational efficiency, security, and compliance."
  enabled                  = true
  function_as_control      = false
  name                     = "EC2 Instance should be managed by online SSM agent"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\ninstanceManagedByOnlineSsmAgent {\n\tlower(input.SsmInstanceInformation.PingStatus) == \"online\"\n}\n\nresult := \"fail\" {\n\tnot instanceManagedByOnlineSsmAgent\n}\n\ncurrentConfiguration := \"'SsmInstanceInformation': 'null' or 'PingStatus' is not 'Online'\"\nexpectedConfiguration := \"EC2 instance should be managed by SSM with 'PingStatus: Online'\""
  remediation_instructions = "For instructions on installing an SSM Agent on the EC2 Instance, see the [AWS guide](https://docs.aws.amazon.com/systems-manager/latest/userguide/manually-install-ssm-agent-linux.html).\n\nEC2 Instance Platform Details: `{{platformDetails}}`."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["virtualMachine"]
}


resource "wiz_cloud_configuration_rule" "op-acc-4-4" {
  description              = "This rule checks whether the IAM policy (customer-managed or inline) allows all actions on a service.  \nThis rule fails if the policy contains at least one statement where:  \n* `Effect` is `Allow`\n* `Action` ends with `:*` \n* `Condition` is null or does not exist  \n\nIt is generally not recommended to allow all actions for a service (`Service:*`).  \nIt is recommended to follow the principle of least privilege (PoLP) and restrict the policy to only the required service actions."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM policy should not allow all actions on any service"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\niamPolicy := policy {\n# for parsed policies:\n\tinput.Version\n\tpolicy := input\n}{\n# for policies that require parsing:\n\tpolicy := json.unmarshal(input)\n}\n\nallServiceActions(statement) {\n\tendswith(statement.Action, \":*\")\n}{\n\tendswith(statement.Action[_], \":*\")\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\nstatementAllowsAllServiceActions[statement] {\n\tstatement := iamPolicy.Statement[_]\n\tallServiceActions(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n}\n\nresult := \"fail\" {\n\tcount(statementAllowsAllServiceActions) > 0\n}\n\ncurrentConfiguration := \"Policy allows all service actions\"\nexpectedConfiguration := \"Policy should not allow all service actions\""
  remediation_instructions = "Perform the following commands to delete or modify the IAM policy via AWS CLI:    \n1. First, use the following command to list the IAM entities (Users\\Roles\\Groups) that have the policy attached (if any):  \n```  \naws iam list-entities-for-policy \\\n    --policy-arn <value>  \n```  \n* If the policy **is not attached** to IAM entities - proceed to 2a.    \n* If the policy **is attached** to one or more IAM entities - proceed to 2b.    \n\n2a. As this policy is not in use, it is recommended to delete it. Use the following command to delete the policy:  \n```  \naws iam delete-policy \\\n    --policy-arn <value>  \n```  \n2b. It is recommended to edit the policy and remove the permissive statement.    \nFirst, use the following command to view the policy and locate the overly-permissive statement/s.    \n**Note:** You can also view the policy in the native object JSON in Wiz.  \n```  \naws iam get-policy \\\n    --policy-arn <value> \\\n    --version-id <value>  \n```  \nIf you are not sure what the policy version id is, use the following command to check. It is the 'DefaultVersionId' in the output:  \n```  \naws iam get-policy-version \\\n    --policy-arn <value>  \n```  \nNext, create a new policy in a JSON file locally which replaces the wildcards `*` with the required actions and resources only.    \nUse the following command to create a new policy version with the new policy created and set it as default:  \n```  \naws iam create-policy-version \\\n    --policy-arn <value> \\\n    --policy-document file://<NewPolicyVersion.json> \\\n    --set-as-default  \n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["customerManagedPolicy", "inlinePolicy"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\n# Check AWS::IAM::Policy resources\nWizPolicy[result] {\n    resource := input.document[i].Resources[name]\n    lower(resource.Type) == \"aws::iam::policy\"\n\n    policy := resource.Properties.PolicyDocument\n    st := common_lib.get_statement(common_lib.get_policy(policy))\n    statement := st[_]\n    \n    common_lib.is_allow_effect(statement)\n    common_lib.equalsOrInArray(statement.Action, \"*\")\n    \n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": \"AWS::IAM::Policy\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.PolicyDocument\", [name]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.PolicyDocument.Statement' should not allow '*' as an action\", [name]),\n        \"keyActualValue\": sprintf(\"'Resources.%s.Properties.PolicyDocument.Statement' allows '*' as an action\", [name]),\n        \"searchLine\": common_lib.build_search_line([\"Resources\", name, \"Properties\", \"PolicyDocument\"], []),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}\n\n# Check AWS::IAM::Group resources with inline policies\nWizPolicy[result] {\n    resource := input.document[i].Resources[name]\n    lower(resource.Type) == \"aws::iam::group\"\n\n    policies := object.get(resource.Properties, \"Policies\", [])\n    count(policies) > 0\n    policy := policies[idx]\n    \n    st := common_lib.get_statement(common_lib.get_policy(policy.PolicyDocument))\n    statement := st[_]\n    \n    common_lib.is_allow_effect(statement)\n    common_lib.equalsOrInArray(statement.Action, \"*\")\n    \n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": \"AWS::IAM::Group\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.Policies[%d].PolicyDocument\", [name, idx]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.Policies[%d].PolicyDocument.Statement' should not allow '*' as an action\", [name, idx]),\n        \"keyActualValue\": sprintf(\"'Resources.%s.Properties.Policies[%d].PolicyDocument.Statement' allows '*' as an action\", [name, idx]),\n        \"searchLine\": common_lib.build_search_line([\"Resources\", name, \"Properties\", \"Policies\", idx, \"PolicyDocument\"], []),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}\n\n# Check AWS::IAM::Role resources with inline policies\nWizPolicy[result] {\n    resource := input.document[i].Resources[name]\n    lower(resource.Type) == \"aws::iam::role\"\n\n    policies := object.get(resource.Properties, \"Policies\", [])\n    count(policies) > 0\n    policy := policies[idx]\n    \n    st := common_lib.get_statement(common_lib.get_policy(policy.PolicyDocument))\n    statement := st[_]\n    \n    common_lib.is_allow_effect(statement)\n    common_lib.equalsOrInArray(statement.Action, \"*\")\n    \n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": \"AWS::IAM::Role\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.Policies[%d].PolicyDocument\", [name, idx]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.Policies[%d].PolicyDocument.Statement' should not allow '*' as an action\", [name, idx]),\n        \"keyActualValue\": sprintf(\"'Resources.%s.Properties.Policies[%d].PolicyDocument.Statement' allows '*' as an action\", [name, idx]),\n        \"searchLine\": common_lib.build_search_line([\"Resources\", name, \"Properties\", \"Policies\", idx, \"PolicyDocument\"], []),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}\n\n# Check AWS::IAM::User resources with inline policies\nWizPolicy[result] {\n    resource := input.document[i].Resources[name]\n    lower(resource.Type) == \"aws::iam::user\"\n\n    policies := object.get(resource.Properties, \"Policies\", [])\n    count(policies) > 0\n    policy := policies[idx]\n    \n    st := common_lib.get_statement(common_lib.get_policy(policy.PolicyDocument))\n    statement := st[_]\n    \n    common_lib.is_allow_effect(statement)\n    common_lib.equalsOrInArray(statement.Action, \"*\")\n    \n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": \"AWS::IAM::User\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.Policies[%d].PolicyDocument\", [name, idx]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.Policies[%d].PolicyDocument.Statement' should not allow '*' as an action\", [name, idx]),\n        \"keyActualValue\": sprintf(\"'Resources.%s.Properties.Policies[%d].PolicyDocument.Statement' allows '*' as an action\", [name, idx]),\n        \"searchLine\": common_lib.build_search_line([\"Resources\", name, \"Properties\", \"Policies\", idx, \"PolicyDocument\"], []),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as tf_lib\n\nWizPolicy[result] {\n\tresourceType := {\"aws_iam_role_policy\", \"aws_iam_user_policy\", \"aws_iam_group_policy\", \"aws_iam_policy\", \"aws_ssoadmin_permission_set_inline_policy\"}\n\tresource := input.document[i].resource[resourceType[idx]][name]\n\n\tpolicy := common_lib.json_unmarshal(resource.policy)\n\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.equalsOrInArray(statement.Action, \"*\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": resourceType[idx],\n\t\t\"resourceName\": tf_lib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s[%s].policy\", [resourceType[idx], name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'policy.Statement.Action' shouldn't contain '*'\",\n\t\t\"keyActualValue\": \"'policy.Statement.Action' contains '*'\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", resourceType[idx], name, \"policy\"], []),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].data.aws_iam_policy_document[name]\n\n    policy := {\"Statement\": resource.statement}\n\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.equalsOrInArray(statement.actions, \"*\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_policy_document\",\n\t\t\"resourceName\": tf_lib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_policy_document[%s].policy\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'policy.Statement.actions' shouldn't contain '*'\",\n\t\t\"keyActualValue\": \"'policy.Statement.actions' contains '*'\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_policy_document\", name, \"policy\"], []),\n\t}\n}"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-10-7" {
  description              = "This rule checks if the KMS Key resource policy allows all KMS actions.  \nThis rule skips resource policies that do not contain KMS-related statements (KMS actions or resources) and fails if the policy contains a Statement where:\n* `Effect` is `Allow`\n* `Action` is `kms:*`\n* `Condition` is null or does not exist\n\nIncluding a wildcard (`*`) in the action clause of an AWS Key Management Service (KMS) key policy is not recommended because this can grant excessive access to the key. By using specific actions instead of wildcards, you can ensure that only the intended actions are allowed and prevent unintended actions from being taken on the resources.\n>**Note**  \n>The rule will consider the default KMS key policy statement as allowed, although it contains all KMS actions.\n>Read more [here](https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-default.html#key-policy-default-allow-root-enable-iam).\n"
  enabled                  = true
  function_as_control      = false
  name                     = "KMS key policy should not allow all KMS actions"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresourcePolicy = policy {\n# for parsed policies:\n\tinput.Version\n\tpolicy := input\n}{\n# for policies that require parsing:\n\tpolicy := json.unmarshal(input)\n}\n\n# While '*' also allows all KMS actions, it is not added to the logic to reduce false positive detections.\n# Cloud Configuration Rule 'IAM-184' detects resource-based policies that allow all actions.\nkmsKeyPolicy(statement) {\n\tstartswith(lower(statement.Action), \"kms:\")\n}{\n\tstartswith(lower(statement.Action[_]), \"kms:\")\n}{\n\tcontains(lower(statement.Resource), \"kms\")\n}{\n\tcontains(lower(statement.Resource[_]), \"kms\")\n}\n\nkmsWildcardActions := \"kms:*\"\n\nallKmsActions(statement) {\n\tlower(statement.Action[_]) == kmsWildcardActions\n}{\n\tlower(statement.Action) == kmsWildcardActions\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\n# The logic will consider the default KMS key policy statement as allowed, although it contains all KMS actions.\n# Read more here: https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-default.html#key-policy-default-allow-root-enable-iam\nisDefaultKmsPolicy(statement) {\n\tlower(statement.Sid) == \"enable iam user permissions\"\n\tregex.match(\"^arn:.*:iam::\\\\d{12}:root$\", statement.Principal.AWS)\n\tstatement.Action == kmsWildcardActions\n\tstatement.Resource == \"*\"\n}\n\nkmsPolicyAllowsAllActions[statement] {\n\tstatement := resourcePolicy.Statement[s]\n\tallKmsActions(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n\tnot isDefaultKmsPolicy(statement)\n}\n\nkmsRelatedStatement[statement] {\n\tstatement := resourcePolicy.Statement[s]\n\tkmsKeyPolicy(statement)\n}\n\n# Skips all policies that don't contain KMS-related statements (action/resource), \n# and passes the default KMS key policy statement.\nresult = \"skip\" {\n\tcount(kmsRelatedStatement) == 0\n} else = \"fail\" { \n\tcount(kmsPolicyAllowsAllActions) > 0\n}\n\ncurrentConfiguration := \"KMS Key policy allows all (*) KMS actions\"\nexpectedConfiguration := \"KMS Key policy should not allow all KMS actions\""
  remediation_instructions = "Perform the following commands to attach a new KMS key policy via AWS CLI:  \n1. Locate the Key ID of the KMS key to which the policy is attached.\n\n2. Create a local JSON file containing a new least-privilege key policy.\n\n3. Using the information from steps 1 and 2, perform the following command to update the KMS key policy:\n```\naws kms put-key-policy \\\n    --policy-name default \\\n    --key-id <Your key ID> \\\n    --policy file://new-key-policy.json\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["resourcePolicy"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresources := input.document[i].Resources[name]\n\tresources.Type == \"AWS::KMS::Key\"\n\tpolicy := resources.Properties.KeyPolicy\n\tst := common_lib.get_statement(common_lib.get_policy(policy))\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tnot common_lib.valid_key(statement, \"Condition\")\n\tcommon_lib.has_wildcard(statement, \"kms:*\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resources, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.KeyPolicy\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.KeyPolicy.Statement should not have wildcard in 'Action' and 'Principal'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.KeyPolicy.Statement has wildcard in 'Action' and 'Principal'\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resource\", name, \"Properties\", \"KeyPolicy\"], []),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resources),\n\t}\n}\n\nWizPolicy[result] {\n\tresources := input.document[i].Resources[name]\n\tresources.Type == \"AWS::KMS::Key\"\n\n\tnot common_lib.valid_key(resources.Properties, \"KeyPolicy\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resources, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.KeyPolicy should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.KeyPolicy is undefined or null\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resource\", name, \"Properties\"], []),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resources),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nactionKeys := {\"Action\", \"Actions\"}\nallKMSActions := {\"*\", \"kms:*\", \"kms*\"}\n\nactionContainsAllKMSActions(statement) {\n\tcommon_lib.equalsOrInArray(statement[actionKeys[_]], allKMSActions[_])\n}\n\nWizPolicy[result] {\n\tresourceType := {\"aws_kms_key\", \"aws_kms_key_policy\"}\n    document := input.document[i]\n\tresource := document.resource[resourceType[idx]][name]\n\n\tpolicy := common_lib.json_unmarshal(resource.policy)\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tactionContainsAllKMSActions(statement)\n\tcommon_lib.is_allow_effect(statement)\n    not common_lib.valid_key(statement, \"Condition\")\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": resourceType[idx],\n\t\t\"searchKey\": sprintf(\"%s[%s].policy\", [resourceType[idx], name]),\n\t\t\"keyExpectedValue\": sprintf(\"%s[%s].policy should not allow all KMS actions without conditions.\", [resourceType[idx], name]),\n\t\t\"keyActualValue\": sprintf(\"%s[%s].policy allows all KMS actions without a condition.\", [resourceType[idx], name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", resourceType[idx], name, \"policy\", \"Statement\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t\t}\n}\n"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-exp-8-r4-5" {
  description              = "This rule checks whether the S3 Bucket is not encrypted with a customer-managed key.  \nThis rule fails if `KMSMasterKeyID` is `null`.  \nWhen you use server-side encryption with AWS KMS (SSE-KMS), you should use the customer-managed key. \nAWS KMS supports envelope encryption. S3 uses the AWS KMS features for envelope encryption to further protect your data. Envelope encryption is the practice of encrypting your plaintext data with a data key, and then encrypting that data key with a KMS key.  \nIf you don't specify a customer-managed key, Amazon S3 automatically creates an AWS-managed key in your AWS account the first time that you add an object encrypted with SSE-KMS to a bucket. By default, S3 uses this KMS key for SSE-KMS. To use a customer-managed key for SSE-KMS, create a symmetric encryption customer-managed key before you configure SSE-KMS. Then, when you configure SSE-KMS for your bucket, specify the existing customer-managed key.\n>**Note**  \nSome S3 buckets must use Amazon S3-managed keys (SSE-S3) to use AWS features. This CCR does not skip such resources in order to provide full visibility for compliance checks. For example, [ALB access logs](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/enable-access-logging.html#access-log-create-bucket) can only be stored in a bucket with SSE-S3 encryption. If you wish, you can create Ignore Rules, or use the Security Graph to filter out such buckets, see [this graph query](https://app.wiz.io/explorer/graph#%7E%28queryTitle%7E%27Findings*20for*20S3*20Bucket*20should*20be*20encrypted*20with*20KMS*20*28SSE-KMS*29%7Equery%7E%28type%7E%28%7E%27BUCKET%29%7Eselect%7Etrue%7Erelationships%7E%28%7E%28type%7E%28%7E%28type%7E%27ALERTED_ON%7Ereverse%7Etrue%29%29%7Ewith%7E%28type%7E%28%7E%27CONFIGURATION_FINDING%29%7Ewhere%7E%28configurationRuleShortName%7E%28EQUALS%7E%27S3-010%29%29%7Eselect%7Etrue%29%29%7E%28optional%7Etrue%7Etype%7E%28%7E%28type%7E%27CONTAINS%7Ereverse%7Etrue%29%29%7Ewith%7E%28type%7E%28%7E%27SUBSCRIPTION%29%7Eselect%7Etrue%29%29%7E%28type%7E%28%7E%28type%7E%27STORES_DATA_IN%7Ereverse%7Etrue%29%29%7Enegate%7Etrue%7Ewith%7E%28type%7E%28%7E%27LOAD_BALANCER%29%7Ewhere%7E%28nativeType%7E%28EQUALS%7E%28%7E%27loadBalancerv2*2fapplication%29%29%29%29%29%29%29%7Eview%7E%27table%29) for example.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "S3 Bucket should be encrypted with a customer-managed key"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\ncustomerKMSEncryptionEnabled {\n\tKMSMasterKeyID := object.get(input.bucketEncryptionConfiguration.ServerSideEncryptionConfiguration.Rules[_].ApplyServerSideEncryptionByDefault,\"KMSMasterKeyID\", null)\n    not is_null(KMSMasterKeyID)\n}\n\nresult = \"skip\" {\n\tnot input.WizMetadata.objectFetchStatus.bucketEncryptionConfiguration.result == \"Success\"\n} else = \"fail\" {\n\tnot customerKMSEncryptionEnabled\n}\n\ncurrentConfiguration := sprintf(\"KMS encryption is disabled\", [])\nexpectedConfiguration := sprintf(\"KMS encryption should be enabled\", [])"
  remediation_instructions = "Perform the following command to configure default bucket encryption with SSE-KMS using an S3 Bucket Key via AWS CLI:  \n```  \naws s3api put-bucket-encryption --bucket {{bucketName}} --server-side-encryption-configuration '{  \n    \"Rules\": [  \n            {  \n                \"ApplyServerSideEncryptionByDefault\": {  \n                    \"SSEAlgorithm\": \"aws:kms\",  \n                    \"KMSMasterKeyID\": \"<kmsKeyArn>\"  \n                },  \n                \"BucketKeyEnabled\": true  \n            }  \n        ]  \n    }'  \n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["bucket"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as commonLib\n\n# This rule will pass if at least the 'aws_s3_bucket' or\n# its association configuration resource are properly configured.\n\nbucketWithKmsMasterKey(resource) {\n\trules := terraLib.getArray(resource.rule)\n\tapplyServerSideEncryptionByDefault := terraLib.getValueArrayOrObject(rules[_].apply_server_side_encryption_by_default)\n\tcommonLib.valid_key(applyServerSideEncryptionByDefault, \"kms_master_key_id\")\n\tapplyServerSideEncryptionByDefault.kms_master_key_id != \"\"\n}\n\nbucketEncryptedWithCustomerProvidedCmks(bucket, bucketName, document) {\n\t# TF version 3\n\tserverSideEncryptionConfiguration := terraLib.getValueArrayOrObject(bucket.server_side_encryption_configuration)\n\tbucketWithKmsMasterKey(serverSideEncryptionConfiguration)\n}{\n\t# TF version 4\n\tsseConfigResource := document.resource.aws_s3_bucket_server_side_encryption_configuration[sseConfigName]\n\tterraLib.associatedResources(bucket, sseConfigResource, bucketName, sseConfigName, \"bucket\", \"bucket\")\n\tbucketWithKmsMasterKey(sseConfigResource)\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tbucket := document.resource.aws_s3_bucket[bucketName]\n\n\tnot bucketEncryptedWithCustomerProvidedCmks(bucket, bucketName, document)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": terraLib.get_resource_name(bucket, bucketName),\n\t\t\"resourceType\": \"aws_s3_bucket\",\n\t\t\"searchKey\": sprintf(\"aws_s3_bucket[%s]\", [bucketName]),\n\t\t\"keyExpectedValue\": sprintf(\"'aws_s3_bucket[%s]' should be encrypted using a customer-provided key\", [bucketName]),\n\t\t\"keyActualValue\": sprintf(\"'aws_s3_bucket[%s]' is not encrypted using a customer-provided key\", [bucketName]),\n\t\t\"resourceTags\": object.get(bucket, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_s3_bucket](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket), [aws_s3_bucket_server_side_encryption_configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket_server_side_encryption_configuration)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-7-4" {
  description              = "This rule checks whether GuardDuty ECS Fargate Agent Management is enabled.  \nThis rule fails if the `ECS_FARGATE_AGENT_MANAGEMENT` under the `RUNTIME_MONITORING` configuration is set to `DISABLED`.  \nGuardDuty ECS Fargate Agent Management is a feature that enhances the security of Amazon ECS Fargate tasks by monitoring runtime behavior. When enabled, it helps detect potential security threats and malicious activities within Fargate containers. This feature provides an additional layer of security for containerized applications running on AWS Fargate.  \nIt is recommended to enable GuardDuty ECS Fargate Agent Management to improve the security posture of your ECS Fargate deployments and to gain better visibility into potential security issues at runtime.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty ECS Fargate Agent Management should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"ECS_FARGATE_AGENT_MANAGEMENT\"\n\nfeatureDisabled {\n\tfeature := input.Features[_]\n\tupper(feature.Name) == \"RUNTIME_MONITORING\"\n\tadditionalFeature := feature.AdditionalConfiguration[_]\n\tupper(additionalFeature.Name) == protection\n\tupper(additionalFeature.Status) == \"DISABLED\"\n}\n\nresult = \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])"
  remediation_instructions = "Perform the following command to enable GuardDuty ECS Fargate Agent Management via AWS CLI:\n\n```\naws guardduty update-detector \\\n    --detector-id {{detectorId}} \\\n    --features '[{\"Name\": \"RUNTIME_MONITORING\", \"Status\": \"ENABLED\", \"AdditionalConfiguration\": [{\"Name\": \"ECS_FARGATE_AGENT_MANAGEMENT\", \"Status\": \"ENABLED\"}]}]' \\\n    --region {{region}}\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tfeatures := terraLib.getValueArrayOrObject(resource.features)\n\n\tnot common_lib.valid_key(features, \"runtime_monitoring\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s].features\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].features.runtime_monitoring should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].features.runtime_monitoring is undefined\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name, \"features\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tfeatures := terraLib.getValueArrayOrObject(resource.features)\n\truntime_monitoring := terraLib.getValueArrayOrObject(features.runtime_monitoring)\n\n\tnot common_lib.valid_key(runtime_monitoring, \"ecs_fargate\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s].features.runtime_monitoring\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].features.runtime_monitoring.ecs_fargate should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].features.runtime_monitoring.ecs_fargate is undefined\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name, \"features\", \"runtime_monitoring\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tfeatures := terraLib.getValueArrayOrObject(resource.features)\n\truntime_monitoring := terraLib.getValueArrayOrObject(features.runtime_monitoring)\n\tecs_fargate := terraLib.getValueArrayOrObject(runtime_monitoring.ecs_fargate)\n\n\tecs_fargate.status == \"DISABLED\"\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s].features.runtime_monitoring.ecs_fargate.status\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].features.runtime_monitoring.ecs_fargate.status should be set to 'ENABLED'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].features.runtime_monitoring.ecs_fargate.status is set to 'DISABLED'\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name, \"features\", \"runtime_monitoring\", \"ecs_fargate\", \"status\"], []),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"DISABLED\",\n\t\t\t\"after\": \"ENABLED\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "resource \"aws_guardduty_detector\" \"example_detector\" {\n  features {\n    runtime_monitoring {\n      ecs_fargate {\n        status = \"ENABLED\"\n      }\n    }\n  }\n}"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-10-8" {
  description              = "This rule checks whether the customer-managed KMS key has automatic key rotation enabled.  \nThis rule fails when the `RotationStatus.KeyRotationEnabled` field is not null or set to `true` for active keys.  \nAWS Key Management Service (KMS) allows customers to automatically rotate the backing key every year (approximately 365 days). Key rotation changes only the key material, which is the cryptographic secret that is used in encryption operations. The KMS key is the same logical resource, regardless of whether or how many times its key material changes.  \nKMS ensures data protection and allows you to gain more control for access to the data that you encrypt and assures the durability of the keys.  \nIt is recommended to enable automatic key rotation on the customer-managed KMS Key to reduce the potential impact of a compromised key.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "KMS key automatic rotation should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nrotationEnabled {\n\tinput.keyRotationStatus.KeyRotationEnabled == true\n} {\n\tinput.keyRotationStatus.KeyRotationEnabled == null\n}\n\nsymmetricEnabledCMK {\n\tupper(input.EncryptionAlgorithms[_]) == \"SYMMETRIC_DEFAULT\"\n    input.Enabled\n    not upper(input.KeyManager) == \"AWS\"\n}\n\nresult = \"skip\" {\n\tnot input.keyRotationStatus\n} else = \"skip\" {\n\tnot symmetricEnabledCMK\n} else = \"skip\" {\n\tlower(input.KeyState) == \"pendingdeletion\"\n} else = \"fail\" {\n\tnot rotationEnabled\n}\n"
  remediation_instructions = "Perform the following command in order to enable KMS encryption key rotation via AWS CLI:  \n```  \naws kms enable-key-rotation \\\n\t--key-id {{keyID}}  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["encryptionKey"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ansLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tkms := task[\"community.aws.aws_kms\"]\n\tansLib.checkState(kms)\n\n\tkms.enabled == true\n\tnot common_lib.valid_key(kms, \"pending_window\")\n\tnot common_lib.valid_key(kms, \"enable_key_rotation\")\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{community.aws.aws_kms}}\", [task.name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"community.aws.aws_kms.enable_key_rotation should be set\",\n\t\t\"keyActualValue\": \"community.aws.aws_kms.enable_key_rotation is undefined\",\n\t\t\"resourceTags\": object.get(kms, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tkms := task[\"community.aws.aws_kms\"]\n\tansLib.checkState(kms)\n\n\tkms.enabled == true\n\tnot common_lib.valid_key(kms, \"pending_window\")\n\tkms.enable_key_rotation == false\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{community.aws.aws_kms}}.enable_key_rotation\", [task.name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"community.aws.aws_kms.enable_key_rotation should be set to true\",\n\t\t\"keyActualValue\": \"community.aws.aws_kms.enable_key_rotation is set to false\",\n\t\t\"resourceTags\": object.get(kms, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresources := input.document[i].Resources[name]\n\tresources.Type == \"AWS::KMS::Key\"\n\tkeyRotation := resources.Properties.EnableKeyRotation\n\tkeyRotation == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resources, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.EnableKeyRotation\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.EnableKeyRotation should not be 'true'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.EnableKeyRotation is true\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resources),\n\t}\n}\n\nWizPolicy[result] {\n\tresources := input.document[i].Resources[name]\n\tresources.Type == \"AWS::KMS::Key\"\n\tproperties := resources.Properties\n\tnot common_lib.valid_key(properties, \"EnableKeyRotation\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resources, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.EnableKeyRotation\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.EnableKeyRotation should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.EnableKeyRotation is undefined\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resources),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_kms_key[name]\n\tnot common_lib.valid_key(resource, \"enable_key_rotation\")\n\tcustomer_master_key_spec_set_to_symmetric(resource)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_kms_key\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_kms_key[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_kms_key[%s].enable_key_rotation should be set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_kms_key[%s].enable_key_rotation is undefined\", [name]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_kms_key[name]\n\tresource.enable_key_rotation == false\n\tcustomer_master_key_spec_set_to_symmetric(resource)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_kms_key\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_kms_key[%s]\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_kms_key[%s].enable_key_rotation should be set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_kms_key[%s].enable_key_rotation is false\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\ncustomer_master_key_spec_set_to_symmetric(resource) {\n\t resource.customer_master_key_spec == \"SYMMETRIC_DEFAULT\"\n} else {\n\t not common_lib.valid_key(resource, \"customer_master_key_spec\")\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_kms_key](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/kms_key)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-4-5" {
  description              = "This rule checks whether the IAM customer-managed and inline policies allow full administrative privileges.  \nThis rule fails if the policy statement contains `Effect: Allow`, and the `Action` and `Resource` fields are set to a wildcard `*`.  \nWhen a user is given full access, they are effectively given full access to all resources in the AWS account.  \nIt is recommended that the IAM policy should follow the principle of least privilege (PoLP) and should only include the required permissions.\n>**Note**  \nThis rule will evaluate only AWS-managed policies that are imported as an inline policy, such as `AdministratorAccess`, as they are permissive and are attached to a user. This rule will not evaluate and trigger on the default read-only AWS-managed IAM policies.  \nIf you want to change the Native Types of this rule, you can [duplicate the rule](https://docs.wiz.io/wiz-docs/docs/cloud-configuration-rules#duplicate-a-built-in-cloud-configuration-rule) and configure it as required."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM policy should not have full administrative access"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nhasWildcardValue(values) {\n\tvalues[_] == \"*\"\n} {\n\tvalues == \"*\"\n}\n\nresult = \"skip\" {\n\tnot input.Statement\n} else = \"fail\" {\n\tstatement := input.Statement[_]\n    lower(statement.Effect) == \"allow\"\n    hasWildcardValue(statement.Action)\n    hasWildcardValue(statement.Resource)\n}\n\ncurrentConfiguration := \"The policy allows all actions over all resources\"\nexpectedConfiguration := \"The policy should restrict permissions\""
  remediation_instructions = "Perform the following commands to delete or modify the IAM policy via AWS CLI:    \n1. First, use the following command to list the IAM entities (Users\\Roles\\Groups) that have the policy attached (if any):  \n```  \naws iam list-entities-for-policy \\\n    --policy-arn <value>  \n```  \n* If the policy **is not attached** to IAM entities - proceed to 2a.    \n* If the policy **is attached** to one or more IAM entities - proceed to 2b.    \n  \n2a. As this policy is not in use, It is recommended to delete it. Use the following command to delete the policy:  \n```  \naws iam delete-policy \\\n    --policy-arn <value>  \n```  \n2b. It is recommended to edit the policy and remove the permissive statement.    \nFirst, use the following command to view the policy and locate the overly-permissive statement/s.    \n**Note:** You can also view the policy in the native object JSON in Wiz.  \n```  \naws iam get-policy \\\n    --policy-arn <value> \\\n    --version-id <value>  \n```  \nIf you are not sure what the policy version id is, use the following command to check. It is the 'DefaultVersionId' in the output:  \n```  \naws iam get-policy-version \\\n    --policy-arn <value>  \n```  \nNext, create a new policy in a JSON file locally which replaces the wildcards `*` with the required actions and resources only.    \nUse the following command to create a new policy version with the new policy created and set it to default:  \n```  \naws iam create-policy-version \\\n    --policy-arn <value> \\\n    --policy-document file://<NewPolicyVersion.json> \\\n    --set-as-default  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["customerManagedPolicy", "inlinePolicy"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n    # Check AWS::IAM::Policy resources\n    resource := input.document[i].Resources[name]\n    lower(resource.Type) == \"aws::iam::policy\"\n\n    common_lib.valid_key(resource.Properties, \"PolicyDocument\")\n    policy_document := resource.Properties.PolicyDocument\n    has_admin_privileges(policy_document)\n    \n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": \"AWS::IAM::Policy\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.PolicyDocument\", [name]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"Resources.%s.Properties.PolicyDocument should not allow full \\\"*\\\" administrative privileges\", [name]),\n        \"keyActualValue\": sprintf(\"Resources.%s.Properties.PolicyDocument allows full \\\"*\\\" administrative privileges\", [name]),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}\n\nWizPolicy[result] {\n    # Check AWS::IAM::User resources with inline policies\n    resource := input.document[i].Resources[name]\n    resource_types := [\"AWS::IAM::Group\", \"AWS::IAM::Role\", \"AWS::IAM::User\"]\n    lower(resource.Type) == lower(resource_types[_])\n\n    common_lib.valid_key(resource.Properties, \"Policies\")\n    count(resource.Properties.Policies) > 0\n    policy := resource.Properties.Policies[idx]\n    common_lib.valid_key(policy, \"PolicyDocument\")\n    policy_document := policy.PolicyDocument\n    has_admin_privileges(policy_document)\n    \n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": resource.Type,\n        \"searchKey\": sprintf(\"Resources.%s.Properties.Policies[%d].PolicyDocument\", [name, idx]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"Resources.%s.Properties.Policies[%d].PolicyDocument should not allow full \\\"*\\\" administrative privileges\", [name, idx]),\n        \"keyActualValue\": sprintf(\"Resources.%s.Properties.Policies[%d].PolicyDocument allows full \\\"*\\\" administrative privileges\", [name, idx]),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}\n\n# Helper function to check if a policy document has admin privileges\nhas_admin_privileges(policy_document) {\n    statements := common_lib.get_statement(policy_document)\n    statement := statements[_]\n    \n    # Check if Effect is Allow (default is Allow if not specified)\n    not common_lib.valid_key(statement, \"Effect\")\n    \n    # Check if Action is \"*\" (wildcard for all actions)\n    action_has_wildcard(statement)\n    \n    # Check if Resource is \"*\" (wildcard for all resources)\n    resource_has_wildcard(statement)\n}{\n    statements := common_lib.get_statement(policy_document)\n    statement := statements[_]\n    \n    # Check if Effect is Allow explicitly\n    lower(statement.Effect) == \"allow\"\n\n    # Check if Action is \"*\" (wildcard for all actions)\n    action_has_wildcard(statement)\n    \n    # Check if Resource is \"*\" (wildcard for all resources)\n    resource_has_wildcard(statement)\n}\n\n# Check if action contains wildcard\naction_has_wildcard(statement) {\n    common_lib.valid_key(statement, \"Action\")\n    is_string(statement.Action)\n    statement.Action == \"*\"\n}{\n    common_lib.valid_key(statement, \"Action\")\n    is_array(statement.Action)\n    statement.Action[_] == \"*\"\n}\n\n# Check if resource contains wildcard\nresource_has_wildcard(statement) {\n    common_lib.valid_key(statement, \"Resource\")\n    is_string(statement.Resource)\n    statement.Resource == \"*\"\n}{\n    common_lib.valid_key(statement, \"Resource\")\n    is_array(statement.Resource)\n    statement.Resource[_] == \"*\"\n}"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as tf_lib\n\nWizPolicy[result] {\n\tresourceType := {\"aws_iam_role_policy\", \"aws_iam_user_policy\", \"aws_iam_group_policy\", \"aws_iam_policy\"}\n\tresource := input.document[i].resource[resourceType[idx]][name]\n\n\tpolicy := common_lib.json_unmarshal(resource.policy)\n\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.equalsOrInArray(statement.Resource, \"*\")\n\tcommon_lib.equalsOrInArray(statement.Action, \"*\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": resourceType[idx],\n\t\t\"resourceName\": tf_lib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s[%s].policy\", [resourceType[idx], name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'policy.Statement.Action' shouldn't contain '*'\",\n\t\t\"keyActualValue\": \"'policy.Statement.Action' contains '*'\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", resourceType[idx], name, \"policy\"], []),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].data.aws_iam_policy_document[name]\n\n    policy := {\"Statement\": resource.statement}\n\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.equalsOrInArray(statement.resources, \"*\")\n\tcommon_lib.equalsOrInArray(statement.actions, \"*\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_policy_document\",\n\t\t\"resourceName\": tf_lib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_policy_document[%s].policy\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'policy.Statement.actions' shouldn't contain '*'\",\n\t\t\"keyActualValue\": \"'policy.Statement.actions' contains '*'\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_policy_document\", name, \"policy\"], []),\n\t}\n}"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "mp-com-1-2" {
  description              = "This rule checks whether EC2 Security Group allows unrestricted inbound traffic from the internet.  \nThis rule fails if the Security Group contains a rule that allows inbound traffic from all IPv4 (`0.0.0.0/0`) or IPv6 (`::/0`) CIDR ranges.  \nIt is recommended to restrict the inbound traffic by limiting the IP addresses allowed access to the required addresses only.\n>**Note**  \n>* If you require the Security Group to provide access from all IP addresses *excluding HTTP/S* - see Cloud Configuration Rule `VPC-077`.\n>* This rule does not take into account the port and protocol configuration of the Security Group rules, only the source IP address. There are other rules available that check for unrestricted access over specific ports.\n>* See Cloud Configuration Rule `VPC-056` for *outbound* traffic allowed to all IP addresses.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "EC2 Security Group should not allow access from all IP addresses"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nallIps := {\"0.0.0.0/0\", \"::/0\"}\n\nunrestrictedSourceIPs(rule) {\n\tallIps[rule.IpRanges[_].CidrIp]\n}{\n\tallIps[rule.Ipv6Ranges[_].CidrIpv6]\n}\n\nresult = \"fail\" {\n\trule := input.IpPermissions[permission]\n\tunrestrictedSourceIPs(rule)\n}\n\ncurrentConfiguration := \"Security Group allows unrestricted inbound traffic from the internet\"\nexpectedConfiguration := \"Security Group should restrict inbound traffic from the internet\"\n"
  remediation_instructions = "Perform the following commands to modify or delete the Security Group rule via AWS CLI:\n\nUse the following command to modify the non-compliant rule(s):\n```\naws ec2 modify-security-group-rules \\\n\t--group-id {{groupId}} \\\n\t--security-group-rules SecurityGroupRuleId=<SecurityGroupRuleId>,SecurityGroupRule=\"{FromPort=<FromPort>,ToPort=<ToPort>,IpProtocol=<IpProtocol>,CidrIpv4=<CidrIp>}\"  \n```\n\nAlternatively, use the following command to delete the non-compliant rule(s):\n```\naws ec2 revoke-security-group-ingress \\\n\t--group-id {{groupId}} \\\n\t--security-group-rule-ids <value>\n```\n>**Note**  \n>You can find your rule ID on the Security Group page in the AWS Console or by using the command `describe-security-group-rules` on the AWS CLI."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["securityGroup"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ansLib\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tmodules := {\"amazon.aws.ec2_group\", \"ec2_group\"}\n\tgroup := task[modules[m]]\n\tansLib.checkState(group)\n\n\tsearchKey := getCidrBlock(group)\n\n\tsplitted := regex.split(\"{{|}}\", searchKey)\n\terrorPath := substring(splitted[0], 0, count(splitted[0]) - 1)\n\terrorValue := splitted[1]\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}.%s\", [task.name, modules[m], searchKey]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"ec2_group.%s should not contain the value '%s'\", [errorPath, errorValue]),\n\t\t\"keyActualValue\": sprintf(\"ec2_group.%s contains value '%s'\", [errorPath, errorValue]),\n\t\t\"resourceTags\": object.get(group, \"tags\", {}),\n\t}\n}\n\ngetCidrBlock(sg) = path {\n\thasDefinedPorts(sg.rules[r])\n\tisUnsafeIp(sg.rules[r].cidr_ip)\n\tpath := \"rules.cidr_ip={{0.0.0.0/0}}\"\n} else = path {\n\thasDefinedPorts(sg.rules[r])\n\tisUnsafeIp(sg.rules[r].cidr_ip[c])\n\tpath := \"rules.cidr_ip.{{0.0.0.0/0}}\"\n} else = path {\n\thasDefinedPorts(sg.rules[r])\n\tisUnsafeIpv6(sg.rules[r].cidr_ipv6)\n\tpath := \"rules.cidr_ipv6={{::/0}}\"\n} else = path {\n\thasDefinedPorts(sg.rules[r])\n\tisUnsafeIpv6(sg.rules[r].cidr_ipv6[c])\n\tpath := \"rules.cidr_ipv6.{{::/0}}\"\n}\n\nhasDefinedPorts(rule) {\n\trule.from_port\n\trule.to_port\n} else {\n\trule.ports\n}\n\nisUnsafeIp(\"0.0.0.0/0\") = true\n\nisUnsafeIpv6(\"::/0\") = true\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::EC2::SecurityGroupIngress\"\n\n\tproperties := resource.Properties\n\n\tproperties.CidrIp == \"0.0.0.0/0\"\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.CidrIp\", [cloudFormationLib.getPath(path),name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.CidrIp should not be open to the world (0.0.0.0/0)\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.CidrIp is open to the world (0.0.0.0/0)\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::EC2::SecurityGroupIngress\"\n\n\tproperties := resource.Properties\n\n\tproperties.CidrIpv6 == \"::/0\"\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.CidrIpv6\", [cloudFormationLib.getPath(path),name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.CidrIpv6 should not be open to the world (::/0)\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.CidrIpv6 is open to the world (::/0)\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::EC2::SecurityGroup\"\n\n\tproperties := resource.Properties\n\n\tproperties.SecurityGroupIngress[index].CidrIp == \"0.0.0.0/0\"\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.SecurityGroupIngress\", [cloudFormationLib.getPath(path),name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resources\", name, \"Properties\", \"SecurityGroupIngress\", index, \"CidrIp\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.SecurityGroupIngress[%d].CidrIp should not be open to the world (0.0.0.0/0)\", [name, index]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.SecurityGroupIngress[%d].CidrIp is open to the world (0.0.0.0/0)\", [name, index]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::EC2::SecurityGroup\"\n\n\tproperties := resource.Properties\n\n\tproperties.SecurityGroupIngress[index].CidrIpv6 == \"::/0\"\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.SecurityGroupIngress[%d].CidrIpv6\", [cloudFormationLib.getPath(path),name, index]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resources\", name, \"Properties\", \"SecurityGroupIngress\", index, \"CidrIpv6\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.SecurityGroupIngress[%d].CidrIpv6 should not be open to the world (::/0)\", [name, index]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.SecurityGroupIngress[%d].CidrIpv6 is open to the world (::/0)\", [name, index]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport future.keywords.in\nimport data.generic.common as commonLib\nimport data.generic.terraform as terraLib\n\ntraffic := \"ingress\"\n\ncheckRulesArrayOrObject(rules) {\n\tis_object(rules)\n\tterraLib.cidrAllIpAddresses(rules)\n}{\n\tis_array(rules)\n\trule := rules[r]\n\tterraLib.cidrAllIpAddresses(rule)\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_security_group[name]\n\n\tcheckRulesArrayOrObject(resource[traffic])\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"aws_security_group\",\n\t\t\"searchKey\": sprintf(\"aws_security_group[%s].%s\", [name, traffic]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyActualValue\": sprintf(\"aws_security_group[%s] %s rule allows all IP addresses ('0.0.0.0/0', '::/0')\", [name, traffic]),\n\t\t\"keyExpectedValue\": \"Security Group inbound rule should restrict the IP addresses range\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[j].resource.aws_security_group[name]\n\trule := input.document[i].resource.aws_security_group_rule[ruleName]\n\t\n\tterraLib.associatedResources(resource, rule, name, ruleName, \"name\", \"security_group_id\")\n    \n\tlower(rule.type) == traffic\n\tcheckRulesArrayOrObject(rule)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"aws_security_group\",\n\t\t\"searchKey\": sprintf(\"aws_security_group_rule[%s]\", [ruleName]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyActualValue\": sprintf(\"aws_security_group_rule[%s] allows all IP addresses ('0.0.0.0/0', '::/0')\", [ruleName]),\n\t\t\"keyExpectedValue\": \"Security Group inbound rule should restrict the IP addresses range\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[j].resource.aws_security_group[name]\n\trule := input.document[i].resource.aws_vpc_security_group_ingress_rule[ruleName]\n\t\n\tterraLib.associatedResources(resource, rule, name, ruleName, \"name\", \"security_group_id\")\n\n\tcheckRulesArrayOrObject(rule)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"aws_security_group\",\n\t\t\"searchKey\": sprintf(\"aws_vpc_security_group_ingress_rule[%s]\", [ruleName]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyActualValue\": sprintf(\"aws_vpc_security_group_ingress_rule[%s] allows all IP addresses ('0.0.0.0/0', '::/0')\", [name]),\n\t\t\"keyExpectedValue\": \"Security Group inbound rule should restrict the IP addresses range\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_security_group](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/security_group), [aws_security_group_rule](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/security_group_rule), [aws_vpc_security_group_ingress_rule](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc_security_group_ingress_rule)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-8-3" {
  description              = "Ensure your AWS CloudTrail trails have log file integrity validation enabled."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail log file validation should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tinput.LogFileValidationEnabled == false\n}\n\ncurrentConfiguration := \"'LogFileValidationEnabled' is set to 'false'\"\nexpectedConfiguration := \"Log file validation should be enabled\""
  remediation_instructions = "Perform the following to enable log file validation on a given trail:  \n1. Sign in to the AWS Management Console and open the IAM console at <https://console.aws.amazon.com/cloudtrail>  \n2. Click on Trails in the left navigation pane  \n3. Click on the target trail  \n4. Within the S3 section, click on the edit icon (pencil)  \n5. Click Advanced  \n6. Click on the Yes radio button in the section Enable log file validation  \n7. Click Save"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tnot common_lib.valid_key(resource.Properties, \"EnableLogFileValidation\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.EnableLogFileValidation' should exist\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.EnableLogFileValidation' is missing\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tresource.Properties.EnableLogFileValidation == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.EnableLogFileValidation\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.EnableLogFileValidation' should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.EnableLogFileValidation' is not true\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudtrail[name]\n\tresource.enable_log_file_validation == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].enable_log_file_validation\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_cloudtrail\", name, \"enable_log_file_validation\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].enable_log_file_validation' should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].enable_log_file_validation' is false\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudtrail[name]\n\tnot common_lib.valid_key(resource, \"enable_log_file_validation\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_cloudtrail\", name], []),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].enable_log_file_validation' should be set\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].enable_log_file_validation' is undefined\", [name]),\n\t\t\"remediation\": \"enable_log_file_validation = true\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudtrail](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudtrail)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-4-2" {
  description              = "This rule checks whether the IAM policy allows performing the sensitive IAM action `GetAccountAuthorizationDetails`.  \nThis rule fails if at least one statement that matches the following criteria is found in a customer-managed or inline policy:\n* `Action` contains `iam:GetAccountAuthorizationDetails`, or a wildcard that contains the action\n* `Effect` is `Allow`\n* `Resource` is `*`\n\nUsers/Roles/Groups that have this policy attached can retrieve sensitive information about your IAM constructs in an account and map all relationships between them. This action can be abused by malicious actors for reconnaissance of your entire AWS account permissions and might lead to privilege escalation or even to taking over the entire account.  \nIt is recommended to follow the least-privilege principle (POLP) and restrict the IAM policy to only include the minimum required permissions."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM policy should not allow action that retrieves all IAM information"
  opa_policy               = "package wiz\n\nimport future.keywords.in\n\ndefault result = \"pass\"\n\nactionsThatContainGetAccountAuthorizationDetails := {\"iam:getaccountauthorizationdetails\", \"iam:get*\", \"iam:*\", \"*\"}\n\ngetAccountAuthorizationDetailsAction(statement) {\n\tlower(statement.Action[_]) in actionsThatContainGetAccountAuthorizationDetails\n}{\n\tlower(statement.Action) in actionsThatContainGetAccountAuthorizationDetails\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nwildcardResource(statement) {\n\tstatement.Resource[_] == \"*\"\n}{\n\tstatement.Resource == \"*\"\n}\n\ndenyStatement[statement] {\n\tstatement := input.Statement[s]\n\tlower(statement.Action) in actionsThatContainGetAccountAuthorizationDetails\n\tlower(statement.Effect) == \"deny\"\n}{\n\tstatement := input.Statement[s]\n\tlower(statement.Action[_]) in actionsThatContainGetAccountAuthorizationDetails\n\tlower(statement.Effect) == \"deny\"\n}\n\nstatementAllowingGetAccountAuthorizationDetails[statement] {\n\tstatement := input.Statement[s]\n\tgetAccountAuthorizationDetailsAction(statement)\n\teffectAllow(statement)\n\twildcardResource(statement)\n}\n\nresult = \"fail\" {\t\n    count(statementAllowingGetAccountAuthorizationDetails) > 0\n    count(denyStatement) == 0\n}\n\ncurrentConfiguration := \"The policy allows the action 'iam:GetAccountAuthorizationDetails' for all resources\"\nexpectedConfiguration := \"The policy should not allow the action 'iam:GetAccountAuthorizationDetails' for all resources\"\n"
  remediation_instructions = "Perform the following commands to delete or modify the IAM policy via AWS CLI:    \n1. First, use the following command to list the IAM entities (User\\Role\\Group) that have the policy attached (if any):  \n```  \naws iam list-entities-for-policy \\\n    --policy-arn <value>  \n```  \nIf the policy **is not attached** to IAM entities - proceed to 2a.    \nIf the policy **is attached** to one or more IAM entities - proceed to 2b.    \n2a. As this policy is not in use, It is recommended to delete it. Use the following command to delete the policy:  \n```  \naws iam delete-policy \\\n    --policy-arn <value>  \n```  \n2b. It is recommended to edit the policy to remove the permissive action. First, use the following command to view the actions of the policy:  \n```  \naws iam get-policy-version \\\n    --policy-arn <value> \\\n    --version-id <value>  \n```  \nIf you are not sure what the policy version id is, use the following command to check. It is the 'DefaultVersionId':  \n```  \naws iam get-policy \\\n    --policy-arn <value>  \n```  \nOnce you have located the overly-permissive action(s), create a new JSON file that excludes the permissive actions. Use the following command to create a new policy version and set it to default:  \n```  \naws iam create-policy-version \\\n    --policy-arn <value> \\\n    --policy-document file://<NewPolicyVersion.json> \\\n    --set-as-default  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["customerManagedPolicy", "inlinePolicy"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresourceType := {\"aws_iam_role_policy\", \"aws_iam_user_policy\", \"aws_iam_group_policy\", \"aws_iam_policy\"}\n\tresource := input.document[i].resource[resourceType[idx]][name]\n\n\tpolicy := common_lib.json_unmarshal(resource.policy)\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n    \n\tresourceWildcardAndActionContainsGetAccountAuthorizationDetails(statement)\n\tcommon_lib.is_allow_effect(statement)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": resourceType[idx],\n\t\t\"searchKey\": sprintf(\"%s[%s].policy\", [resourceType[idx], name]),\n\t\t\"keyExpectedValue\": \"'policy.Statement' should not allow 'iam:GetAccountAuthorizationDetails' for all resources.\",\n\t\t\"keyActualValue\": \"'policy.Statement' allows 'iam:GetAccountAuthorizationDetails' (or a wildcard allowing it) for all resources.\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", resourceType[idx], name, \"policy\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nactionKeys := {\"Action\", \"Actions\"}\nresourceKeys := {\"Resource\", \"Resources\"}\nactionsThatContainGetAccountAuthorizationDetails := {\"iam:getaccountauthorizationdetails\", \"iam:get*\", \"iam:*\", \"*\"}\n\nresourceWildcardAndActionContainsGetAccountAuthorizationDetails(statement) {\n\tcommon_lib.equalsOrInArray(statement[resourceKeys[_]], \"*\")\n\tcommon_lib.equalsOrInArray(statement[actionKeys[_]], actionsThatContainGetAccountAuthorizationDetails[_])\n}"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-4-3" {
  description              = "This rule checks whether the IAM policy allows assume role permission across all services.  \nThis rule fails if the policy contains at least one `Statement` that includes:\n* `Effect` is set to `Allow`\n* `Action` contains `sts:AssumeRole` or a wildcard containing the action (`*` or `sts:*`)\n* `Resource` is set to a wildcard (`*`)\n* `Condition` is `null` or does not exist\n\nTypically, AssumeRole is used if you have multiple accounts and need to access resources from each account.  \nIt is bad practice to allow the IAM policy the assume role permission across all services, especially without any conditions.  \nIt is recommended to follow the principle of least privilege (PoLP) by restricting the IAM policy to the required services."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM policy should not allow assume role permission across all services"
  opa_policy               = "package wiz\n\nimport future.keywords.in\n\ndefault result = \"pass\"\n\nactionsContainingStsAssumeRole := {\"*\", \"sts:*\", \"sts:assumerole\"}\n\nstsAssumeRoleAction(statement) {\n\tlower(statement.Action[_]) in actionsContainingStsAssumeRole\n}{\n\tlower(statement.Action) in actionsContainingStsAssumeRole\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nwildcardResource(statement) {\n\tstatement.Resource[_] == \"*\"\n}{\n\tstatement.Resource == \"*\"\n}{\n\tendswith(statement.Resource[_], \":*\")\n}{\n\tendswith(statement.Resource, \":*\")\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\nstatementAllowingSnsAssumeRoleForAllResources[statement] {\n\tstatement := input.Statement[s]\n\tstsAssumeRoleAction(statement)\n\teffectAllow(statement)\n\twildcardResource(statement)\n\tnullCondition(statement)\n}\n\nresult = \"fail\" { \n\tcount(statementAllowingSnsAssumeRoleForAllResources) > 0\n}\n\ncurrentConfiguration := \"The policy allows assume role permission across all services\"\nexpectedConfiguration := \"The overly permissive statement(s) should restrict services\""
  remediation_instructions = "Perform the following commands to delete or modify the IAM policy via AWS CLI:    \nIf the policy **is not in use**, it is recommended to delete it. Use the following command to delete the policy:  \n```  \naws iam delete-policy \\\n    --policy-arn <value>  \n```  \nIf the policy **is in use**, locate the overly permissive statement(s) in the policy, and create a new JSON file that excludes the permissive condition. Use the following command to create a new policy version and set it to default:  \n```  \naws iam create-policy-version \\\n    --policy-arn <value> \\\n    --policy-document file://<NewPolicyVersion.json> \\\n    --set-as-default  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["customerManagedPolicy", "inlinePolicy"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ans_lib\nimport data.generic.common as common_lib\n\nmodules := {\"community.aws.iam_managed_policy\", \"iam_managed_policy\"}\n\nWizPolicy[result] {\n\ttask := ans_lib.tasks[id][t]\n\tawsApiGateway := task[modules[m]]\n\tans_lib.checkState(awsApiGateway)\n\n\tst := common_lib.get_statement(common_lib.get_policy(awsApiGateway.policy))\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\n\tcommon_lib.equalsOrInArray(statement.Principal.AWS, \"*\")\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}.policy\", [task.name, modules[m]]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"iam_managed_policy.policy.Statement.Principal.AWS should not contain '*'\",\n\t\t\"keyActualValue\": \"iam_managed_policy.policy.Statement.Principal.AWS contains '*'\",\n\t\t\"searchLine\": common_lib.build_search_line([\"playbooks\", t, modules[m], \"policy\"], []),\n\t\t\"resourceTags\": object.get(awsApiGateway, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nactionsContainingStsAssumeRole := {\"*\", \"sts:*\", \"sts:assumerole\"}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::IAM::Policy\"\n\n\tpolicy := resource.Properties.PolicyDocument\n\tst := common_lib.get_statement(common_lib.get_policy(policy))\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.equalsOrInArray(statement.Resource, \"*\")\n\tassumeRoleActions(statement)\n    \n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.PolicyDocument\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.PolicyDocument.Statement' with AssumeRole action should not grant access in all services ('*')\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.PolicyDocument.Statement' with AssumeRole action is granting access in all services ('*')\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resource\", name, \"Properties\", \"PolicyDocument\"], []),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nassumeRoleActions(statement) {\n  startswith(lower(statement.Action[_]), actionsContainingStsAssumeRole[_])\n}{\n  startswith(lower(statement.Action), actionsContainingStsAssumeRole[_])\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresourceType := {\"aws_iam_role_policy\", \"aws_iam_user_policy\", \"aws_iam_group_policy\", \"aws_iam_policy\"}\n\tresource := input.document[i].resource[resourceType[idx]][name]\n\n\tpolicy := common_lib.json_unmarshal(resource.policy)\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tresourceWildcardAndActionContainsStsAssumeRole(statement)\n\tnot common_lib.valid_key(statement, \"Condition\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": resourceType[idx],\n\t\t\"searchKey\": sprintf(\"%s[%s].policy\", [resourceType[idx], name]),\n\t\t\"keyExpectedValue\": \"'policy.Statement.Resource' should not be '*' with the action 'sts:AssumeRole'(or wildcard containing it), or a Condition should exist.\",\n\t\t\"keyActualValue\": \"'policy.Statement.Resource' is '*' and 'policy.Statement.Action' contains 'sts:AssumeRole', or a wildcard allowing it.\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", resourceType[idx], name, \"policy\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nactionsContainingStsAssumeRole := {\"*\", \"sts:*\", \"sts:assumerole\"}\nresourceKeys := {\"Resource\", \"Resources\"}\nactionKeys := {\"Action\", \"Actions\"}\n\nresourceWildcardAndActionContainsStsAssumeRole(statement) {\n\tcommon_lib.equalsOrInArray(statement[resourceKeys[_]], \"*\")\n\tcommon_lib.equalsOrInArray(statement[actionKeys[_]], actionsContainingStsAssumeRole[_])\n}"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-6-r1-1" {
  description              = "This rule checks whether the IAM password policy is set to require a minimum length of 14 characters.  \nThis rule fails if the field `MinimumPasswordLength` does not exist or is set to less than 14.  \nLonger passwords are more secure than shorter ones, and enforcing password length can significantly reduce the risk of brute-force attacks."
  enabled                  = true
  function_as_control      = false
  name                     = " IAM password policy should enforce a minimum length of 12 characters"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nnotRequiresMinimumLength {\n\tnot input.accountPasswordPolicy.MinimumPasswordLength >= 12\n} {\n\tnot input.accountPasswordPolicy\n}\n\nresult = \"fail\" {\n\tnotRequiresMinimumLength\n}\n\ncurrentConfiguration := \"Minimum password length is not configured to 14 higher\"\nexpectedConfiguration := \"Minimum password length should be configured to 14 higher\"\n"
  remediation_instructions = "Perform the following command to edit the IAM password policy enforcement/s via AWS CLI:  \n```  \naws iam update-account-password-policy \\\n  --minimum-password-length <recommended: 12 (characters) or more> \\\n  [--require-numbers] \\\n  [--require-uppercase-characters] \\\n  [--require-lowercase-characters] \\\n  [--password-reuse-prevention <recommended: 10 or more>] \\\n  [--max-password-age <recommended: 90 (days) or less>] \\\n  [--require-symbols]  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["account"]
}


resource "wiz_cloud_configuration_rule" "mp-com-1-1" {
  description              = "This rule checks whether the Default Security Group contains any inbound or outbound rules.  \nThis rule fails unless `IpPermissions` and `IpPermissionsEgress` are `null`. It skips non-default security groups.  \nEach VPC has a default security group that has an initial configuration that denies all inbound traffic and allows all outbound traffic. If you do not specify a security group when you launch an instance, the instance is automatically assigned to this default security group.  \nIt is recommended to remove any inbound and outbound rules, especially any overly permissive rules, from the default security group and not to attach it to any resource."
  enabled                  = true
  function_as_control      = false
  name                     = "Default security group should have no rules configured"
  opa_policy               = "package wiz\n\ndefault result = \"fail\"\n\nresult = \"skip\" {\n   \tinput.GroupName != \"default\" \n} else = \"pass\" {\n\tinput.IpPermissions == null\n\tinput.IpPermissionsEgress == null\n}\n\ncurrentConfiguration := \"Either IpPermissions or IpPermissionsEgress contains rules\"\nexpectedConfiguration := \"No rules should be configured\""
  remediation_instructions = "Perform the following command to remove rules from the security group via AWS CLI:  \n  \nRemove inbound rules:  \n```  \naws ec2 revoke-security-group-ingress --group-id {{securityGroupId}} --security-group-rule-id <ruleId>  \n```  \n  \nRemove outbound rules:  \n```  \naws ec2 revoke-security-group-egress --group-id {{securityGroupId}} --security-group-rule-id <ruleId>  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["securityGroup"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ansLib\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tmodules := {\"amazon.aws.ec2_group\", \"ec2_group\"}\n\tgroup := task[modules[m]]\n\tansLib.checkState(group)\n\n\tsearchKey := getCidrBlock(group)\n\n\tsplitted := regex.split(\"{{|}}\", searchKey)\n\terrorPath := substring(splitted[0], 0, count(splitted[0]) - 1)\n\terrorValue := splitted[1]\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}.%s\", [task.name, modules[m], searchKey]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"ec2_group.%s should not contain the value '%s'\", [errorPath, errorValue]),\n\t\t\"keyActualValue\": sprintf(\"ec2_group.%s contains value '%s'\", [errorPath, errorValue]),\n\t\t\"resourceTags\": object.get(group, \"tags\", {}),\n\t}\n}\n\ngetCidrBlock(sg) = path {\n\tisUnsafeIp(sg.rules[r].cidr_ip)\n\tpath := \"rules.cidr_ip={{0.0.0.0/0}}\"\n} else = path {\n\tisUnsafeIp(sg.rules[r].cidr_ip[c])\n\tpath := \"rules.cidr_ip.{{0.0.0.0/0}}\"\n} else = path {\n\tisUnsafeIp(sg.rules_egress[r].cidr_ip)\n\tpath := \"rules_egress.cidr_ip={{0.0.0.0/0}}\"\n} else = path {\n\tisUnsafeIp(sg.rules_egress[r].cidr_ip[c])\n\tpath := \"rules_egress.cidr_ip.{{0.0.0.0/0}}\"\n} else = path {\n\tisUnsafeIpv6(sg.rules[r].cidr_ipv6)\n\tpath := \"rules.cidr_ipv6={{::/0}}\"\n} else = path {\n\tisUnsafeIpv6(sg.rules[r].cidr_ipv6[c])\n\tpath := \"rules.cidr_ipv6.{{::/0}}\"\n} else = path {\n\tisUnsafeIpv6(sg.rules_egress[r].cidr_ipv6)\n\tpath := \"rules_egress.cidr_ipv6={{::/0}}\"\n} else = path {\n\tisUnsafeIpv6(sg.rules_egress[r].cidr_ipv6[c])\n\tpath := \"rules_egress.cidr_ipv6.{{::/0}}\"\n}\n\nisUnsafeIp(\"0.0.0.0/0\") = true\n\nisUnsafeIpv6(\"::/0\") = true\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tcheck_group_name(resource)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.GroupName should be defined as default and the inbound and outbound rules should be empty.\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.GroupName is defined as default and the inbound and outbound rules are not empty.\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\ncheck_group_name(resource) {\n\tresource.Type == \"AWS::EC2::SecurityGroup\"\n\tsecurity_group := resource.Properties\n\tsecurity_group.GroupName == \"default\"\n\tcheck_rules(security_group)\n}\n\ncheck_rules(security_group) {\n\tcount(security_group.SecurityGroupIngress) != 0\n}\n\ncheck_rules(security_group) {\n\tcount(security_group.SecurityGroupEgress) != 0\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\n# This rule will fail if either the 'ingress' and/or 'egress' blocks exist and\n# is not an empty array in the default security group.\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.resource.aws_default_security_group[name]\n\n\tblocks := {\"ingress\", \"egress\"}\n\tblock := blocks[b]\n\tterraLib.validKey(resource, block)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_default_security_group\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_default_security_group[%s].%s\", [name, block]),\n\t\t\"keyExpectedValue\": sprintf(\"'%s' block should not exist\", [block]),\n\t\t\"keyActualValue\": sprintf(\"'%s' block exists\", [block]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_default_security_group](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/default_security_group)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-1-1" {
  description              = "This rule checks whether the IAM User is attached to at least one user group.  \nThe rule will fail if `GroupList` is `null`.  \nIt is recommended for users to be managed in user groups where IAM policies are centrally controlled."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM User should be part of a group"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tis_null(input.GroupList)\n}\n\ncurrentConfiguration := \"'GroupList': 'null'\"\nexpectedConfiguration := \"User should be part of at least one group\""
  remediation_instructions = "Perform the following command to add the User to a Group via AWS CLI:\n```\naws iam add-user-to-group \\\n\t--user-name {{userName}} \\\n\t--group-name <Group name to add the user to>\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["user"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::IAM::User\"\n\tproperties := resource.Properties\n\n\tnot common_lib.valid_key(properties, \"Groups\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"'Resources.Properties should contain Groups\",\n\t\t\"keyActualValue\": \"'Resources.Properties' does not contain Groups\",\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::IAM::User\"\n\tgroups := resource.Properties.Groups\n\tcount(groups) == 0\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.Groups\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'Resources.Properties.Groups' should contain groups\",\n\t\t\"keyActualValue\": \"'Resources.Properties.Groups' is empty\",\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
}


resource "wiz_control" "op-exp-1-1" {
  description               = "All cloud assets should be tagged with metadata that allows for clear ownership identification. Required tags include: Owner (individual or team responsible), Team (department or business unit), Environment (e.g., dev, staging, prod), and Application (associated service or workload)"
  enabled                   = true
  name                      = "Cloud assets should be tagged with metadata allowing for clear ownership identification"
  project_id                = "*"
  query                     = "{\"select\":true,\"type\":[\"CLOUD_RESOURCE\"],\"where\":{\"tags\":{\"TAG_CONTAINS_ANY\":[{\"key\":\"departamento\"},{\"key\":\"Propietario\"}]}}}"
  resolution_recommendation = null
  scope_query               = "{\"type\":[\"CLOUD_RESOURCE\"]}"
  security_sub_categories   = []
  severity                  = "MEDIUM"
}

resource "wiz_cloud_configuration_rule" "op-acc-4-10" {
  description              = "This rule checks whether the IAM policy (customer-managed or inline) allows all KMS actions.  \nThis rule fails if the policy contains at least one statement where:  \n* `Effect` is `Allow`\n* `Action` is `kms:*` \n* `Condition` is null or does not exist  \n\nIt is generally not recommended to include a wildcard ('*') in the action field of an AWS Key Management Service (KMS) key policy because it grants permission to perform all actions on the key, which could potentially include the ability to delete or modify the key, as well as encrypt and decrypt data.  \nThis could be a security risk because it allows any user or service with access to the key to perform any action on it, which could lead to data loss or unauthorized access. It's better to limit permissions to specific actions and for specific resources that are required for your use case."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM policy should not allow all KMS actions"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\niamPolicy := policy {\n# for parsed policies:\n\tinput.Version\n\tpolicy := input\n}{\n# for policies that require parsing:\n\tpolicy := json.unmarshal(input)\n}\n\n# While '*' also allows all KMS actions, it is intentionally not added to the logic.\n# Cloud Configuration Rule 'IAM-025' detects identity-based policies that allow\n# all actions on all resources.\n\nallKmsActions(statement) {\n\tlower(statement.Action) == \"kms:*\"\n}{\n\tlower(statement.Action[_]) == \"kms:*\"\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\nstatementAllowsAllKmsActions[statement] {\n\tstatement := iamPolicy.Statement[_]\n\tallKmsActions(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n}\n\nresult := \"fail\" { \n\tcount(statementAllowsAllKmsActions) > 0\n}\n\ncurrentConfiguration := \"Policy allows all KMS actions\"\nexpectedConfiguration := \"Policy should not allow all KMS actions\"\n"
  remediation_instructions = "Perform the following commands to delete or modify the IAM policy via AWS CLI:    \n1. First, use the following command to list the IAM entities (Users\\Roles\\Groups) that have the policy attached (if any):  \n```  \naws iam list-entities-for-policy \\\n    --policy-arn <value>  \n```  \n* If the policy **is not attached** to IAM entities - proceed to 2a.    \n* If the policy **is attached** to one or more IAM entities - proceed to 2b.    \n\n2a. As this policy is not in use, It is recommended to delete it. Use the following command to delete the policy:  \n```  \naws iam delete-policy \\\n    --policy-arn <value>  \n```  \n2b. It is recommended to edit the policy and remove the permissive statement.    \nFirst, use the following command to view the policy and locate the overly-permissive statement/s.    \n**Note:** You can also view the policy in the native object JSON in Wiz.  \n```  \naws iam get-policy \\\n    --policy-arn <value> \\\n    --version-id <value>  \n```  \nIf you are not sure what the policy version id is, use the following command to check. It is the 'DefaultVersionId' in the output:  \n```  \naws iam get-policy-version \\\n    --policy-arn <value>  \n```  \nNext, create a new policy in a JSON file locally which replaces the wildcards `*` with the required actions and resources only.    \nUse the following command to create a new policy version with the new policy created and set it to default:  \n```  \naws iam create-policy-version \\\n    --policy-arn <value> \\\n    --policy-document file://<NewPolicyVersion.json> \\\n    --set-as-default  \n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["customerManagedPolicy", "inlinePolicy"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_iam_policy[name]\n\tpolicy := json.unmarshal(resource.policy)\n\tstatement := policy.Statement[_]\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.check_actions(statement, \"kms:*\")\n\tnot terraLib.validKey(statement, \"Condition\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_policy[%s].policy\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_iam_policy[%s].policy.Statement should not allow all KMS actions\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_iam_policy[%s].policy.Statement allows all KMS actions\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_policy\", name, \"policy\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "resource \"aws_iam_policy\" \"example_policy\" {\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Effect = \"Allow\"\n        Action = [\n          <kms_action> // Specify action that does not contain wildcard ('*')\n        ]\n        Resource = \"<kms_key_arn>\" // Specify the ARN of the KMS key\n      }\n    ]\n  })\n}"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "mp-s-2-2" {
  description              = "This rule checks whether the API Gateway (REST API) stages are configured with WAFv2 Web ACL.\nThis rule fails if any stage's WebAclArn field doesn't start with arn:aws:wafv2.\n\nA web access control list (web ACL) gives you fine-grained control over all of the HTTP(S) web requests that your protected resource responds to. \n>**Note**  \nYou can associate each AWS resource with only one web ACL. The relationship between web ACL and AWS resources is one-to-many.  \nYou cannot associate a web ACL that you have associated with a CloudFront distribution with any other AWS resource type."
  enabled                  = true
  function_as_control      = false
  name                     = "REST API Gateway stages should be configured with WAFv2 Web ACL"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nstages := input.Stages\n\nis_invalid_arn(stage) {\n    not stage.WebAclArn\n}{\n    is_null(stage.WebAclArn)\n}{\n    not startswith(stage.WebAclArn, \"arn:aws:wafv2\")\n}\n\ninvalidStages {\n    is_invalid_arn(stages[_])\n}\n\nresult := \"fail\" {\n    invalidStages\n}\n\ncurrentConfiguration := \"Some 'WebAclArn' fields in stages do not contain valid ARNs\"\nexpectedConfiguration := \"All 'WebAclArn' fields in stages should contain valid ARNs\""
  remediation_instructions = "Perform the following commands to configure the API Gateway REST API with WAFv2 WebACL via AWS CLI:    \n```  \naws wafv2 associate-web-acl --web-acl-arn <webAclArn> --resource-arn <resourceArn>  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["apiGateway"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ans_lib\nimport data.generic.common as common_lib\n\nmodules := {\"community.aws.aws_api_gateway\", \"aws_api_gateway\"}\n\nWizPolicy[result] {\n\ttask := ans_lib.tasks[id][t]\n\tapi := task[modules[m]]\n\tans_lib.checkState(api)\n\n\tnot has_waf_associated(api.stage)\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}\", [task.name, modules[m]]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"API Gateway Stage should be associated with a Web Application Firewall\",\n\t\t\"keyActualValue\": \"API Gateway Stage is not associated with a Web Application Firewall\",\n\t\t\"searchLine\": common_lib.build_search_line([\"playbooks\", t, modules[m]], []),\n\t\t\"resourceTags\": object.get(api, \"tags\", {}),\n\t}\n}\n\nhas_waf_associated(stage) {\n\twaf := {\"community.aws.wafv2_resources\", \"wafv2_resources\"}\n\n\ttask2 := ans_lib.tasks[_][_]\n\twafResource := task2[waf[_]]\n\tans_lib.checkState(wafResource)\n\tcontains(wafResource.arn, \"arn:aws:apigateway:\")\n\tassociatedStage := split(wafResource.arn, \"/\")\n\tassociatedStage[4] == stage\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tlower(resource.Type) == \"aws::apigateway::stage\"\n\n\tnot has_waf_associated(resource.Properties.StageName, name)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"resourceType\": resource.Type,\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.StageName\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"API Gateway Stage should be associated with a Web Application Firewall\",\n\t\t\"keyActualValue\": \"API Gateway Stage is not associated with a Web Application Firewall\",\n\t\t\"searchLine\": common_lib.build_search_line([\"Resources\", name, \"Properties\", \"StageName\"], []),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nhas_waf_associated(stageName, resourceName) {\n\tresource := input.document[i].Resources[name]\n\tlower(resource.Type) == \"aws::wafv2::webaclassociation\"\n\tcontains(lower(resource.Properties.ResourceArn), \"arn:aws:apigateway:\")\n\tassociatedStage := split(lower(resource.Properties.ResourceArn), \"/\")\n\tassociatedStage[4] == lower(stageName)\n}{\n\tresource := input.document[i].Resources[name]\n\tlower(resource.Type) == \"aws::wafv2::webaclassociation\"\n\ttemp := resource.Properties.ResourceArn[r]\n\tarn := temp[_].playbooks\n\tcontains(lower(arn[0]), \"arn:aws:apigateway:\")\n\tassociatedStage := lower(arn[3].Ref)\n\tassociatedStage == lower(resourceName)\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\n\nwafExists(document, apiGatewayStageResource, gatewayStageName) {\n\twafAssociationResource := document.resource.aws_wafv2_web_acl_association[wafAssociationName]\n\tterraLib.associatedResources(apiGatewayStageResource, wafAssociationResource, gatewayStageName, wafAssociationName, null, \"resource_arn\")\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tapiGatewayStageResource := document.resource.aws_api_gateway_stage[gatewayStageName]\n\n\tnot wafExists(document, apiGatewayStageResource, gatewayStageName)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": terraLib.get_resource_name(apiGatewayStageResource, gatewayStageName),\n\t\t\"resourceType\": \"aws_api_gateway_stage\",\n\t\t\"searchKey\": sprintf(\"aws_api_gateway_stage[%s]\", [gatewayStageName]),\n\t\t\"keyExpectedValue\": sprintf(\"'aws_api_gateway_stage[%s]' should be associated with a WAF ('aws_wafv2_web_acl_association')\", [gatewayStageName]),\n\t\t\"keyActualValue\": sprintf(\"'aws_api_gateway_stage[%s]' is not associated with a WAF\",[gatewayStageName]),\n\t\t\"resourceTags\": object.get(apiGatewayStageResource, \"tags\", {})\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_api_gateway_stage](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/api_gateway_stage), [aws_wafv2_web_acl_association](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/wafv2_web_acl_association)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-7-13" {
  description              = "This rule checks whether the AWS Account has primary contact information.  \nThis rule fails if `accountContactInformationConfigured` is `false`.  \nProviding contact information is crucial for AWS to contact the account owner in case of security incidents or other important issues.  \nIt is recommended to keep this information up to date to ensure timely communication.  \n>**Note**  \nThe resource JSON does not provide the contact information details, only if they exist or not."
  enabled                  = true
  function_as_control      = false
  name                     = "AWS Account primary contact information should be provided"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"fail\" {\n\tinput.accountContactInformationConfigured == false\n}\n\ncurrentConfiguration := \"'accountContactInformationConfigured': 'false'\"\nexpectedConfiguration := \"Primary contact information should be provided for the Account\""
  remediation_instructions = "Perform the following command to update the primary contact for your AWS account via AWS CLI:\n```\naws account put-contact-information \\\n\t--contact-information '{\"AddressLine1\": <\"value\">, \"City\": <\"value\">, \"CompanyName\": <\"value\">, \"CountryCode\": <\"value\">, \"DistrictOrCounty\": <\"value\">, \n\"FullName\": <\"value\">, \"PhoneNumber\": <\"value\">, \"PostalCode\": <\"value\">, \"StateOrRegion\": <\"value\">, \"WebsiteUrl\": <\"value\">}'\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["account"]
}


resource "wiz_cloud_configuration_rule" "op-acc-6-r2-4" {
  description              = "This rule checks whether the IAM assumed role policy for cross-account access requires the use of an external ID or Multi-Factor Authentication (MFA).  \nThis rule fails if the role is cross-account and the `sts:ExternalId` field is set to `null` or does not exist, and if the `aws:MultiFactorAuthPresent` field is not set to `true`.  \nThe primary function of this rule is to address the confused deputy problem. In abstract terms, the external ID allows the user that is assuming the role to assert the circumstances under which they are operating. It also allows the account owner to permit the role to be assumed only under specific circumstances."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM assumed role cross account should have an external ID or MFA"
  opa_policy               = "package wiz\nimport future.keywords.in\n\ndefault result = \"pass\"\n\npolicyEncode(assumeRolePolicy) = statements {\n\tassumeRolePolicy.Version\n\tstatements := assumeRolePolicy.Statement\n}{\n\tstatements := json.unmarshal(assumeRolePolicy).Statement\n}\n\nstatements := policyEncode(input.AssumeRolePolicyDocument)\nsource := split(input.Arn, \":\")[4]\nisTrue := {true, \"true\"}\nisNull := {null, \"null\"}\n\ncrossAccountRole(statement) {\n\tdestination := statement.Principal.AWS\n\tsource != split(destination, \":\")[4]\n}{\n\tdestination := statement.Principal.AWS[_]\n\tsource != split(destination, \":\")[4]\n}\n\nmfaOrExternalIdConditionsExist(statement) {\n\tstatement.Condition.Bool[\"aws:MultiFactorAuthPresent\"] in isTrue\n}{\n\tstatement.Condition.BoolIfExists[\"aws:MultiFactorAuthPresent\"] in isTrue\n}{\n\tstatement.Condition.StringEquals[\"sts:ExternalId\"]\n\tnot statement.Condition.StringEquals[\"sts:ExternalId\"] in isNull\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nuncompliantStatement[statements] {\n\tstatements := policyEncode(input.AssumeRolePolicyDocument)\n\tnot mfaOrExternalIdConditionsExist(statements[s])\n\tcrossAccountRole(statements[s])\n\teffectAllow(statements[s])\n}\n\nresult = \"skip\" {\n\tnot input.AssumeRolePolicyDocument\n} else = \"fail\" {\n\tcount(uncompliantStatement) > 0\n}\n\ncurrentConfiguration := \"'AssumeRolePolicyDocument' is cross-account and does not require 'aws:MultiFactorAuthPresent' or 'sts:ExternalId' conditions\"\nexpectedConfiguration := \"Cross-account assumed roles should require external ID or MFA\""
  remediation_instructions = "Perform the following commands to configure the IAM Assume role policy to use external ID or Multi-Factor Authentication via AWS CLI:    \n1. You should choose if you would like to use an external ID, Multi-Factor Authentication (MFA), or both:    \n1a. Add the following fields to the JSON policy to configure the role to use an external ID:  \n```  \n\"Condition\": {  \n  \"StringEquals\": {  \n      \"sts:ExternalId\": <externalId>  \n  }  \n}  \n```  \n1b. Add the following fields to the JSON policy to configure the role to use MFA:  \n```  \nCondition\": {  \n  \"Bool\": {  \n    \"aws:MultiFactorAuthPresent\": \"true\"  \n  }  \n}  \n```  \n2. Use the following command to update the role with the changes in the JSON policy:  \n```  \naws iam update-assume-role-policy --role-name {{roleName}} --policy-document <policyDocumentJson>  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["role"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ans_lib\nimport data.generic.common as common_lib\n\nmodules := {\"community.aws.iam_role\", \"iam_role\"}\n\nWizPolicy[result] {\n\ttask := ans_lib.tasks[id][t]\n\tiamRole := task[modules[m]]\n\tans_lib.checkState(iamRole)\n\n\tpolicy := iamRole.assume_role_policy_document\n\tst := common_lib.get_statement(common_lib.get_policy(policy))\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\n\tcommon_lib.is_cross_account(statement)\n\tcommon_lib.is_assume_role(statement)\n\n\tnot common_lib.has_external_id(statement)\n\tnot common_lib.has_mfa(statement)\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}.assume_role_policy_document\", [task.name, modules[m]]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"assume_role_policy_document should not contain ':root\",\n\t\t\"keyActualValue\": \"assume_role_policy_document contains ':root'\",\n\t\t\"searchLine\": common_lib.build_search_line([\"playbooks\", t, modules[m], \"assume_role_policy_document\"], []),\n\t\t\"resourceTags\": object.get(iamRole, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::IAM::Role\"\n\n\tpolicy := resource.Properties.AssumeRolePolicyDocument\n\tst := common_lib.get_statement(common_lib.get_policy(policy))\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\n\tcommon_lib.is_cross_account(statement)\n\tcommon_lib.is_assume_role(statement)\n\n\tnot common_lib.has_external_id(statement)\n\tnot common_lib.has_mfa(statement)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.AssumeRolePolicyDocument\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.AssumeRolePolicyDocument should require external ID or MFA\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.AssumeRolePolicyDocument does not require external ID or MFA\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line(path, [name, \"Properties\", \"AssumeRolePolicyDocument\"]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_iam_role[name]\n\n\tpolicy := common_lib.json_unmarshal(resource.assume_role_policy)\n\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\n\tcommon_lib.is_cross_account(statement)\n\tcommon_lib.is_assume_role(statement)\n\n\tnot common_lib.has_external_id(statement)\n\tnot common_lib.has_mfa(statement)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_role\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_role[%s].assume_role_policy\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'assume_role_policy' requires external ID or MFA\",\n\t\t\"keyActualValue\": \"'assume_role_policy' does not require external ID or MFA\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_role\", name, \"assume_role_policy\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_role](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_role)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-8-4" {
  description              = "This rule checks whether the CloudTrail trail is configured to log S3 data events.  \nThis rule fails if the `Basic` or `Advanced` event selectors don't have Data `AWS::S3::Object` type objects with both read and write logging.  \nData events provide visibility into the resource operations performed on or within a resource. These are also known as data plane events.  \nIt is recommended to enable S3 data events to proactively monitor problems and issues with your resource, perform security analysis, or take actions using Amazon CloudWatch Events.  \n>**Note**  \nAdditional charges apply for logging data events. To view CloudTrail pricing, click [here](https://aws.amazon.com/cloudtrail/pricing/)."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail trail should be configured with S3 data events"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\nS3objectType := \"AWS::S3::Object\"\n\n#check for read and write permissions in basic event selectors\nbasicReadAndWrite(eventSelector) {\n\tlower(eventSelector.ReadWriteType) == \"all\"\n}\n\n# #check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\tlower(readOrWrite.Field) == \"readonly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tlower(currSelector.Field) == lower(currField)\n\tlower(currSelector.Equals[_]) == lower(currValue)\n}\n\nadvancedEventSelectorWithDataEvents(AdvancedEventSelectors) {\n \tcheckFieldSelector(AdvancedEventSelectors.FieldSelectors[_], \"resources.type\", S3objectType)\n  \tcheckFieldSelector(AdvancedEventSelectors.FieldSelectors[_], \"eventCategory\", \"Data\")\n   \tnot advanReadAndWrite(AdvancedEventSelectors.FieldSelectors)\n\n}\n\n#check event selector for basic and advanced resources\nconfiguredWithS3DataEvents {\n\t# Basic \n \tlower(input.EventSelectors[_].DataResources[_].Type) == lower(S3objectType)\n   \tbasicReadAndWrite(input.EventSelectors[_])\n}{ \n \t# Advanced\n \tadvancedEventSelectorWithDataEvents(input.AdvancedEventSelectors[_])\n}\n\nresult = \"fail\" {\n\tnot configuredWithS3DataEvents\n}\n\ncurrentConfiguration := \"Cloudtrail is not configured with S3 data events\"\nexpectedConfiguration := \"Cloudtrail should be configured with S3 data events\""
  remediation_instructions = "Perform the following commands to configure CloudTrail to log S3 data events via AWS CLI:\n\n1. Use the following command to enable **basic** S3 data events:\n```\naws cloudtrail put-event-selectors \\\n--trail-name {{trailName}} \\\n--event-selectors '[\n{ \n    \"ReadWriteType\": \"All\", \n    \"DataResources\": [\n    { \n        \"Type\": \"AWS::S3::Object\",\n        \"Values\": [\n            \"arn:aws:s3:::\"\n        ] \n    }\n    ],\n    \"IncludeManagementEvents\": true\n  }\n]'\n```\n2. Use the following command to enable **Advanced** S3 data events:\n```\naws cloudtrail put-event-selectors \\\n  --trail-name {{trailName}} \\\n  --advanced-event-selectors '[ \n     { \n        \"FieldSelectors\": [ \n        {\n            \"Field\": \"eventCategory\",\n            \"Equals\": [ \"Management\" ]\n        }    \n        ]\n    },\n    { \n        \"FieldSelectors\": [ \n        {\n            \"Field\": \"eventCategory\",\n            \"Equals\": [ \"Data\" ]\n        },\n        {\n            \"Field\": \"resources.type\",\n            \"Equals\": [ \"AWS::S3::Object\" ]\n        }\n        ]\n    }\n  ]'\n```\n>**Note**  \nYou can use either AdvancedEventSelectors or EventSelectors, but not both. If you apply AdvancedEventSelectors to a trail, any existing EventSelectors are overwritten."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terra_lib\n\nS3objectType := \"AWS::S3::Object\"\n\n#check for read and write permissions in basic event selectors\nbasicReadAndWrite(basicSelector) {\n\tbasicSelector.read_write_type == \"All\"\n}\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\treadOrWrite.field == \"readOnly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tcurrSelector.field == currField\n\tcurrSelector.equals[_] == currValue\n}\n\nadvancedEventSelectorWithDataEvents(currEventSel) {\n\tcheckFieldSelector(currEventSel[_], \"resources.type\", S3objectType)\n  \tcheckFieldSelector(currEventSel[_], \"eventCategory\", \"Data\")\n  \tnot advanReadAndWrite(currEventSel)\n}\n\n#check data resources types in basic event selectors\ncheckDataResource(currDataRes, currType) {\n\tcurrDataRes.type == currType\n}\n\nbasicDataResourcesWithDataEvents(currDataRes) {\n  \tcheckDataResource(currDataRes, S3objectType)\n}\n\n#seperate checks for advanced single and multi selectors\nadvancedEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.advanced_event_selector[_]\n\tadvancedEventSelectorWithDataEvents(eventSel.field_selector)\n}{\n\t# Singel event selectors\n\teventSel := cloudtrailResource.advanced_event_selector\n\tadvancedEventSelectorWithDataEvents(eventSel.field_selector)\t\n}\n\nbasicEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.event_selector[_]\n\tdataResource(eventSel)\n}{\n\t# Singel event selectors\n\teventSel := cloudtrailResource.event_selector\n\tdataResource(eventSel)\t\n}\n\n#seperate checks for basic single and multi data resources\ndataResource(basicSelector) {\n\t# Multi data resources\n\tdataRes := basicSelector.data_resource[_]\n\tbasicDataResourcesWithDataEvents(dataRes)\n\tbasicReadAndWrite(basicSelector)\n}{\n\t# Singel data resources\n\tdataRes := basicSelector.data_resource\n\tbasicDataResourcesWithDataEvents(dataRes)\n\tbasicReadAndWrite(basicSelector)\n}\n\n#check event selector for basic and advanced resources\nconfiguredWithS3DataEvents(cloudtrailResource) {\n\t# Basic \n  \tbasicEventSelc(cloudtrailResource)\n}{ \n\t# Advanced\n\tadvancedEventSelc(cloudtrailResource)\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[cloudtrailName]  \n\tnot configuredWithS3DataEvents(cloudtrailResource)\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceName\": terra_lib.get_resource_name(cloudtrailResource, cloudtrailName),\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [cloudtrailName]),\n\t\t\"keyExpectedValue\": sprintf(\"cloudtrail %v should be configured with S3 data events\",[cloudtrailName]),\n\t\t\"keyActualValue\": sprintf(\"cloudtrail %v is not configured with S3 data events\",[cloudtrailName]),\n  \t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {})\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudtrail](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudtrail)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "op-acc-4-12" {
  description              = "This rule checks whether the IAM Access Analyzer is enabled and active in the AWS account.  \nThis rule fails if the no Access Analyzer exists with `Status` set to `ACTIVE`.  \nIAM Access Analyzer helps you identify the resources in your organization and accounts, such as Amazon S3 buckets or IAM roles, that are shared with an external entity. This lets you review and monitor access to your resources and helps ensure that your resources are not unintentionally shared."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM Access Analyzer should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\naccess_analyzer_active {\n\tupper(input.AccessAnalyzers[i].Status) == \"ACTIVE\"\n}\n\nresult = \"fail\" {\n\tnot access_analyzer_active\n}\n\ncurrentConfiguration := \"'AccessAnalyzers' do not contain an element with 'Status' set to 'ACTIVE'\"\nexpectedConfiguration := \"'AccessAnalyzers' should contain at least one element with 'Status' set to 'ACTIVE'\"\n"
  remediation_instructions = "Perform the following command to enable IAM Access Analyzer via AWS CLI:\n```\naws accessanalyzer create-analyzer \\\n\t--analyzer-name <Analyzer Name> \\\n\t--type ACCOUNT \\\n\t--region {{RegionName}}\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["region"]
}


resource "wiz_cloud_configuration_rule" "op-exp-6-1" {
  description              = "This rule checks whether the Malware Protection feature in Amazon GuardDuty is enabled.  \nThis rule fails if the `EBS_MALWARE_PROTECTION` status is disabled.  \nGuardDuty Malware Protection helps identify potential security threats by scanning EBS volumes for malware, which can compromise the EC2 instances and the data stored within. It is recommended to keep this feature enabled to enhance the security posture of your AWS environment."
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty Detector Malware Protection should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"EBS_MALWARE_PROTECTION\"\n\nfeatureDisabled {\n\tupper(input.Features[feature].Name) == protection\n\tupper(input.Features[feature].Status) == \"DISABLED\"\n}\n\n\nresult = \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])\n"
  remediation_instructions = "Perform the following command to enable Malware Protection for GuardDuty via AWS CLI:\n\n```\naws guardduty update-member-detectors \\\n--detector-id {{detectorID}} \\\n--account-ids {{accountID}} \\\n--features '[{\"Name\": \"EBS_MALWARE_PROTECTION\", \"Status\": \"ENABLED\"}]'\n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
}


resource "wiz_cloud_configuration_rule" "mp-si-2-7" {
  description              = "This rule checks if the CloudWatch Log Group is encrypted using KMS.  \nThis rule fails if `KmsKeyId` is `null`.  \nLog group data is always encrypted in CloudWatch Logs. By default, CloudWatch Logs uses server-side encryption for the log data at rest. As an alternative, you can use AWS Key Management Service for this encryption. If you do, the encryption is done using a KMS customer-managed key. Encryption using KMS is enabled at the log group level, by associating a key with a log group, either when you create the log group or after it exists.  \nIt is recommended to encrypt the log group with a KMS key."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudWatch Log Group should be encrypted using KMS"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tis_null(input.KmsKeyId)\n}\n\ncurrentConfiguration := \"'KmsKeyId': 'null'\"\nexpectedConfiguration := \"'KmsKeyId' should not be 'null'\""
  remediation_instructions = "Perform the following command to encrypt the CloudWatch Log Group with a KMS customer-managed key via AWS CLI:\n```\naws logs associate-kms-key \\\n\t--log-group-name {{logGroupName}} \\\n\t--kms-key-id <key-arn>\n```\n>**Note**  \n>The command above assumes you already have a KMS key for the log group. If you do not, follow the steps [here](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/encrypt-log-data-kms.html#create-cmk) first to create one."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["logs#loggroup"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n    resource := input.document[i].Resources[name]\n    lower(resource.Type) == \"aws::logs::loggroup\"\n    not common_lib.valid_key(resource.Properties, \"KmsKeyId\")\n\n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": \"AWS::Logs::LogGroup\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n        \"issueType\": \"MissingAttribute\",\n        \"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' should be defined\", [name]),\n        \"keyActualValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' is not defined\", [name]),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}\n\nWizPolicy[result] {\n    resource := input.document[i].Resources[name]\n    lower(resource.Type) == \"aws::logs::loggroup\"\n    common_lib.valid_key(resource.Properties, \"KmsKeyId\")\n    resource.Properties.KmsKeyId == \"\"\n\n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": \"AWS::Logs::LogGroup\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.KmsKeyId\", [name]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' should not be empty\", [name]),\n        \"keyActualValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' is empty\", [name]),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudwatch_log_group[name]\n\tnot common_lib.valid_key(resource, \"kms_key_id\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudwatch_log_group\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudwatch_log_group[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"Attribute 'kms_key_id' should be set\",\n\t\t\"keyActualValue\": \"Attribute 'kms_key_id' is undefined\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudwatch_log_group](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudwatch_log_group)"
    type                     = "TERRAFORM"
  }
}



resource "wiz_cloud_configuration_rule" "op-acc-6-r5-2" {
  description              = "This rule checks whether CloudTrail at the organization level is configured as multi-region, global service logging is enabled, and management events are configured for all read/write operations.  \nEnsuring that a multi-region trail exists assists with detecting when unexpected activity occurs.  \nWhen global service logging is enabled, events on AWS global services are recorded as well. In addition, to ensure management operations performed on all resources are recorded as well, management events should be configured for all read/write operations."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail management events and global service logging should be enabled in all regions - Organization level"
  opa_policy               = "package wiz\n\ndefault result = \"fail\"\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\tlower(readOrWrite.Field) == \"readonly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tlower(currSelector.Field) == lower(currField)\n\tlower(currSelector.Equals[_]) == lower(currValue)\n}\n\n#returns value if configuration is good\nselectors[event] {\n\t#basic\n\tevent := input.EventSelectors[i]\n    event.IncludeManagementEvents\n    lower(event.ReadWriteType) == \"all\"\n}{\n\t#advanced\n\tevent := input.AdvancedEventSelectors[i]\n  \tcheckFieldSelector(event.FieldSelectors[_], \"eventCategory\", \"Management\")\n\tnot advanReadAndWrite(event.FieldSelectors)\n}\n\nresult = \"skip\" { #if account level\n\tnot input.IsOrganizationTrail\n}\nelse = \"pass\" {\n\tinput.IsMultiRegionTrail\n    input.CloudTrailStatus.IsLogging\n    count(selectors) > 0\n}\ncurrentConfiguration := sprintf(\"IsMultiRegionTrail setting is set to: %s. IsLogging is set to: %s. Required event selector exists: %s\", [input.IsMultiRegionTrail, input.CloudTrailStatus.IsLogging, count(selectors) > 0])\nexpectedConfiguration := \"IsMultiRegionTrail and IsLogging should be set to true. There should be at least one event selector with IncludeManagementEvents set to true and ReadWriteType set to 'All'\""
  remediation_instructions = "Perform the following commands in order to modify CloudTrail via CLI:  \n1. Use the following command in order to enable Multi-region CloudTrail logging:  \n```  \naws cloudtrail update-trail --name {{trailName}} --is-multi-region-trail  \n```  \n2. Use the following command in order to start CloudTrail logging:  \n```  \naws cloudtrail start-logging --name {{trailName}}  \n```  \n3. Use the following command in order to modify CloudTrail event selectors:  \n```  \naws cloudtrail put-event-selectors --trail-name {{trailName}} --event-selectors '[{\"ReadWriteType\": \"All\",\"IncludeManagementEvents\": true}]'  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tcommon_lib.valid_key(resource.Properties, \"IsMultiRegionTrail\")\n\tnot checkRegion(resource)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.IsMultiRegionTrail\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' is false\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tnot common_lib.valid_key(resource.Properties, \"IsMultiRegionTrail\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' should exist\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' is missing\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\ncheckRegion(cltr) {\n\tcltr.Properties.IsMultiRegionTrail == true\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nisOrganizationLevel(cloudtrailResource) {\n\tcloudtrailResource.is_organization_trail == true\n}\n\nisMultiRegionTrail(cloudtrailResource) {\n\tnot common_lib.valid_key(cloudtrailResource, \"is_multi_region_trail\")\t\n}{\n\tcloudtrailResource.is_multi_region_trail == false\n}\n\n#check for read and write permissions in basic event selectors\nbasicReadAndWrite(eventSel) {\n\teventSel.read_write_type == \"All\"\n}\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\treadOrWrite.field == \"readOnly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tcurrSelector.field == currField\n\tcurrSelector.equals[_] == currValue\n}\n\nadvancedEventSelectorWithManagementEvents(currEventSel) {\n  \tcheckFieldSelector(currEventSel[_], \"eventCategory\", \"Management\")\n  \tnot advanReadAndWrite(currEventSel)\n}\n\nbasicResourcesWithManagementEvents(eventSel) {\n\teventSel.include_management_events == true\n}\n\n#seperate checks for advanced single and multi selectors\nadvancedEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.advanced_event_selector[_]\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.advanced_event_selector\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\t\n}\n\n#seperate checks for basic single and multi event selectors\nbasicEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.event_selector[_]\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.event_selector\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}\n\n#check event selector for basic and advanced resources\nconfiguredWithManagementEvents(cloudtrailResource) {\n\t# Basic \n  \tbasicEventSelc(cloudtrailResource)\n}{ \n\t# Advanced\n\tadvancedEventSelc(cloudtrailResource)\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[cloudtrailName]  \n\tnot configuredWithManagementEvents(cloudtrailResource)\n \tisOrganizationLevel(cloudtrailResource)\n\tisMultiRegionTrail(cloudtrailResource)\n\t\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, cloudtrailName),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [cloudtrailName]),\n\t\t\"keyExpectedValue\": sprintf(\"cloudtrail %v should be configured with management events and multi region\",[cloudtrailName]),\n\t\t\"keyActualValue\": sprintf(\"cloudtrail %v is not configured with management events and multi region\",[cloudtrailName]),\n  \t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {})\n\t}\n}\n\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\tnot common_lib.valid_key(cloudtrailResource, \"is_multi_region_trail\")\n\tisOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail is defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail is undefined or null\", [name]),\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\tcloudtrailResource.is_multi_region_trail == false\n\tisOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail is set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail is set to false\", [name]),\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\tcloudtrailResource.enable_logging == false\n\tisOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].enable_logging\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s].enable_logging undefined or is set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s].enable_logging is set to false\", [name]),\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudtrail](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudtrail)"
    type                     = "TERRAFORM"
  }
}

resource "wiz_cloud_configuration_rule" "mp-com-1-4" {
  description              = "This rule checks if the EC2 or VPC Security Group is not being used.  \nIt is recommended to delete (or not create) any unused Security Groups in your AWS account."
  enabled                  = true
  function_as_control      = false
  name                     = "Unused Security Group should be deleted"
  opa_policy               = null
  remediation_instructions = null
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["securityGroup"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\n\n\nextractSecurityGroupsNames(resourceName) = {\n\tx |\n\t\tnot is_null(resourceName[\"security_groups\"])\n\t\tx := resourceName[\"security_groups\"][_]\n}\n\nextractSecurityGroupsIdNames(resourceName) = {\n\tx |\n\t\tnot is_null(resourceName[\"security_group_ids\"])\n\t\tx := resourceName[\"security_group_ids\"][_]\n}\n\nextractVpcSecurityGroupIdsNames(resourceName) = {\n\tx |\n\t\tnot is_null(resourceName[\"vpc_security_group_ids\"])\n\t\tx := resourceName[\"vpc_security_group_ids\"][_]\n}\n\nextractSecurityGroupIdNames(resourceName) = {\n\tresourceName[\"security_group_id\"] | not is_null(resourceName[\"security_group_id\"])\n}\n\n# The next 2 functions are to supports cases if the SG is configured in a CloudFormation Stack.\ncfSgReourceTypes := {\"VpcSecurityGroupIds\", \"SecurityGroupIds\", \"SecurityGroups\"}\n\nextractVpcSecurityGroupIdsNamesFromCloudformationStackParameters(resourceName) = {\n\tx |\n\t\tsecurityGroups := resourceName.parameters[cfSgReourceTypes[type]]\n\t\tnot is_null(securityGroups)\n\t\tis_array(securityGroups)\n\t\tx := securityGroups[_]\n}\n\nextractVpcSecurityGroupIdsNamesFromCloudformationStackParametersInString(resourceName) = {\n\tx |\n\t\tsecurityGroups := resourceName.parameters[cfSgReourceTypes[type]]\n\t\tnot is_null(securityGroups)\n\t\tis_string(securityGroups)\n\t\tcontains(securityGroups, \"aws_security_group\")\n\t\ttemp := [ y | y := regex.find_all_string_submatch_n(\"aws_security_group.[a-zA-Z0-9_-]*\", securityGroups, -1)[_][_]][_]\n        x := concat(\"\", [\"$${\", temp, \"}\"])\t\t\n}\n\nextractSecurityGroupNames(res) = {\n\tsecurityGroupNames |\n\t\tsecurityGroupsNames := extractSecurityGroupsNames(res)\n\t\tsecurityGroupsIdNames := extractSecurityGroupsIdNames(res)\n\t\tvpcSecurityGroupIdsNames := extractVpcSecurityGroupIdsNames(res)\n\t\tsecurityGroupIdNames := extractSecurityGroupIdNames(res)\n\t\tsecurityGroupNamesFromCloudformation := extractVpcSecurityGroupIdsNamesFromCloudformationStackParameters(res)\n\t\tsecurityGroupNamesFromCloudformationString := extractVpcSecurityGroupIdsNamesFromCloudformationStackParametersInString(res)\n\t\tsecurityGroupNames := securityGroupsNames|securityGroupsIdNames|vpcSecurityGroupIdsNames|securityGroupIdNames|securityGroupNamesFromCloudformation|securityGroupNamesFromCloudformationString\n}\n\nallResourcesSecurityGroupNames = {\n    {\n\t\tsgNames[_] |\n\t\t\t[_, value] := walk(input.document[j])\n\t\t\tsgNames := extractSecurityGroupNames(value)[_]\n\t\t\tcount(sgNames) > 0\n\t}\n}\n\nisSecurityGroupInUse(sgResource, sgResourceName, allUsedSGNames) {\n\tsgNameUsed := allUsedSGNames[_]\n\n\t# check if any resource references the security group:\n\tterraLib.associatedResourcesFromPreparsedReference(sgResource, sgResourceName, \"name\", sgNameUsed)\n}{\n\tsgNameUsed := allUsedSGNames[_]\n\tcontains(sgNameUsed, \".\")\n\tparts := split(sgNameUsed, \".\")\n\tcontains(parts[i], \"aws_security_group\")\n\tx := parts[i+1]\n\tterraLib.associatedResourcesFromPreparsedReference(sgResource, sgResourceName, \"name\", x)\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\n\tallUsedSGNames := { sgNames[_] | sgNames := allResourcesSecurityGroupNames[_] }\n\n\tresource := doc.resource.aws_security_group[securityGroupName]\n\tnot isSecurityGroupInUse(resource, securityGroupName, allUsedSGNames)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, securityGroupName),\n\t\t\"resourceType\": \"aws_security_group\",\n\t\t\"searchKey\": sprintf(\"aws_security_group[%s]\", [securityGroupName]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_security_group[%s]' should be used\", [securityGroupName]),\n\t\t\"keyActualValue\": sprintf(\"'aws_security_group[%s]' is not used\", [securityGroupName]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_security_group](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/security_group)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-7-9" {
  description              = "This rule checks whether the EKS Protection feature in Amazon GuardDuty is enabled.  \nThis rule fails if the `EKS_AUDIT_LOGS` status is disabled.  \nAmazon GuardDuty's EKS Protection feature enhances security by monitoring and detecting potential threats and anomalous activity within your EKS clusters. It is recommended to enable this feature to benefit from additional security monitoring for your Kubernetes workloads."
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty Detector EKS Protection should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"EKS_AUDIT_LOGS\"\n\nfeatureDisabled {\n\tupper(input.Features[feature].Name) == protection\n\tupper(input.Features[feature].Status) == \"DISABLED\"\n}\n\n\nresult = \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])\n"
  remediation_instructions = "Perform the following command to enable EKS Protection for GuardDuty via AWS CLI:\n\n```\naws guardduty update-member-detectors \\\n--detector-id {{detectorID}} \\\n--account-ids {{accountID}} \\\n--features '[{\"Name\": \"EKS_AUDIT_LOGS\", \"Status\": \"ENABLED\"}]'\n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
}


resource "wiz_cloud_configuration_rule" "op-exp-7-8" {
  description              = "This rule checks whether the Lambda Protection feature in Amazon GuardDuty is enabled.  \nThis rule fails if the `LAMBDA_NETWORK_LOGS` status is disabled.  \nEnabling Lambda Protection in GuardDuty enhances security by monitoring and providing findings on potential threats and anomalies in your Lambda environments. It is recommended to enable Lambda Protection to ensure comprehensive security monitoring."
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty Detector Lambda Protection should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"LAMBDA_NETWORK_LOGS\"\n\nfeatureDisabled {\n\tupper(input.Features[feature].Name) == protection\n\tupper(input.Features[feature].Status) == \"DISABLED\"\n}\n\n\nresult = \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])\n"
  remediation_instructions = "Perform the following command to enable Lambda Protection for GuardDuty via AWS CLI:\n\n```\naws guardduty update-member-detectors \\\n--detector-id {{detectorID}} \\\n--account-ids {{accountID}} \\\n--features '[{\"Name\": \"LAMBDA_NETWORK_LOGS\", \"Status\": \"ENABLED\"}]'\n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
}


resource "wiz_cloud_configuration_rule" "op-mon-3-1" {
  description              = "This rule checks whether the CloudTrail event is integrated with CloudWatch.  \nThis rule fails if the `LatestCloudWatchLogsDeliveryTime` is not set to a recent date, or if the `CloudWatchLogsRoleArn` field does not exist, or if one of these fields is set to `null`: `CloudWatchLogsLogGroupArn`, `latestLogDelivery`, `CloudWatchLogsRoleArn`.  \nCloudTrail is a web service that records API activity in your AWS account.\nCloudWatch is a monitoring service for AWS resources and applications. \nIntegrating CloudTrail events with CloudWatch events lets you leverage features to help you archive, analyze, and respond to changes in your AWS resources."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail event should be integrated with CloudWatch"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nlatestLogDelivery := input.CloudTrailStatus.LatestCloudWatchLogsDeliveryTime\nvalidTimeframe := 259200000000000 # 3 days\n\nresult = \"fail\" {\n\tis_null(input.CloudWatchLogsLogGroupArn)\n}{\n\tis_null(latestLogDelivery)\n}{\n\tis_null(input.CloudWatchLogsRoleArn)\n}{\n\tnot input.CloudWatchLogsRoleArn\n}{\n    time.parse_rfc3339_ns(latestLogDelivery) < time.now_ns() - validTimeframe\n}\n\ncurrentConfiguration := sprintf(\"'LatestCloudWatchLogsDeliveryTime' is not set to a recent date\", [])\nexpectedConfiguration := sprintf(\"CloudTrail should be integrated with CloudWatch\", [])"
  remediation_instructions = "Perform the following command to integrate CloudTrail events into CloudWatch via AWS CLI:    \n1. Use the following command to create a log group:  \n```  \naws logs create-log-group --log-group-name <logGroupName>  \n```  \n2. Use the following command to retrieve the log group ARN, you should use it in step 7:  \n```  \naws logs describe-log-groups  \n```  \n3. Create the JSON file that will contain the policy document, open a text editor and save the following policy contents in a file called assume_role_policy_document.json:  \n```  \n{  \n  \"Version\": \"2012-10-17\",  \n  \"Statement\": [  \n    {  \n      \"Sid\": \"\",  \n      \"Effect\": \"Allow\",  \n      \"Principal\": {  \n        \"Service\": \"cloudtrail.amazonaws.com\"  \n      },  \n      \"Action\": \"sts:AssumeRole\"  \n    }  \n  ]  \n}  \n```  \n4. Use the following command to create a role for CloudTrail that enables it to send events to the CloudWatch Logs log group:  \n```  \naws iam create-role --role-name <roleName> --assume-role-policy-document file://<assumeRolePath>.json  \n```  \n5. Create the following role policy document for CloudTrail to grant CloudTrail the permissions required to create a CloudWatch Logs log stream in the log group you specify, and to deliver CloudTrail events to that log stream:  \n```  \n{  \n  \"Version\": \"2012-10-17\",  \n  \"Statement\": [  \n    {  \n  \n      \"Sid\": <createLogStreamSid>,  \n      \"Effect\": \"Allow\",  \n      \"Action\": [  \n        \"logs:CreateLogStream\"  \n      ],  \n      \"Resource\": [  \n        \"arn:aws:logs:{{region}}:<accountId>:log-group:<logGroupName>:log-stream:<accountId>_CloudTrail_{{region}}*\"  \n      ]  \n  \n    },  \n    {  \n      \"Sid\": <putLogStreamSid>,  \n      \"Effect\": \"Allow\",  \n      \"Action\": [  \n        \"logs:PutLogEvents\"  \n      ],  \n      \"Resource\": [  \n        \"arn:aws:logs:{{region}}:<accountId>:log-group:<logGroupName>:log-stream:<accountId>_CloudTrail_{{region}}*\"  \n      ]  \n    }  \n  ]  \n}  \n```  \n6. Use the following command to apply the policy to the role:  \n```  \naws iam put-role-policy --role-name <roleName> --policy-name <policyName> --policy-document file://<rolePolicyDocument>.json  \n```  \n7. Use the following command to update the trail with the log group and role information:  \n```  \naws cloudtrail update-trail --name <logGroupName> --cloud-watch-logs-log-group-arn <logGroupArn> --cloud-watch-logs-role-arn <roleArn>  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tattributes := {\"CloudWatchLogsLogGroupArn\", \"CloudWatchLogsRoleArn\"}\n\tattr := attributes[a]\n\n\tnot common_lib.valid_key(resource.Properties, attr)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.%s' should be declared\", [name, attr]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.%s' is not declared\", [name, attr]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tcloudtrail := document.resource.aws_cloudtrail[name]\n\tattr := {\"cloud_watch_logs_role_arn\", \"cloud_watch_logs_group_arn\"}\n\tattribute := attr[a]\n\n\tnot common_lib.valid_key(cloudtrail, attribute)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrail, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s].%s should be defined and not null\", [name, attribute]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s].%s is undefined or null\", [name, attribute]),\n\t\t\"resourceTags\": object.get(cloudtrail, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudtrail](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudtrail)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_control" "op-exp-8-r1-7" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor disabling or scheduled deletion of AWS KMS keys.\n\nIt is recommended to set an alarm that will be triggered for every  'DisableKey' or 'ScheduleKeyDeletion' operation. Monitoring AWS KMS key configurations to detect undesired changes that can affect data access."
  enabled                   = false
  name                      = "Subscription with no CloudWatch monitoring for AWS KMS keys"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 7\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}



resource "wiz_cloud_configuration_rule" "op-acc-6-r7-2" {
  description              = "This rule checks whether the IAM user's credentials have been used in the past 45 days.  \nThis rule fails if the user has credentials enabled and did not log into the console or their access keys were not used in the past 45 days. Unnecessary credentials increase the window of opportunity for compromised accounts to be used.  \nIt is recommended that all credentials that have not been used for 45 or more days be disabled or removed."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM User credentials unused for 45 days or more should be disabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nnow_ns := time.now_ns()\ndays_45_ns := time.parse_duration_ns(\"1080h\") # 45 days\n\nunusedCredentials[credential] {\n\tnot now_ns - time.parse_rfc3339_ns(input.userCredentials.PasswordLastUsed) < days_45_ns\n\tlower(input.userCredentials.PasswordEnabled) == \"true\"\n\tcredential = \"console password\"\n}\n\nunusedCredentials[credential] {\n\tinput.userCredentials.PasswordLastUsed = \"N/A\"\n\tlower(input.userCredentials.PasswordEnabled) == \"true\"\n\tcredential = \"console password\"\n}\n\nunusedCredentials[credential] {\n\tnot now_ns - time.parse_rfc3339_ns(input.userCredentials.AccessKey1LastUsedDate) < days_45_ns\n\tlower(input.userCredentials.AccessKey1Active) == \"true\"\n\tcredential = \"access key 1\"\n}\n\nunusedCredentials[credential] {\n\tinput.userCredentials.AccessKey1LastUsedDate = \"N/A\"\n\tlower(input.userCredentials.AccessKey1Active) == \"true\"\n\tcredential = \"access key 1\"\n}\n\nunusedCredentials[credential] {\n\tinput.userCredentials.AccessKey2LastUsedDate = \"N/A\"\n\tlower(input.userCredentials.AccessKey2Active) == \"true\"\n\tcredential = \"access key 2\"\n}\n\nunusedCredentials[credential] {\n\tnot now_ns - time.parse_rfc3339_ns(input.userCredentials.AccessKey2LastUsedDate) < days_45_ns\n\tlower(input.userCredentials.AccessKey2Active) == \"true\"\n\tcredential = \"access key 2\"\n}\n\nresult = \"fail\" {\n\tnow_ns - time.parse_rfc3339_ns(input.CreateDate) > days_45_ns\n    count(unusedCredentials) > 0\n}\n\ncurrentConfiguration := concat(\"\",[\"User credentials have not been used in the past 45 days: \",concat(\", \", unusedCredentials)])\nexpectedConfiguration := \"User credentials unused for 45 days or more should be disabled or removed\""
  remediation_instructions = "Perform the following steps to disable access keys, disable console access, or delete the user via AWS CLI:\n\n### Disable access keys  \n1. Use the following command to list the access keys of the user:\n```\naws iam list-access-keys \\\n\t--user-name {{userName}}\n```\n2. Use the following command to disable the access keys.  \nCopy the `AccessKeyId` output of active access keys, and paste the value into the `access-key` parameter. If there is more than one, run the next command twice, once for each Key ID.  \n```\naws iam update-access-key \\\n\t--user-name {{userName}} \\\n\t--access-key <value> \\\n\t--status Inactive\n```\n>**Note**  \nOnce an access key is disabled, any application using it will not work until a new one is configured for it.\n\n### Disable console access  \nUse the following command to disable the user's console access:\n```\naws iam delete-login-profile \\\n\t--user-name {{userName}}\n```\n\n### Delete user  \n```\naws iam delete-user \\\n\t--user-name {{userName}}\n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["user"]
}


resource "wiz_cloud_configuration_rule" "mp-com-4-2" {
  description              = "This rule checks whether VPC subnets allow automatic public IP assignment.  \nThis rule fails if the `MapPublicIpOnLaunch` field is `true`.  \nAssigning a public IP to resources in the subnet automatically upon launch can expose them to the internet.\nIt is recommended to disable this option, as it can cause unintentional resource exposure."
  enabled                  = true
  function_as_control      = false
  name                     = "VPC Subnets should not allow automatic public IP assignment"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" { input.MapPublicIpOnLaunch == true }"
  remediation_instructions = "Perform the following command in order to disable automatic public IP assignment via AWS CLI:  \n```  \naws ec2 modify-subnet-attribute --subnet-id {{subnetID}} --no-map-public-ip-on-launch  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["subnet"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::EC2::Subnet\"\n\tresource.Properties.MapPublicIpOnLaunch == true\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.MapPublicIpOnLaunch\", [cloudFormationLib.getPath(path),name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.MapPublicIpOnLaunch' should be false\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.MapPublicIpOnLaunch' is true\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_subnet[name]\n\n\tresource.map_public_ip_on_launch == true\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_subnet\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_subnet[%s].map_public_ip_on_launch\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_subnet[%s].map_public_ip_on_launch should be set to false or undefined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_subnet[%s].map_public_ip_on_launch is set to true\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_subnet\", name, \"map_public_ip_on_launch\"], []),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"true\",\n\t\t\t\"after\": \"false\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_subnet](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/subnet)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-mon-3-r2-1" {
  description              = "This rule checks whether a CloudFormation Stack has drifted from its expected template configuration.  \nThis rule fails if `StackDriftStatus` is set to `DRIFTED`.  \nDrift detection in AWS CloudFormation is used to detect whether the actual configuration of stack resources differs, or has drifted, from the expected configuration. It is important to ensure that the CloudFormation stacks are in sync with their template configurations to maintain consistency and to avoid unintended changes that could lead to security vulnerabilities or application issues."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudFormation Stack should not drift from the template configuration"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"fail\" {\n\tupper(input.DriftInformation.StackDriftStatus) == \"DRIFTED\"\n}\n\ncurrentConfiguration := \"'StackDriftStatus': DRIFTED'\"\nexpectedConfiguration := \"'StackDriftStatus' should not be 'DRIFTED'\""
  remediation_instructions = "Perform the following command to detect drift for the CloudFormation stack via AWS CLI:  \n1. Use the following command to review the resources that have drifted:\n```\naws cloudformation describe-stack-resource-drifts \\\n\t--stack-name {{stackName}} \\\n\t--stack-resource-drift-status-filters MODIFIED DELETED\n```\n2. Use the following command to update the stack:\n```\naws cloudformation update-stack \\\n    --stack-name {{stackName}}\n```\n>**Note**  \nIt may be easier to view the drift and update the stack via the AWS Portal. For more information see the [AWS guide](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/detect-drift-stack.html)."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["cloudformation#stack"]
}


resource "wiz_cloud_configuration_rule" "mp-com-1-3" {
  description              = "This rule checks if the EC2 Security Group has an inbound rule allowing all protocols.  \nThis rule will fail if there is at least one rule that has `IpPermissions` with `IpProtocol: -1`.  \nIt skips security groups that do not have any inbound rules.  \nAllowing all protocols can increase opportunities for malicious activity and the risk of data loss.  \nIt is recommended to configure your Security Group inbound rules to limit ingress traffic to the specific protocols required.\n>**Note**  \n>Cloud Configuration Rule `VPC-088` checks the security group *outbound* rules that allow all protocols."
  enabled                  = true
  function_as_control      = false
  name                     = "EC2 Security Group inbound rules should not allow all protocols"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"skip\" {\n\tnot input.IpPermissions\n} else = \"fail\" {\n\tinput.IpPermissions[_].IpProtocol == \"-1\"\n}\n\ncurrentConfiguration := \"Inbound rules allow all protocols\"\nexpectedConfiguration := \"All inbound rules should specify specific protocols\"\n"
  remediation_instructions = "Perform the following commands to modify or delete the Security Group rule via AWS CLI:\n\nUse the following command to modify the non-compliant rule(s):\n```\naws ec2 modify-security-group-rules \\\n\t--group-id {{groupId}} \\\n\t--security-group-rules SecurityGroupRuleId=<SecurityGroupRuleId>,SecurityGroupRule=\"{FromPort=<FromPort>,ToPort=<ToPort>,IpProtocol=<IpProtocol>,CidrIpv4=<CidrIp>}\"  \n```\n\nAlternatively, use the following command to delete the non-compliant rule(s):\n```\naws ec2 revoke-security-group-ingress \\\n\t--group-id {{groupId}} \\\n\t--security-group-rule-ids <value>\n```\n>**Note**  \n>You can find your rule ID on the Security Group page in the AWS Console or by using the command `describe-security-group-rules` on the AWS CLI."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["securityGroup"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::EC2::SecurityGroupIngress\"\n\n\tproperties := resource.Properties\n\n\tproperties.IpProtocol == -1\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.IpProtocol\", [cloudFormationLib.getPath(path),name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.IpProtocol should not be set to -1\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.IpProtocol is set to -1\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::EC2::SecurityGroup\"\n\n\tproperties := resource.Properties\n\n\tproperties.SecurityGroupIngress[index].IpProtocol == -1\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties.SecurityGroupIngress.IpProtocol\", [cloudFormationLib.getPath(path),name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.SecurityGroupIngress[%d].IpProtocol should not be set to -1\", [name, index]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.SecurityGroupIngress[%d].IpProtocol is set to -1\", [name, index]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport future.keywords.in\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\ntraffic := \"ingress\"\nallProtocols := {\"all\", \"-1\", -1}\n\ncheckRulesArrayOrObject(rules) {\n\tis_object(rules)\n\tlower(rules.protocol) in allProtocols\n}{\n\tis_array(rules)\n\tlower(rules[_].protocol) in allProtocols\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_security_group[name]\n\n\tcheckRulesArrayOrObject(resource[traffic])\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"aws_security_group\",\n\t\t\"searchKey\": sprintf(\"aws_security_group[%s].%s\", [name, traffic]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyActualValue\": sprintf(\"aws_security_group[%s] %s rule allows all protocols ('all', '-1')\", [name, traffic]),\n\t\t\"keyExpectedValue\": sprintf(\"aws_security_group[%s] %s rule should not allow all protocols\", [name, traffic]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[j].resource.aws_security_group[name]\n\trule := input.document[i].resource.aws_security_group_rule[ruleName]\n\t\n\tterraLib.associatedResources(resource, rule, name, ruleName, \"id\", \"security_group_id\")\n\n\tlower(rule.type) == traffic\n\tlower(rule.protocol) in allProtocols\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"aws_security_group\",\n\t\t\"searchKey\": sprintf(\"aws_security_group_rule[%s].protocol\", [ruleName]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyActualValue\": sprintf(\"aws_security_group_rule[%s] allows all protocols ('all', '-1')\", [ruleName]),\n\t\t\"keyExpectedValue\": sprintf(\"aws_security_group_rule[%s] should not allow all protocols\", [ruleName]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[j].resource.aws_security_group[name]\n\trule := input.document[i].resource.aws_vpc_security_group_ingress_rule[ruleName]\n\t\n\tterraLib.associatedResources(resource, rule, name, ruleName, \"id\", \"security_group_id\")\n\n\tlower(rule.ip_protocol) in allProtocols\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"aws_security_group\",\n\t\t\"searchKey\": sprintf(\"aws_vpc_security_group_ingress_rule[%s].ip_protocol\", [ruleName]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyActualValue\": sprintf(\"aws_vpc_security_group_ingress_rule[%s] allows all protocols ('all', '-1')\", [ruleName]),\n\t\t\"keyExpectedValue\": sprintf(\"aws_vpc_security_group_ingress_rule[%s] should not allow all protocols\", [ruleName]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_security_group](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/security_group), [aws_security_group_rule](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/security_group_rule), [aws_vpc_security_group_ingress_rule](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc_security_group_ingress_rule)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-4-8" {
  description              = "This rule checks whether the IAM policy (customer-managed or inline) allows KMS decryption actions on all KMS keys.  \nThis rule fails if the policy contains at least one statement where:  \n* `Effect` is `Allow`\n* `Resource` is `*`\n* `Action` contains at least one of: `kms:Decrypt`, `kms:ReEncryptFrom`, `kms:*`\n* `Condition` is null or does not exist\n\nWith AWS KMS, you control who can use your KMS keys and gain access to your encrypted data. IAM policies define which actions an identity (user, group, or role) can perform on which resources. Following security best practices, it is recommended that you follow the principle of least privilege (PoLP). In other words, you should grant identities the `kms:Decrypt` or `kms:ReEncryptFrom` permissions only for the keys that are required to perform a task. \nIt is recommended to adopt the PoLP to reduce the risk of unintended disclosure of your data.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "IAM policy should not allow decryption actions on all KMS keys"
  opa_policy               = "package wiz\n\nimport future.keywords.in\n\ndefault result := \"pass\"\n\niamPolicy := policy {\n# For parsed policies:\n\tinput.Version\n\tpolicy := input\n}{\n# For policies that require parsing:\n\tpolicy := json.unmarshal(input)\n}\n\n# While '*' also allows all KMS actions, it is intentionally not added to the logic.\n# Cloud Configuration Rule 'IAM-025' detects identity-based policies that allow\n# all actions on all resources.\n\ndecryptionActions := {\"kms:*\", \"kms:reencryptfrom\", \"kms:decrypt\"}\n\nkmsDecryptionActions(statement) {\n\tlower(statement.Action) in decryptionActions\n}{\n\tlower(statement.Action[_]) in decryptionActions\n}\n\noverlyPermissiveResources(statement) {\n\tstatement.Resource == \"*\"\n}{\n\tstatement.Resource[_] == \"*\"\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\nstatementAllowsAllKmsActions[statement] {\n\tstatement := iamPolicy.Statement[_]\n\tkmsDecryptionActions(statement)\n\toverlyPermissiveResources(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n}\n\nresult := \"fail\" {\n\tcount(statementAllowsAllKmsActions) > 0\n}\n\ncurrentConfiguration := \"Policy allows KMS decryption actions for all keys\"\nexpectedConfiguration := \"Policy should not allow KMS decryption actions for all keys\""
  remediation_instructions = "Perform the following commands to delete or modify the IAM policy via AWS CLI:    \n1. First, use the following command to list the IAM entities (Users\\Roles\\Groups) that have the policy attached (if any):  \n```  \naws iam list-entities-for-policy \\\n    --policy-arn <value>  \n```  \n* If the policy **is not attached** to IAM entities - proceed to 2a.    \n* If the policy **is attached** to one or more IAM entities - proceed to 2b.    \n\n2a. As this policy is not in use, it is recommended to delete it. Use the following command to delete the policy:  \n```  \naws iam delete-policy \\\n    --policy-arn <value>  \n```  \n2b. It is recommended to edit the policy and remove the permissive statement.    \nFirst, use the following command to view the policy and locate the overly-permissive statement/s.    \n**Note:** You can also view the policy in the native object JSON in Wiz.  \n```  \naws iam get-policy \\\n    --policy-arn <value> \\\n    --version-id <value>  \n```  \nIf you are not sure what the policy version id is, use the following command to check. It is the 'DefaultVersionId' in the output:  \n```  \naws iam get-policy-version \\\n    --policy-arn <value>  \n```  \nNext, create a new policy in a JSON file locally which replaces the wildcards `*` with the required actions and resources only.    \nUse the following command to create a new policy version with the new policy created and set it as default:  \n```  \naws iam create-policy-version \\\n    --policy-arn <value> \\\n    --policy-document file://<NewPolicyVersion.json> \\\n    --set-as-default  \n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["customerManagedPolicy", "inlinePolicy"]
}


resource "wiz_cloud_configuration_rule" "mp-s-4-1" {
  description              = "This rule checks whether the Auto Scaling Group can deploy multiple instance types across multiple Availability Zones.  \nThis rule fails if there isn't more than one overridden instance type in the `MixedInstancesPolicy`.  \nThis rule also fails if there isn't more than one Availability zone configured.  \nThis rule skips groups without a mixed instance policy configured.\nUsing multiple instance types allows for more flexibility and resilience in your infrastructure. \nThis way, another instance type can be launched if there is insufficient instance capacity in the chosen Availability Zones.  \nDistributing instances across multiple Availability Zones can protect your applications from the failure of a single location and help ensure high availability."
  enabled                  = true
  function_as_control      = false
  name                     = "Auto Scaling Group should use multiple instance types in multiple availability zones"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nMultipleInstanceTypesAndMultiAZ {\n\tinstanceTypes := [type | type := input.Group.MixedInstancesPolicy.LaunchTemplate.Overrides[_].InstanceType]\n\tcount(instanceTypes) > 1\n\tcount(input.Group.AvailabilityZones) > 1\n}\n\nusesLaunchConfiguration {\n\tnot is_null(input.Group.LaunchConfigurationName)\n}\n\nresult = \"skip\"{\n\tis_null(input.Group.MixedInstancesPolicy)\n} else = \"fail\" {\n\tnot MultipleInstanceTypesAndMultiAZ\n}\n\ncurrentConfiguration := \"Auto Scaling group is not configured with multiple instance types in multiple Availability Zones\"\nexpectedConfiguration := \"Auto Scaling groups should use multiple instance types in multiple Availability Zones\"\n"
  remediation_instructions = "Perform the following commands to update the Auto Scaling group to use multiple instance types in multiple Availability Zones via AWS CLI:\n\n1. Use the following command to update the Auto Scaling group to use multiple Availability Zones :\n```\naws autoscaling update-auto-scaling-group \\\n    --auto-scaling-group-name {{autoScalingGroupName}} \\\n    --vpc-zone-identifier <subentID1> <subentID2> <subentID3> \\\n    --region {{Region}}\n   ```\n   \n>**Note**  \nThis command will override the network configuration settings, instead of adding to them.\nEnsure that the subnets you choose are in different Availability Zones.\n\n2. Follow [this guide](https://docs.aws.amazon.com/autoscaling/ec2/userguide/mixed-instances-groups-set-up-overview.html) to update the Auto Scaling group to use multiple instance types."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["autoScalingGroup"]
}


resource "wiz_cloud_configuration_rule" "mp-si-2-6" {
  description              = "This rule checks whether the AWS region enforces encryption of newly created EBS volumes.  \nThis rule fails if `EbsEncryptionByDefault` is set to `false`.  \nEBS volume encryption is a region-specific setting. When enabled, newly created volumes are automatically encrypted, and the encryption of existing volumes or snapshots in the region cannot be disabled. Enabling the EBS encryption setting ensures that all new volumes are automatically encrypted.  \nIt is recommended to enable default EBS encryption in all the AWS regions that you use. Remember that you can set the CCR to ignore regions that are not in use."
  enabled                  = true
  function_as_control      = false
  name                     = "AWS default EBS encryption should be enabled in the region"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\ndefaultEbsEncryption := input.EbsEncryptionByDefault\n\nresult = \"fail\" {\n\tdefaultEbsEncryption == false\n}\n\ncurrentConfiguration := sprintf(\"'EbsEncryptionByDefault: %v'\", [defaultEbsEncryption])\nexpectedConfiguration := \"'EbsEncryptionByDefault' should be set to 'true'\""
  remediation_instructions = "Perform the following command to enable default EBS encryption for the AWS region via AWS CLI:\n```\naws ec2 enable-ebs-encryption-by-default \\\n\t--region {{region}}\n```\n>**Note**  \n>Enabling encryption by default has no effect on the encryption status of your existing volumes."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["region"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.resource.aws_ebs_encryption_by_default[name]\n\tresource.enabled == false\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_ebs_encryption_by_default\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_ebs_encryption_by_default[%s].enabled\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_ebs_encryption_by_default\", name, \"enabled\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'aws_ebs_encryption_by_default.enabled' should be 'true'\",\n\t\t\"keyActualValue\": \"'aws_ebs_encryption_by_default.enabled' is 'false'\",\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_ebs_encryption_by_default](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ebs_encryption_by_default)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_control" "op-exp-8-r1-12" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor unauthorized API calls.\n\nIt is recommended to set an alarm that will be triggered for every unauthorized API call. Monitoring unauthorized API calls helps help detect and respond to unapproved actions."
  enabled                   = false
  name                      = "Subscription with no CloudWatch monitoring for unauthorized API calls"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 12\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_control" "op-acc-6-r2-3" {
  description               = "This user account has admin privileges in the environment and does not require multi-factor authentication when logging in. \n\nHighly privileged users are a greater risk to the environment when compromised. Therefore, an attacker who manages to access the users credentials could use the high privileges to disrupt the environment.  "
  enabled                   = true
  name                      = "User account with admin privileges and MFA disabled"
  project_id                = "*"
  query                     = "{\"as\":\"scoped_entity\",\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ENTITLES\"}],\"with\":{\"blockExpanded\":true,\"blockName\":\"Has Admin Permissions\",\"relationships\":[{\"type\":[{\"type\":\"ALLOWS\"}],\"with\":{\"aggregate\":true,\"select\":true,\"type\":[\"ACCESS_ROLE_PERMISSION\"],\"where\":{\"accessTypes\":{\"EQUALS\":[\"Admin\"]}}}},{\"type\":[{\"type\":\"ALLOWS_ACCESS_TO\"}],\"with\":{\"as\":\"scoped_project\",\"select\":true,\"type\":[\"SUBSCRIPTION\",\"CLOUD_ORGANIZATION\",\"KUBERNETES_CLUSTER\",\"NAMESPACE\"]}}],\"type\":[\"IAM_BINDING\"],\"where\":{\"accessTypes\":{\"EQUALS\":[\"Admin\"]}}}}],\"select\":true,\"type\":[\"USER_ACCOUNT\"],\"where\":{\"accountEnabled\":{\"EQUALS\":true},\"hasAdminPrivileges\":{\"EQUALS\":true},\"hasMfa\":{\"EQUALS\":false},\"inactiveInLast90Days\":{\"EQUALS\":false},\"nativeType\":{\"EQUALS\":[\"rootUser\",\"user\"]},\"passwordEnabled\":{\"EQUALS\":true}}}"
  resolution_recommendation = "### Protect highly privileged principals\n* Use the least privilege principle when assigning permissions, meaning that each account is assigned the exact permissions that it needs to function properly. When assigning permissions, avoid wild-card permissions.\n* To find unused permissions assigned to the principal, use the Excessive Permissions object on the Security Graph.\n* Minimize the attack surface of principals with sensitive permissions by remediating all Issues associated to them.\n* Enable MFA for users with sensitive permissions if possible."
  scope_query               = "{\"select\":true,\"type\":[\"USER_ACCOUNT\"]}"
  security_sub_categories   = []
  severity                  = "MEDIUM"
}


resource "wiz_cloud_configuration_rule" "op-exp-10-3" {
  description              = "This rule checks whether the CloudTrail log files are not encrypted at rest with a KMS key (SSE-KMS).  \nThis rule fails if `KmsKeyId` is `null`.  \nWhen you use server-side encryption with AWS KMS (SSE-KMS), you can use the default AWS-managed key, or you can specify a customer-managed key that you have already created (recommended).  \nTo encrypt the CloudTrail logs with AWS KMS customer-managed key, create an AWS KMS customer-managed key or use an existing one. The AWS KMS key and the S3 bucket that stores the logs must be in the same region."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail logs should be encrypted with SSE-KMS"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tis_null(input.KmsKeyId)\n}\n\ncurrentConfiguration := \"'KmsKeyId' is null\"\nexpectedConfiguration := \"KMS encryption key should be configured\""
  remediation_instructions = "Perform the following to configure CloudTrail to use SSE-KMS:  \n1. Sign in to the AWS Management Console and open the CloudTrail [console](https://console.aws.amazon.com/cloudtrail).  \n2. In the left navigation pane, choose Trails.  \n3. Click on a Trail.  \n4. Under the S3 section click on the edit button (pencil icon).  \n5. Click Advanced.  \n6. Select an existing CMK from the KMS key Id drop-down menu.  \n7. Click Save.  \n8. You will see a notification message stating that you need to have decrypt permissions on the specified KMS key to decrypt log files.  \n9. Click Yes.\n>**Note**  \n>* Ensure the CMK is located in the same region as the S3 bucket.  \n>* You will need to apply a KMS Key policy on the selected CMK in order for CloudTrail as a service to encrypt and decrypt log files using the CMK provided. Steps are provided [here](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create-kms-key-policy-for-cloudtrail.html) for editing the selected CMK Key policy.\n>* Customer created keys incur an additional cost. Click [here](https://aws.amazon.com/kms/pricing/) for more information."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tkmsKeyID := resource.Properties.KMSKeyId\n\tkmsKeyID == \"\"\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KMSKeyId' should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.KMSKeyId' is undefined or null\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tnot common_lib.valid_key(resource.Properties, \"KMSKeyId\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KMSKeyId' should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.KMSKeyId' is undefined or null\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tcloudtrail := input.document[i].resource.aws_cloudtrail[name]\n\tnot common_lib.valid_key(cloudtrail, \"kms_key_id\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrail, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s].kms_key_id should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s].kms_key_id is undefined or null\", [name]),\n\t\t\"resourceTags\": object.get(cloudtrail, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudtrail](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudtrail)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "mp-com-3-3" {
  description              = "This rule checks whether the Cloudfront distribution allows SSLv3 or TLSv1 in the communication to clients or the origin server.  \nUsing insecure and deprecated TLS protocols could make the connections vulnerable to exploits such as 'POODLE', which allows a malicious actor to eavesdrop on Cloudfront traffic by implementing a man-in-the-middle attack."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudFront distribution should not allow insecure TLS protocols"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\ninsecureProtocols := {\"SSLv3\", \"TLSv1\", \"TLSv1.1_2016\", \"TLSv1_2016\"}\ndistributionConfig := input.distribution.DistributionConfig\n\nresult = \"fail\" {\n    insecureProtocols[distributionConfig.Origins.Items[_].CustomOriginConfig.OriginSslProtocols.Items[_]]\n}{\n\tinsecureProtocols[distributionConfig.ViewerCertificate.MinimumProtocolVersion]\n}{\n\tdistributionConfig.ViewerCertificate.CloudFrontDefaultCertificate == true\n}\n\ncurrentConfiguration := \"The CloudFront distribution supports insecure TLS protocol\"\nexpectedConfiguration := \"TLS1.2 or higher should be supported\""
  remediation_instructions = "Perform the following commands to update the CloudFront Distribution TLS version via AWS CLI:\n\n1. Use the following command to get the `ETag` and save it for further steps:\n```\nexport ETag=$(aws cloudfront get-distribution-config --id {{distributionID}} --query='ETag' --output=text)  \n```\n\n2. Use the following command to get the configuration of the CloudFront distribution and write it to a new file: \n```\naws cloudfront get-distribution-config --id {{distributionID}} --query='DistributionConfig' > DistributionConfig.json  \n```\n3. Edit the ***DistributionConfig.json*** file. Set the `MinimumProtocolVersion` value to `TLSv1.2_2021`.\n\n4. Use the following command:\n```\naws cloudfront update-distribution --id {{distributionID}} --distribution-config file://DistributionConfig.json --if-match $ETag\n```\n5. Optional - Use the following command in order to delete the ***DistributionConfig.json*** file:\n```\nrm DistributionConfig.json\n```\n>**Note**  \n>If you receive an error when trying to update the distribution, you can troubleshoot the error [here](https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_UpdateDistribution.html#API_UpdateDistribution_Errors)."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["cloudfront"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as commonLib\nimport data.generic.cloudformation as cloudFormationLib\n\ninsecureProtocols := {\"sslv3\", \"tlsv1\", \"tlsv1.1_2016\", \"tlsv1_2016\"}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tlower(resource.Type) == \"aws::cloudfront::distribution\"\n\tnot commonLib.valid_key(resource.Properties.ViewerCertificate, \"CloudFrontDefaultCertificate\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"AWS::CloudFront::Distribution\",\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.ViewerCertificate\", [name]),\n\t\t\"searchLine\": commonLib.build_search_line([\"Resources\", name, \"Properties\", \"ViewerCertificate\"], []),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.ViewerCertificate.CloudFrontDefaultCertificate should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.ViewerCertificate.CloudFrontDefaultCertificate is undefined\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tlower(resource.Type) == \"aws::cloudfront::distribution\"\n\tresource.Properties.ViewerCertificate.CloudFrontDefaultCertificate == true\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"AWS::CloudFront::Distribution\",\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.ViewerCertificate.CloudFrontDefaultCertificate\", [name]),\n\t\t\"searchLine\": commonLib.build_search_line([\"Resources\", name, \"Properties\", \"ViewerCertificate\", \"CloudFrontDefaultCertificate\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.ViewerCertificate.CloudFrontDefaultCertificate should be false\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.ViewerCertificate.CloudFrontDefaultCertificate is true\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tlower(resource.Type) == \"aws::cloudfront::distribution\"\n\tresource.Properties.ViewerCertificate.CloudFrontDefaultCertificate == false\n\tinsecureProtocols[lower(resource.Properties.ViewerCertificate.MinimumProtocolVersion)]\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"resourceType\": \"AWS::CloudFront::Distribution\",\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.ViewerCertificate.MinimumProtocolVersion\", [name]),\n\t\t\"searchLine\": commonLib.build_search_line([\"Resources\", name, \"Properties\", \"ViewerCertificate\", \"MinimumProtocolVersion\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.ViewerCertificate.MinimumProtocolVersion is TLSv1.1 or TLSv1.2\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.ViewerCertificate.MinimumProtocolVersion isn't TLSv1.1 or TLSv1.2\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\ninsecureProtocols := {\"sslv3\", \"tlsv1\", \"tlsv1.1_2016\", \"tlsv1_2016\"}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudfront_distribution[name]\n\tviewerCertificate := terraLib.getValueArrayOrObject(resource.viewer_certificate)\n\tnot terraLib.validKey(viewerCertificate, \"cloudfront_default_certificate\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudfront_distribution\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"resource.aws_cloudfront_distribution[%s].viewer_certificate\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_cloudfront_distribution\", name, \"viewer_certificate\"], []),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"resource.aws_cloudfront_distribution[%s].viewer_certificate.cloudfront_default_certificate should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"resource.aws_cloudfront_distribution[%s].viewer_certificate.cloudfront_default_certificate is undefined\", [name]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudfront_distribution[name]\n\tviewerCertificate := terraLib.getValueArrayOrObject(resource.viewer_certificate)\n\tviewerCertificate.cloudfront_default_certificate == true\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudfront_distribution\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"resource.aws_cloudfront_distribution[%s].viewer_certificate.cloudfront_default_certificate\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_cloudfront_distribution\", name, \"viewer_certificate\", \"cloudfront_default_certificate\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"resource.aws_cloudfront_distribution[%s].viewer_certificate.cloudfront_default_certificate should be false\", [name]),\n\t\t\"keyActualValue\": sprintf(\"resource.aws_cloudfront_distribution[%s].viewer_certificate.cloudfront_default_certificate is true\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"true\",\n\t\t\t\"after\": \"false\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudfront_distribution[name]\n\tviewerCertificate := terraLib.getValueArrayOrObject(resource.viewer_certificate)\n\tviewerCertificate.cloudfront_default_certificate == false\n\tinsecureProtocols[lower(viewerCertificate.minimum_protocol_version)]\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudfront_distribution\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"resource.aws_cloudfront_distribution[%s].viewer_certificate.minimum_protocol_version\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_cloudfront_distribution\", name, \"viewer_certificate\", \"minimum_protocol_version\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"resource.aws_cloudfront_distribution[%s].viewer_certificate.minimum_protocol_version should start with TLSv1.1 or TLSv1.2\", [name]),\n\t\t\"keyActualValue\": sprintf(\"resource.aws_cloudfront_distribution[%s].viewer_certificate.minimum_protocol_version doesn't start with TLSv1.1 or TLSv1.2\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": sprintf(\"%s\", [viewerCertificate.minimum_protocol_version]),\n\t\t\t\"after\": \"TLSv1.2\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\n"
    remediation_instructions = "resource \"aws_cloudfront_distribution\" \"example_cloudfront_distribution\" {\n  viewer_certificate {\n    minimum_protocol_version = \"TLSv1.2_2019\"\n  }\n}"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-10-2" {
  description              = "This rule checks if the CloudWatch Log Group is encrypted using KMS.  \nThis rule fails if `KmsKeyId` is `null`.  \nLog group data is always encrypted in CloudWatch Logs. By default, CloudWatch Logs uses server-side encryption for the log data at rest. As an alternative, you can use AWS Key Management Service for this encryption. If you do, the encryption is done using a KMS customer-managed key. Encryption using KMS is enabled at the log group level, by associating a key with a log group, either when you create the log group or after it exists.  \nIt is recommended to encrypt the log group with a KMS key."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudWatch Log Group should be encrypted using KMS"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tis_null(input.KmsKeyId)\n}\n\ncurrentConfiguration := \"'KmsKeyId': 'null'\"\nexpectedConfiguration := \"'KmsKeyId' should not be 'null'\""
  remediation_instructions = "Perform the following command to encrypt the CloudWatch Log Group with a KMS customer-managed key via AWS CLI:\n```\naws logs associate-kms-key \\\n\t--log-group-name {{logGroupName}} \\\n\t--kms-key-id <key-arn>\n```\n>**Note**  \n>The command above assumes you already have a KMS key for the log group. If you do not, follow the steps [here](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/encrypt-log-data-kms.html#create-cmk) first to create one."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["logs#loggroup"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n    resource := input.document[i].Resources[name]\n    lower(resource.Type) == \"aws::logs::loggroup\"\n    not common_lib.valid_key(resource.Properties, \"KmsKeyId\")\n\n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": \"AWS::Logs::LogGroup\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n        \"issueType\": \"MissingAttribute\",\n        \"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' should be defined\", [name]),\n        \"keyActualValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' is not defined\", [name]),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}\n\nWizPolicy[result] {\n    resource := input.document[i].Resources[name]\n    lower(resource.Type) == \"aws::logs::loggroup\"\n    common_lib.valid_key(resource.Properties, \"KmsKeyId\")\n    resource.Properties.KmsKeyId == \"\"\n\n    result := {\n        \"documentId\": input.document[i].id,\n        \"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n        \"resourceType\": \"AWS::Logs::LogGroup\",\n        \"searchKey\": sprintf(\"Resources.%s.Properties.KmsKeyId\", [name]),\n        \"issueType\": \"IncorrectValue\",\n        \"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' should not be empty\", [name]),\n        \"keyActualValue\": sprintf(\"'Resources.%s.Properties.KmsKeyId' is empty\", [name]),\n        \"resourceTags\": cloudFormationLib.getCFTags(resource),\n    }\n}"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_cloudwatch_log_group[name]\n\tnot common_lib.valid_key(resource, \"kms_key_id\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_cloudwatch_log_group\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudwatch_log_group[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": \"Attribute 'kms_key_id' should be set\",\n\t\t\"keyActualValue\": \"Attribute 'kms_key_id' is undefined\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudwatch_log_group](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudwatch_log_group)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-4-13" {
  description              = "This rule checks if the EC2 Instance is managed by AWS Systems Manager (SSM) and the agent is online.  \nThis rule fails if `SsmInstanceInformation` is `null` or if `PingStatus` is not `Online`.  \nAWS Systems Manager is a management service that helps you automatically collect software inventory, apply OS patches, create system images, and configure Windows and Linux operating systems. These capabilities help you define and track system configurations, prevent drift, and maintain software compliance of your EC2 and on-premises configurations. By using SSM to manage EC2 instances, you can simplify resource and application management, shorten the time to detect and resolve operational problems, and make it easier to operate and manage your infrastructure at scale.  \nIt is recommended to manage EC2 instances with SSM for improved operational efficiency, security, and compliance."
  enabled                  = true
  function_as_control      = false
  name                     = "EC2 Instance should be managed by online SSM agent"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\ninstanceManagedByOnlineSsmAgent {\n\tlower(input.SsmInstanceInformation.PingStatus) == \"online\"\n}\n\nresult := \"fail\" {\n\tnot instanceManagedByOnlineSsmAgent\n}\n\ncurrentConfiguration := \"'SsmInstanceInformation': 'null' or 'PingStatus' is not 'Online'\"\nexpectedConfiguration := \"EC2 instance should be managed by SSM with 'PingStatus: Online'\""
  remediation_instructions = "For instructions on installing an SSM Agent on the EC2 Instance, see the [AWS guide](https://docs.aws.amazon.com/systems-manager/latest/userguide/manually-install-ssm-agent-linux.html).\n\nEC2 Instance Platform Details: `{{platformDetails}}`."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["virtualMachine"]
}


resource "wiz_cloud_configuration_rule" "mp-info-6-1" {
  description              = "This rule checks if the Backup Plan Rule includes a DynamoDB Table resource.  \nThis rule fails if `Selections.BackupSelection.Resources` includes at least one `arn:aws:dynamodb` resource or `*` - indicating that all resources are included. It does not take into account any other factors such as conditions, tags, schedule settings, etc.  \nYou can view the resources included in the plan rule and its settings by inspecting the resource JSON in Wiz under `Selections`.\n>**Note**  \nThis rule is informational and does not indicate a misconfiguration."
  enabled                  = true
  function_as_control      = false
  name                     = "Backup Plan Rule includes DynamoDB resources"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"fail\" {\n\tstartswith(input.Selections[_].BackupSelection.Resources[_], \"arn:aws:dynamodb\")\n}{\n\tinput.Selections[_].BackupSelection.Resources[_] == \"*\"\n}\n\ncurrentConfiguration := \"At least one DynamoDB resource is included in the backup plan rule\"\nexpectedConfiguration := \"This rule is informational and does not indicate a misconfiguration\"\n"
  remediation_instructions = "Perform the following steps to create a new backup plan rule via AWS CLI:\n\n1. If you do not already have a Backup Plan that you want to use, you can create one using the command below, otherwise, skip to the next step.  \n1a. Use this template to create a JSON file with your required Backup Plan configuration:\n```\n{\n  \"BackupPlan\":{\n    \"BackupPlanName\":\"test-plan\",\n    \"Rules\":[\n      {\n        \"RuleName\":<\"rule-name\">,\n        \"TargetBackupVaultName\":<\"vault-name>\",\n        \"ScheduleExpression\":<\"cron(0 1 ? * * *)>\",\n        \"ScheduleExpressionTimezone\":<\"America/Los_Angeles\">,\n        \"StartWindowMinutes\":<value>, // Value is integer in minutes\n        \"CompletionWindowMinutes\":<value>, // Value is integer in minutes\n        \"Lifecycle\":{\n          \"DeleteAfterDays\":<value>, // Value is integer in days\n        }\n      }\n    ]\n  }\n}\n```\nStore your JSON document locally with a name you choose.\n\n1b. Use the following command to create the new Backup Plan:\n```\naws backup create-backup-plan --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```\n\n2. In this step we will assign resources to the Backup Plan.  \n2a. Use this template to create a JSON file with your required plan rule configuration:\n```\n{\n  \"BackupPlanId\":<\"BACKUP-PLAN-ID\">, // The plan ID created in the previous command\n  \"BackupSelection\":{\n    \"SelectionName\":<\"selection-name\">, \n    \"IamRoleArn\":<\"arn:aws:iam::ACCOUNT-ID:role/IAM-ROLE-ARN\">,\n    \"Resources\":[\n      <\"arn:aws:ec2:*:*:instance/*\">,\n    ]\n  }\n}\n```\nFor more JSON examples, click [here](https://docs.aws.amazon.com/aws-backup/latest/devguide/assigning-resources.html#assigning-resources-json).  \nStore your JSON document locally with a name you choose.\n\n2b. Use the following command to create the new Backup Plan Rule:\n```\naws backup create-backup-selection --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "INFORMATIONAL"
  target_native_types      = ["backup#backuprule"]
}


resource "wiz_cloud_configuration_rule" "op-acc-4-7" {
  description              = "This rule checks whether the IAM Role's inline policy allows PassRole permission across all resources without a condition.  \nThis rule fails if the role inline policy contains at least one `Statement` that includes:\n* `Effect` is set to `Allow`\n* `Action` contains `iam:PassRole` or a wildcard containing the action (`*`, `iam:*`)\n* `Resource` is set to a wildcard (`*`)\n* `Condition` is `null` or does not exist\n\nTo pass a role (and its permissions) to an AWS service, a user must have permission to pass the role to the service. This helps administrators ensure that only approved users can configure a service with a role that grants permissions. To allow a user to pass a role to an AWS service, you must grant the PassRole permission to the user's IAM user, role, or group.  \nIt is bad practice to allow roles the PassRole permission across all resources, especially without any conditions.  \nIt is recommended to follow the principle of least privilege (PoLP) by either restricting the IAM Role policy to the required resources or by deleting the inline policy if you no longer require it."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM Role policy should not allow PassRole permission across all resources"
  opa_policy               = "package wiz\n\nimport future.keywords.in\n\ndefault result = \"pass\"\n\nactionsIncludingIamPassRole := {\"*\", \"iam:*\", \"iam:passrole\"}\n\nactionContainsIamPassRole(statement) {\n\tlower(statement.Action[_]) in actionsIncludingIamPassRole\n}{\n\tlower(statement.Action) in actionsIncludingIamPassRole\n}\n\nwildcardResource(statement) {\n\tstatement.Resource[_] == \"*\"\n}{\n\tstatement.Resource == \"*\"\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\n# This functions supports cases where the policy requires parsing (unmarshalling):\noverlyPermissivePolicies[policyName] {\n\trolePolicies := input.RolePolicyList[policy]\n\tstatement := json.unmarshal(rolePolicies.PolicyDocument).Statement[s]\n\tactionContainsIamPassRole(statement)\n\twildcardResource(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n\tpolicyName := rolePolicies.PolicyName\n}\n\n# This functions supports already parsed policies:\noverlyPermissivePolicies[policyName] {\n\trolePolicies := input.RolePolicyList[policy]\n\trolePolicies.PolicyDocument.Version\n\tstatement := rolePolicies.PolicyDocument.Statement[s]\n\tactionContainsIamPassRole(statement)\n\twildcardResource(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n\tpolicyName := rolePolicies.PolicyName\n}\n\nresult = \"fail\" {\n\tcount(overlyPermissivePolicies) > 0\n}\n\ncurrentConfiguration := sprintf(\"The following policies allow all resources (*) the action 'iam:PassRole': '%v'\", [concat(\", \", overlyPermissivePolicies)])\nexpectedConfiguration := \"IAM Role policy should restrict resources or add a Condition clause\""
  remediation_instructions = "Perform the following commands to delete or modify the IAM policy via AWS CLI:\n\nTo delete the reported inline policies, use the following command to delete the policy. Run the command for each overly permissive policy name detected (listed below) that you wish to delete.  \n```  \naws iam delete-role-policy \\\n    --role-name {{roleName}} \\\n    --policy-name <paste policy name>\n```  \n\nIf the IAM Role requires the `iam:PassRole` permission,  it is recommended to create a new JSON file policy that is more restrictive by limiting the Resource clause to specific ARNs, or adding a restrictive `Condition` clause.  \nTo pass the role to a specific AWS service use the `iam:PassedToService` condition - for more information click [here](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_examples_iam-passrole-service.html).\n\nUse the following command to create a new inline policy version:\n```  \naws iam put-role-policy \\\n    --role-name {{roleName}} \\\n    --policy-name <paste policy name here to update the existing policy version> \\\n    --policy-document file://<NewPolicyVersion.json>\n```\nIAM Role inline policies allowing `iam:PassRole` to all resources: `{{overlyPermissiveInlinePolicies}}`."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["role"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tresource := document.resource.aws_iam_role_policy[name]\n\tpolicy := resource.policy\n\n\tout := common_lib.json_unmarshal(policy)\n\tst := common_lib.get_statement(out)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tcheck_passrole(statement)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_iam_role_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_role_policy[%s].policy\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'aws_iam_role_policy.policy.Statement.Action' iam:passrole shouldn't have Resource '*'\",\n\t\t\"keyActualValue\": \"'aws_iam_role_policy.policy.Statement.Action' iam:passrole has Resource '*'\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_role_policy\", name, \"policy\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\ncheck_passrole(statement) {\n\tcommon_lib.equalsOrInArray(statement.Action, \"iam:passrole\")\n\tcommon_lib.equalsOrInArray(statement.Resource, \"*\")\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_role_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_role_policy)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "mp-s-4-r1-1" {
  description              = "Resources with Cloudfront distributions must have AWS Advanced Shield Application Layer Automatic Response enabled."
  enabled                  = true
  function_as_control      = false
  name                     = "Cloudfront Advanced Shield DDoS rule"
  opa_policy               = "package wiz\nimport future.keywords.if\n\ndefault result := \"fail\"\n\nprotectsCloudFront := true if {\n\tstartswith(input.ResourceArn,\"arn:aws:cloudfront:\")\n}\n\nisApplicationLayerAutomaticResponseConfigurationEnabled := true if {\n\tlower(input.ApplicationLayerAutomaticResponseConfiguration.Status)==\"enabled\"\n}\n\nresult := \"skip\" {\n\tnot protectsCloudFront\n}\n\nresult := \"pass\" {\n\tprotectsCloudFront\n\tisApplicationLayerAutomaticResponseConfigurationEnabled\n}\n\ncurrentConfiguration := sprintf(\"This AWS Shield does not has ApplicationLayerAutomaticResponseConfiguration enabled (%s)\", [input.ApplicationLayerAutomaticResponseConfiguration])\nexpectedConfiguration := \"Resources with Cloudfront distributions must have AWS Advanced Shield Application Layer Automatic Response enabled.\"\n"
  remediation_instructions = null
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["shield#protection"]
}


resource "wiz_control" "op-exp-7-11" {
  description               = "This AWS account has Security Hub disabled\n\nSecurity Hub provides centralized visibility into security findings and compliance status across AWS accounts. It automates compliance checks, prioritizes security findings, and offers insights into potential threats."
  enabled                   = false
  name                      = "Subscription wit no AWS Security Hub"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"type\":[{\"type\":\"CONTAINS\"}],\"with\":{\"relationships\":[{\"negate\":true,\"type\":[{\"type\":\"CONTAINS\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS_TECH\"}],\"with\":{\"type\":[\"TECHNOLOGY\"],\"where\":{\"_externalID\":{\"EQUALS\":[\"11161\"]}}}}],\"type\":[\"MANAGEMENT_SERVICE\"]}}],\"select\":true,\"type\":[\"REGION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"region\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"cloudPlatform\":{\"EQUALS\":[\"AWS\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable security hub.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}



resource "wiz_cloud_configuration_rule" "mp-si-2-5" {
  description              = "This rule checks whether all DynamoDB Table Replicas are encrypted with a customer-managed key.\n\nThis rule fails if any replica in the `Replicas` array has a `null` value for the `KMSMasterKeyId` field, indicating that it's not using a customer-managed key for encryption.\n\nDynamoDB offers server-side encryption at rest using AWS-owned keys by default. However, for enhanced security and control, it's recommended to use customer-managed keys (CMKs) through AWS Key Management Service (KMS). This allows for better key rotation practices, auditing of key usage, and the ability to disable or revoke access to the data if needed.\n\nIt is recommended to encrypt all DynamoDB Table Replicas with customer-managed keys to maintain consistent security across all replicas and to have greater control over the encryption process."
  enabled                  = true
  function_as_control      = false
  name                     = "DynamoDB Table Replica should be encrypted with a customer-managed key"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tsome replica\n\tinput.Replicas[replica].KMSMasterKeyId == null\n}\n\ncurrentConfiguration := sprintf(\"Replicas without customer-managed key: %v\", [count([r | r := input.Replicas[_]; r.KMSMasterKeyId == null])])\nexpectedConfiguration := \"All DynamoDB Table Replicas should be encrypted with a customer-managed key\""
  remediation_instructions = "Perform the following commands to encrypt DynamoDB Table Replicas with a customer-managed key via AWS CLI:\n\n1. Optional - Create a customer-managed KMS key in each region where you have a replica (unless you want to use an existing key):\n\n```\naws kms create-key --description <<Add your description here>> --region <<replicaRegion>>\n```\n\n2. Then, update each replica to use the customer-managed key:\n\n```\naws dynamodb update-table \\\n    --table-name {{tableName}} \\\n    --replica-updates '[{\"RegionName\": \"<<replicaRegion>>\", \"KMSMasterKeyId\": \"<<kmsKeyId>>\"}]' \\\n    --region {{region}}\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["dynamoDB/table"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_dynamodb_table_replica[name]\n\tnot terraLib.validKey(resource, \"kms_key_arn\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_dynamodb_table_replica\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_dynamodb_table_replica[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_dynamodb_table_replica[%s].kms_key_arn' should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_dynamodb_table_replica[%s].kms_key_arn' is undefined\", [name]),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "resource \"aws_dynamodb_table_replica\" \"example_table\" {\n  kms_key_arn = \"<kms_key_arn>\" // Add your KMS key ARN\n}"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-3-r4-2" {
  description              = "This rule checks if the EC2 Instance has a compliant patch status after a patch installation attempt on the instance.  \nThis rule skips instances without a patch installation attempt, and fails if `SsmComplianceItems.ComplianceType: Patch` has a `Status` of `NON_COMPLIANT`.  \nSystems Manager Patch Manager is a service that automatically updates security patches on assets managed by it. Ensuring that EC2 instances are compliant with SSM patch requirements is crucial for maintaining the security and integrity of the instances. Non-compliance could lead to vulnerabilities and potential breaches.  \nIt is recommended to patch and update instances to mitigate security risks regularly."
  enabled                  = true
  function_as_control      = false
  name                     = "EC2 instance after a SSM patch installation should have patch compliance status of COMPLIANT"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\npatchComplianceExists {\n\tlower(input.SsmComplianceItems[_].ComplianceType) == \"patch\"\n}\n\nresult := \"skip\" {\n\tnot patchComplianceExists\n} else := \"fail\" {\n\tlower(input.SsmComplianceItems[item].ComplianceType) == \"patch\"\n\tupper(input.SsmComplianceItems[item].Status) == \"NON_COMPLIANT\"\n}\n\ncurrentConfiguration := \"'ComplianceType: Patch' has 'Status: NON_COMPLIANT'\"\nexpectedConfiguration := \"'ComplianceType: Patch' should have 'Status: COMPLIANT'\"\n"
  remediation_instructions = "Perform the following command to run a patch installation on the EC2 instance via AWS CLI:\n```\naws ssm send-command \\\n    --targets \"Key=instanceids,Values={{instanceId}}\" \\\n    --document-name \"AWS-RunPatchBaseline\" \\\n    --parameters 'Operation=Install'\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["virtualMachine"]
}


resource "wiz_cloud_configuration_rule" "op-exp-4-2" {
  description              = "This rule checks if the EC2 Instance has a non-compliant SSM association compliance status. \nThis rule skips instances without an SSM association, and fails if `SsmComplianceItems.ComplianceType: Association` has a `Status` of `NON_COMPLIANT`.  \nSystems Manager is an AWS service that you can use to view and control your AWS infrastructure as well as maintain security and compliance. A State Manager association is a configuration that is assigned to the instances that you manage."
  enabled                  = true
  function_as_control      = false
  name                     = "EC2 instance after a SSM association should have association compliance status of COMPLIANT"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nassociationComplianceExists {\n\tlower(input.SsmComplianceItems[_].ComplianceType) == \"association\"\n}\n\nresult := \"skip\" {\n\tnot associationComplianceExists\n} else := \"fail\" {\n\tlower(input.SsmComplianceItems[item].ComplianceType) == \"association\"\n\tupper(input.SsmComplianceItems[item].Status) == \"NON_COMPLIANT\"\n}\n\ncurrentConfiguration := \"'ComplianceType: Association' has 'Status: NON_COMPLIANT'\"\nexpectedConfiguration := \"'ComplianceType: Association' should have 'Status: COMPLIANT'\""
  remediation_instructions = "A failed association can be related to different things, including targets and SSM document names. To remediate this issue, you must first identify and investigate the association by viewing the association history. For instructions on viewing association history, see [Viewing association histories](https://docs.aws.amazon.com/systems-manager/latest/userguide/state-manager-associations-history.html) in the AWS Systems Manager User Guide.\n\nAfter investigating, you can edit the association to correct the identified issue. You can edit an association to specify a new name, schedule, severity level, or targets. After you edit an association, AWS Systems Manager creates a new version. For instructions on editing an association, see [Editing and creating a new version of an association](https://docs.aws.amazon.com/systems-manager/latest/userguide/state-manager-associations-edit.html) in the AWS Systems Manager User Guide."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["virtualMachine"]
}


resource "wiz_cloud_configuration_rule" "mp-si-2-2" {
  description              = "This rule checks whether the S3 Bucket is not encrypted with a customer-managed key.  \nThis rule fails if `KMSMasterKeyID` is `null`.  \nWhen you use server-side encryption with AWS KMS (SSE-KMS), you should use the customer-managed key. \nAWS KMS supports envelope encryption. S3 uses the AWS KMS features for envelope encryption to further protect your data. Envelope encryption is the practice of encrypting your plaintext data with a data key, and then encrypting that data key with a KMS key.  \nIf you don't specify a customer-managed key, Amazon S3 automatically creates an AWS-managed key in your AWS account the first time that you add an object encrypted with SSE-KMS to a bucket. By default, S3 uses this KMS key for SSE-KMS. To use a customer-managed key for SSE-KMS, create a symmetric encryption customer-managed key before you configure SSE-KMS. Then, when you configure SSE-KMS for your bucket, specify the existing customer-managed key.\n>**Note**  \nSome S3 buckets must use Amazon S3-managed keys (SSE-S3) to use AWS features. This CCR does not skip such resources in order to provide full visibility for compliance checks. For example, [ALB access logs](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/enable-access-logging.html#access-log-create-bucket) can only be stored in a bucket with SSE-S3 encryption. If you wish, you can create Ignore Rules, or use the Security Graph to filter out such buckets, see [this graph query](https://app.wiz.io/explorer/graph#%7E%28queryTitle%7E%27Findings*20for*20S3*20Bucket*20should*20be*20encrypted*20with*20KMS*20*28SSE-KMS*29%7Equery%7E%28type%7E%28%7E%27BUCKET%29%7Eselect%7Etrue%7Erelationships%7E%28%7E%28type%7E%28%7E%28type%7E%27ALERTED_ON%7Ereverse%7Etrue%29%29%7Ewith%7E%28type%7E%28%7E%27CONFIGURATION_FINDING%29%7Ewhere%7E%28configurationRuleShortName%7E%28EQUALS%7E%27S3-010%29%29%7Eselect%7Etrue%29%29%7E%28optional%7Etrue%7Etype%7E%28%7E%28type%7E%27CONTAINS%7Ereverse%7Etrue%29%29%7Ewith%7E%28type%7E%28%7E%27SUBSCRIPTION%29%7Eselect%7Etrue%29%29%7E%28type%7E%28%7E%28type%7E%27STORES_DATA_IN%7Ereverse%7Etrue%29%29%7Enegate%7Etrue%7Ewith%7E%28type%7E%28%7E%27LOAD_BALANCER%29%7Ewhere%7E%28nativeType%7E%28EQUALS%7E%28%7E%27loadBalancerv2*2fapplication%29%29%29%29%29%29%29%7Eview%7E%27table%29) for example.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "S3 Bucket should be encrypted with a customer-managed key"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\ncustomerKMSEncryptionEnabled {\n\tKMSMasterKeyID := object.get(input.bucketEncryptionConfiguration.ServerSideEncryptionConfiguration.Rules[_].ApplyServerSideEncryptionByDefault,\"KMSMasterKeyID\", null)\n    not is_null(KMSMasterKeyID)\n}\n\nresult = \"skip\" {\n\tnot input.WizMetadata.objectFetchStatus.bucketEncryptionConfiguration.result == \"Success\"\n} else = \"fail\" {\n\tnot customerKMSEncryptionEnabled\n}\n\ncurrentConfiguration := sprintf(\"KMS encryption is disabled\", [])\nexpectedConfiguration := sprintf(\"KMS encryption should be enabled\", [])"
  remediation_instructions = "Perform the following command to configure default bucket encryption with SSE-KMS using an S3 Bucket Key via AWS CLI:  \n```  \naws s3api put-bucket-encryption --bucket {{bucketName}} --server-side-encryption-configuration '{  \n    \"Rules\": [  \n            {  \n                \"ApplyServerSideEncryptionByDefault\": {  \n                    \"SSEAlgorithm\": \"aws:kms\",  \n                    \"KMSMasterKeyID\": \"<kmsKeyArn>\"  \n                },  \n                \"BucketKeyEnabled\": true  \n            }  \n        ]  \n    }'  \n```\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["bucket"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as commonLib\n\n# This rule will pass if at least the 'aws_s3_bucket' or\n# its association configuration resource are properly configured.\n\nbucketWithKmsMasterKey(resource) {\n\trules := terraLib.getArray(resource.rule)\n\tapplyServerSideEncryptionByDefault := terraLib.getValueArrayOrObject(rules[_].apply_server_side_encryption_by_default)\n\tcommonLib.valid_key(applyServerSideEncryptionByDefault, \"kms_master_key_id\")\n\tapplyServerSideEncryptionByDefault.kms_master_key_id != \"\"\n}\n\nbucketEncryptedWithCustomerProvidedCmks(bucket, bucketName, document) {\n\t# TF version 3\n\tserverSideEncryptionConfiguration := terraLib.getValueArrayOrObject(bucket.server_side_encryption_configuration)\n\tbucketWithKmsMasterKey(serverSideEncryptionConfiguration)\n}{\n\t# TF version 4\n\tsseConfigResource := document.resource.aws_s3_bucket_server_side_encryption_configuration[sseConfigName]\n\tterraLib.associatedResources(bucket, sseConfigResource, bucketName, sseConfigName, \"bucket\", \"bucket\")\n\tbucketWithKmsMasterKey(sseConfigResource)\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tbucket := document.resource.aws_s3_bucket[bucketName]\n\n\tnot bucketEncryptedWithCustomerProvidedCmks(bucket, bucketName, document)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": terraLib.get_resource_name(bucket, bucketName),\n\t\t\"resourceType\": \"aws_s3_bucket\",\n\t\t\"searchKey\": sprintf(\"aws_s3_bucket[%s]\", [bucketName]),\n\t\t\"keyExpectedValue\": sprintf(\"'aws_s3_bucket[%s]' should be encrypted using a customer-provided key\", [bucketName]),\n\t\t\"keyActualValue\": sprintf(\"'aws_s3_bucket[%s]' is not encrypted using a customer-provided key\", [bucketName]),\n\t\t\"resourceTags\": object.get(bucket, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_s3_bucket](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket), [aws_s3_bucket_server_side_encryption_configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket_server_side_encryption_configuration)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "mp-si-2-3" {
  description              = "This rule checks whether the SQS Queue is using KMS customer-managed keys rather than AWS-managed keys.  \nThis rule fails if the `KmsMasterKeyId` field is configured to use a default AWS-managed key.  \nIt is recommended to use a customer-managed KMS key to encrypt the content of the SQS queue messages, as well as to gain full control over who can use the keys and access the data encrypted within these messages."
  enabled                  = true
  function_as_control      = false
  name                     = "SQS Queue should be encrypted with a customer-managed key"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\nawsManagedKmsAlias := \"alias/aws/sqs\"\n\nresult = \"fail\" {\n\tinput.KmsMasterKeyId == awsManagedKmsAlias\n} {\n\tnot input.KmsMasterKeyId\n}\n\ncurrentConfiguration := sprintf(\"'KmsMasterKeyId' is set to %s\", [awsManagedKmsAlias])\nexpectedConfiguration := sprintf(\"'KmsMasterKeyId' should not be set to %s\", [awsManagedKmsAlias])"
  remediation_instructions = "Perform the following command in order to encrypt SQS Queue with a KMS customer-managed keys via AWS CLI:  \n```  \naws sqs set-queue-attributes --queue-url <Queue_URL> --attributes KmsMasterKeyId=<KmsMasterKeyId>  \n```  \n>**Note**  \nIn case you do not have a KMS customer managed key, You will need to create a new key to encrypt queue messages using the CMK provided. Steps are provided [here](https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html)"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["sqs"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::SQS::Queue\"\n\n\tnot common_lib.valid_key(resource.Properties, \"KmsMasterKeyId\")\n\tSqsManagedSseNotEnabled(resource.Properties)\n\t\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s.Properties\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.KmsMasterKeyId should be set or SqsManagedSseEnabled set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.KmsMasterKeyId is undefined and SqsManagedSseEnabled not enabled\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nSqsManagedSseNotEnabled(Properties) {\n\tnot common_lib.valid_key(Properties, \"SqsManagedSseEnabled\")\n} else {\n\tcloudFormationLib.isCloudFormationFalse(Properties.SqsManagedSseEnabled)\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\n## two ways to activated SSE : kms_master_key_id OR sqs_managed_sse_enabled\n## https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/sqs_queue#server-side-encryption-sse\nsse_activated(obj) {\n\tcommon_lib.valid_key(obj, \"kms_master_key_id\")\n} else {\n\tcommon_lib.valid_key(obj, \"sqs_managed_sse_enabled\")\n} else = false {\n\ttrue\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_sqs_queue[name]\n\tnot common_lib.valid_key(resource, \"kms_master_key_id\")\n\n\tresource.sqs_managed_sse_enabled == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_sqs_queue\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_sqs_queue[%s].sqs_managed_sse_enabled\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_sqs_queue[%s].sqs_managed_sse_enabled must be set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_sqs_queue[%s].sqs_managed_sse_enabled is set to false\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_sqs_queue\", name, \"sqs_managed_sse_enabled\"], []),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_sqs_queue[name]\n\tsse_activated(resource) == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_sqs_queue\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_sqs_queue[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_sqs_queue[%s].kms_master_key_id or aws_sqs_queue[%s].sqs_managed_sse_enabled should be defined and not null\", [name, name]),\n\t\t\"keyActualValue\": sprintf(\"aws_sqs_queue[%s].kms_master_key_id and aws_sqs_queue[%s].sqs_managed_sse_enabled are undefined or null\", [name, name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_sqs_queue\", name], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_sqs_queue[name]\n\tresource.kms_master_key_id == \"\"\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_sqs_queue\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_sqs_queue[%s].kms_master_key_id\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"aws_sqs_queue.kms_master_key_id should not be ''\",\n\t\t\"keyActualValue\": \"aws_sqs_queue.kms_master_key_id is ''\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_sqs_queue\", name, \"kms_master_key_id\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_sqs_queue](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/sqs_queue)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-10-6" {
  description              = "This rule checks whether the KMS key policy allows KMS actions for all principals.  \nThis rule skips resource policies that do not contain KMS-related statements (KMS actions or resources), and fails if the policy contains a Statement where:\n* `Effect` is `Allow`\n* `Principal` contains wildcard (`*` or `AWS:*`)\n* `Condition` is null or does not exist  \n\nIt is generally not recommended to include a wildcard (`*`) in the principal clause of an AWS Key Management Service (KMS) key policy because it grants permission to any principal (user or service) to perform the actions specified in the action field. This could be a security risk because it allows any principal with access to the AWS account to perform the specified actions on the key, which could include the ability to delete or modify the key, as well as encrypt and decrypt data.\n\nThis could also lead to unintended access to your resources or misconfigured role permissions; it would be better to limit permissions to specific principals or groups, and those should be least privilege roles. This helps ensure that only authorized principals can perform the specified actions on the key, which can reduce the risk of unauthorized access to sensitive data.\n\n>**Note**  \n>The IaC matchers of this rule detect KMS keys that have an overly permissive policy. This includes the AWS default overly permissive KMS key policy that is assigned in case a policy is not defined. The cloud matcher on Cloud Configuration Rule `IAM-148` detects KMS key policies that allow all KMS actions."
  enabled                  = true
  function_as_control      = false
  name                     = "KMS key policy should not allow access to all principals"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresourcePolicy = policy {\n# for parsed policies:\n\tinput.Version\n\tpolicy := input\n}{\n# for policies that require parsing:\n\tpolicy := json.unmarshal(input)\n}\n\n# While '*' also allows all KMS actions, it is not added to the logic to reduce false positive detections.\n# Cloud Configuration Rule 'IAM-184' detects resource-based policies that allow all actions.\nkmsKeyPolicy(statement) {\n\tstartswith(lower(statement.Action), \"kms:\")\n}{\n\tstartswith(lower(statement.Action[_]), \"kms:\")\n}{\n\tstartswith(lower(statement.Resource), \"arn:aws:kms\")\n}{\n\tstartswith(lower(statement.Resource[_]), \"arn:aws:kms\")\n}\n\nwildcardPrincipal(statement) {\n\tstatement.Principal == \"*\"\n}{\n\tstatement.Principal[_] == \"*\"\n}{\n\tstatement.Principal.AWS[_] == \"*\"\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\nkmsPolicyAllowsAllPrincipals[statement] {\n\tstatement := resourcePolicy.Statement[s]\n\tkmsKeyPolicy(statement)\n\twildcardPrincipal(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n}\n\nkmsRelatedStatement[statement] {\n\tstatement := resourcePolicy.Statement[s]\n\tkmsKeyPolicy(statement)\n}\n\n# Skips all policies that don't contain KMS-related statements (action/resource). \nresult = \"skip\" {\n\tcount(kmsRelatedStatement) == 0\n} else = \"fail\" { \n\tcount(kmsPolicyAllowsAllPrincipals) > 0\n}\n\ncurrentConfiguration := \"KMS Key policy allows access to all (*) principals\"\nexpectedConfiguration := \"KMS Key policy should not allow access to all (*) principals\"\n"
  remediation_instructions = "Perform the following commands to attach a new KMS key policy via AWS CLI:    \n1. Locate the Key ID of the KMS key to which the policy is attached to.\n\n2. Create a local JSON file containing a new least-privilege key policy.\n\n3. Using the information from steps 1 and 2, perform the following command to update the KMS key policy:\n```\naws kms put-key-policy \\\n    --policy-name default \\\n    --key-id <Your key ID> \\\n    --policy file://new-key-policy.json\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["resourcePolicy"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresources := input.document[i].Resources[name]\n\tresources.Type == \"AWS::KMS::Key\"\n\tpolicy := resources.Properties.KeyPolicy\n\tst := common_lib.get_statement(common_lib.get_policy(policy))\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tcommon_lib.equalsOrInArray(statement.Principal, \"*\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resources, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.KeyPolicy\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.KeyPolicy.Statement should not be '*'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.KeyPolicy.Statement is '*'\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"Resource\", name, \"Properties\", \"KeyPolicy\"], []),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resources),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-6-r1-7" {
  description              = "This rule checks whether the IAM password policy allows users to change their passwords.  \nThis rule fails if `AllowUsersToChangePassword` is set to `false`.  \nPassword policy should allow users to change their passwords as a security best practice."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM password policy should allow users to change their passwords"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tnot input.accountPasswordPolicy.AllowUsersToChangePassword\n}\n\ncurrentConfiguration := \"IAM password policy is not allowing users to change their passwords\"\nexpectedConfiguration := \"IAM password policy should allow users to change their passwords\""
  remediation_instructions = "Perform the following command to configure the IAM password policy to allow users to change their passwords via AWS CLI:  \n```  \naws iam update-account-password-policy --allow-users-to-change-password  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["account"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ansLib\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tmodules := {\"community.aws.iam_password_policy\", \"iam_password_policy\"}\n\tpwPolicy := task[modules[m]]\n\tansLib.checkState(pwPolicy)\n\n\tsearchKey := checkAllowPass(pwPolicy)\n\tsearchKey != \"none\"\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{%s}}%s\", [task.name, modules[m], searchKey]),\n\t\t\"issueType\": issueType(searchKey),\n\t\t\"keyExpectedValue\": \"iam_password_policy should have the property 'allow_pw_change/allow_password_change' true\",\n\t\t\"keyActualValue\": \"iam_password_policy has the property 'allow_pw_change/allow_password_change' undefined or false\",\n\t\t\"resourceTags\": object.get(pwPolicy, \"tags\", {}),\n\t}\n}\n\nissueType(str) = \"MissingAttribute\" {\n\tstr == \"\"\n} else = \"IncorrectValue\" {\n\ttrue\n}\n\ncheckAllowPass(pwPolicy) = \".allow_pw_change\" {\n\tansLib.isAnsibleFalse(pwPolicy.allow_pw_change)\n} else = \".allow_password_change\" {\n\tansLib.isAnsibleFalse(pwPolicy.allow_password_change)\n} else = \"\" {\n\tnot pwPolicy.allow_pw_change\n\tnot pwPolicy.allow_password_change\n} else = \"none\" {\n\ttrue\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as common_lib\n\n#allow_users_to_change_password default is true\nWizPolicy[result] {\n\tpol := input.document[i].resource.aws_iam_account_password_policy[name]\n\tpol.allow_users_to_change_password == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_iam_account_password_policy\",\n\t\t\"resourceName\": terraLib.get_resource_name(pol, name),\n\t\t\"searchKey\": sprintf(\"aws_iam_account_password_policy[%s].allow_users_to_change_password\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_iam_account_password_policy\", name,\"allow_users_to_change_password\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"'allow_users_to_change_password' should equal 'true'\",\n\t\t\"keyActualValue\": \"'allow_users_to_change_password' is equal 'false'\",\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(pol, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_iam_account_password_policy](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_account_password_policy)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_control" "op-exp-8-r1-5" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor AWS Organization changes.\n\nIt is recommended to set an alarm that will be triggered for every AWS Organization change (such as DeleteOrganization, EnablePolicyType, MoveAccount, RemoveAccountFromOrganization). Monitoring changes to the AWS Organization help detect and prevent undesired modifications that can affect the account's security posture."
  enabled                   = true
  name                      = "Subscription with no CloudWatch monitoring for AWS Organization"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 14\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_cloud_configuration_rule" "op-acc-6-r7-3" {
  description              = "This rule checks if an IAM user with no credentials exists for over 90 days.  \nThis rule fails if the fields 'AccessKey1Active', 'AccessKey2Active', and 'PasswordEnabled' are set to 'false' and the 'CreateDate' is more than 90 days ago.  \nHaving unused users is not best practice; it is recommended to delete useless users in order to maintain a clean environment."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM users unused for over 90 days should be deleted"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\ncreateDate := input.CreateDate\naccessKey1 := input.userCredentials.AccessKey1Active\naccessKey2 := input.userCredentials.AccessKey2Active\npassword := input.userCredentials.PasswordEnabled\nnow_ns := time.now_ns()\nninty_days_ns := time.parse_duration_ns(\"2160h\") # 90d in hours\n\nnonActiveCredentials {\n    lower(accessKey1) == \"false\"\n    lower(accessKey2) == \"false\"\n    lower(password) == \"false\"\n}\n\nresult = \"fail\" {\n\tnonActiveCredentials\n    \tnow_ns - time.parse_rfc3339_ns(createDate) > ninty_days_ns\n}\n\ncurrentConfiguration := \"Unused User does not have any active credentials for over 90 days\"\nexpectedConfiguration := \"IAM user should be deleted/used in 90 days from creation\"\n"
  remediation_instructions = "Perform the following step to delete an IAM user via AWS CLI:  \n```  \naws iam delete-user \\\n    --user-name {{userName}}  \n```  \n\n"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "INFORMATIONAL"
  target_native_types      = ["user"]
}


resource "wiz_cloud_configuration_rule" "op-exp-7-7" {
  description              = "This rule checks if GuardDuty Detector is not enabled.  \nThis rule fails if `Status` is not set to `ENABLED`, meaning it is suspended.  \nIt is recommended to enable GuardDuty in all active regions in your AWS account.\n>**Note**  \n>See this [Control](https://app.wiz.io/graph#~(control~'wc-id-639)) to see in which active regions GuardDuty is disabled."
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty Detector should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nstatus := input.Status\n\nresult = \"fail\" {\n\tupper(status) != \"ENABLED\"\n}\n\ncurrentConfiguration := sprintf(\"'Status': '%v'\", [status])\nexpectedConfiguration := \"GuardDuty detector should be enabled\""
  remediation_instructions = "Perform the following command to enable the GuardDuty detector via AWS CLI:\n```\naws guardduty update-detector \\\n\t--detector-id <value> \\\n\t--enable\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["guardduty"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::GuardDuty::Detector\"\n\tproperties := resource.Properties\n\tproperties.Enable == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.Enable\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.Enable should be set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.Enable is set to false\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tawsGuardDuty := input.document[i].resource.aws_guardduty_detector[name]\n\tdetector := awsGuardDuty.enable\n\n\tdetector == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(awsGuardDuty, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s].enable\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name, \"enable\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"GuardDuty Detector should be Enabled\",\n\t\t\"keyActualValue\": \"GuardDuty Detector is not Enabled\",\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(awsGuardDuty, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_guardduty_detector](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/guardduty_detector)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-4-6" {
  description              = "This rule checks whether the IAM Role has an inline policy that allows decryption actions on all KMS keys.  \nThis rule fails if the role has at least one inline policy (`RolePolicyList`) that contains a statement where:  \n* `Action` contains one of: `kms:Decrypt`, `kms:ReEncryptFrom`, `kms:*`, `*`\n* `Resource` is `*`\n* `Effect` is `Allow`\n* `Condition` is null or does not exist\n\nWith AWS KMS, you control who can use your KMS keys and gain access to your encrypted data. IAM policies define which actions an identity (user, group, or role) can perform on which resources. Following security best practices, it is recommended that you follow the principle of least privilege (PoLP). In other words, you should grant identities the `kms:Decrypt` or `kms:ReEncryptFrom` permissions only for the keys that are required to perform a task.  \nIt is recommended to adopt the PoLP to reduce the risk of unintended disclosure of your data.\n>**Note**  \nSee Cloud Configuration Rule `IAM-198` to view such non-compliant policies."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM Role inline policies should not allow decryption actions on all KMS keys"
  opa_policy               = "package wiz\n\nimport future.keywords.in\n\ndefault result := \"pass\"\n\ninlinePolicy[policy] {\n\t# For parsed policies:\n\tinput.RolePolicyList[p].PolicyDocument.Version\n\tpolicy := input.RolePolicyList[p].PolicyDocument\n}{\n\t# For policies that require parsing:\n\tpolicy := json.unmarshal(input.RolePolicyList[p].PolicyDocument)\n}\n\ndecryptionActions := {\"*\", \"kms:*\", \"kms:reencryptfrom\", \"kms:decrypt\"}\n\nkmsDecryptionActions(statement) {\n\t# in case Action is an array\n\tlower(statement.Action[_]) in decryptionActions\n}{\n\t# in case Action is not an array\n\tlower(statement.Action) in decryptionActions\n}\n\noverlyPermissiveResources(statement) {\n\t# in case Resource is an array\n\tstatement.Resource[_] == \"*\"\n}{\n\t# in case Resource is not an array\n\tstatement.Resource == \"*\"\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nnullCondition(statement) {\n\tobject.get(statement, \"Condition\", null) == null\n}\n\nstatementAllowsKmsDecryptionActions(policy) {\n\t# in case Statement is an array\n\tstatmentAllowsKmsDecryption := [\n\tstatement | statement := policy.Statement[s];\n\tkmsDecryptionActions(statement)\n\toverlyPermissiveResources(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n\t]\n\n\tcount(statmentAllowsKmsDecryption) > 0\n}{\n    # in case Statement is not an array\n\tstatmentAllowsKmsDecryption := [\n\tstatement | statement := policy.Statement;\n\tkmsDecryptionActions(statement)\n\toverlyPermissiveResources(statement)\n\teffectAllow(statement)\n\tnullCondition(statement)\n\t]\n\n\tcount(statmentAllowsKmsDecryption) > 0\n}\n\ninlinePoliciesAllowingKmsDecryption {\n\n\tpolicyAllowsKmsDecryption := [\n\tpolicy | policy := inlinePolicy[p];\n\tstatementAllowsKmsDecryptionActions(policy)\n\t]\n    \n\tcount(policyAllowsKmsDecryption) > 0\n}\n\nresult := \"fail\" {\n\tinlinePoliciesAllowingKmsDecryption\n}\n\ncurrentConfiguration := \"Inline policy allows KMS decryption actions on all KMS keys\"\nexpectedConfiguration := \"Inline policy should not allow KMS decryption actions on all KMS keys\""
  remediation_instructions = "If you want to **modify** the non-compliant inline policy attached to the role - see this [AWS guide](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage-edit.html#edit-inline-policy-console).\n\nIf you want to **delete** the non-compliant inline policy attached to the role - see this [AWS guide](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage-delete.html#delete-policies-cli-api)."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["role"]
}


resource "wiz_cloud_configuration_rule" "op-acc-3-r1-1" {
  description              = "AWS provides a support center that can be used for incident notification and response, as well as technical support and customer services. Create an IAM Role to allow authorized users to manage incidents with AWS Support."
  enabled                  = true
  function_as_control      = false
  name                     = "Ensure a support role has been created to manage incidents with AWS Support"
  opa_policy               = "package wiz\n\ndefault result = \"fail\"\n\n# Check if the role has the necessary managed policy attached\nhas_support_policy {\n    policy := input.AttachedManagedPolicies[_]\n    lower(policy.PolicyName) == \"awssupportaccess\"\n}\n\n# Check if the role name indicates it's a support role\nis_support_role {\n    contains(lower(input.RoleName), \"support\")\n}\n\nresult = \"pass\" {\n    has_support_policy\n    is_support_role\n}\n\ncurrentConfiguration := sprintf(\"Role '%s' does not have the 'AWSSupportAccess' policy attached or is not named as a support role\", [input.RoleName])\nexpectedConfiguration := \"A support role should be created with the 'AWSSupportAccess' policy attached and named to indicate it's for support purposes\"\n\n# Additional context\nreason := \"not_found\" {\n    not has_support_policy\n    not is_support_role\n} else := \"policy_missing\" {\n    not has_support_policy\n    is_support_role\n} else := \"naming_issue\" {\n    has_support_policy\n    not is_support_role\n}\n\n# Provide more detailed guidance based on the specific issue\nguidance := \"Create a new IAM role specifically for managing incidents with AWS Support. Attach the 'AWSSupportAccess' managed policy to this role and ensure its name clearly indicates its purpose (e.g., 'AWSSupportRole').\" {\n    reason == \"not_found\"\n} else := \"Attach the 'AWSSupportAccess' managed policy to the existing support role to grant necessary permissions for AWS Support.\" {\n    reason == \"policy_missing\"\n} else := \"Consider renaming the role to clearly indicate its purpose as a support role (e.g., 'AWSSupportRole').\" {\n    reason == \"naming_issue\"\n}"
  remediation_instructions = null
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["role"]
}


resource "wiz_control" "op-exp-8-r1-4" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor IAM Policies changes.\n\nIt is recommended to set an alarm that will be triggered for every IAM policy configuration change (create, update, attach, detach, or delete). This helps detect activity that grants users, groups, or roles undesired permissions."
  enabled                   = true
  name                      = "Subscription with no CloudWatch monitoring for IAM Policies"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 8\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}




resource "wiz_cloud_configuration_rule" "mp-si-2-1" {
  description              = "Ensure that existing Elastic Block Store (EBS) attached volumes are encrypted to meet security and compliance requirements."
  enabled                  = true
  function_as_control      = false
  name                     = "EBS Volume should be encrypted"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tinput.Encrypted == false\n}\n\ncurrentConfiguration := \"Encrypted is set to 'false'\"\nexpectedConfiguration := \"The EBS volume should be encrypted\""
  remediation_instructions = "Follow these steps to encrypt EBS at rest:  \n  \n1. Login to the AWS Management Console navigate to EC2 <https://console.aws.amazon.com/ec2/>  \n2. Under 'Elastic Block Store' select 'Volumes'.  \n3. Select the non-encrypted instance to encrypt.  \n4. Click the 'Actions' button and select 'Create Snapshot'.  \n5. Enter the snapshot name and click 'Create Snapshot'.  \n6. Under 'Elastic Block Store' click 'Snapshots'.  \n7. Select the created snapshot and under 'Actions' click 'Copy'.  \n8. Mark the 'Encryption' and select the relevant key and click 'Copy'.  \n9. Select the new EBS snapshot.  \n10. Click 'Actions' and select 'Create Volume'.  \n11. Select the appropriate options and make sure the volume Encryption is selected (Encrypt this volume).  \n12. Click 'Create Volume'.  \n13. Select the unencrypted volume and in the 'Actions' select 'Detach Volume'.  \n14. Click 'Yes, Detach'.  \n15. Select the new encrypted EBS volume.  \n16. Click 'Actions' and select 'Attach Volume'.  \n17. In the 'Attach Volume' menu enter the EC2 instance ID and the device name for attachment.  \n18. Click 'Attach'."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["volume"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as commonLib\nimport data.generic.terraform as terraLib\n\nENABLED := \"enabled\"\nENCRYPTED := \"encrypted\"\n\nisEncryption(resource, key) {\n  resource[key] == true\n}\n\ndefaultEncription(doc) {\n  not doc.resource.aws_ebs_encryption_by_default\n}{\n  encryptionByDefaultResource := doc.resource.aws_ebs_encryption_by_default[config]\n  not isEncryption(encryptionByDefaultResource, ENABLED)\n}\n\nWizPolicy[result] {\n  document := input.document[i]\n  defaultEncription(document)\n  ebsVolumeResource := document.resource.aws_ebs_volume[volumeName]\n  not isEncryption(ebsVolumeResource, ENCRYPTED)\n    \n  result := {\n    \"documentId\": input.document[i].id,\n    \"resourceName\": terraLib.get_resource_name(ebsVolumeResource, volumeName),\n    \"resourceType\": \"aws_ebs_volume\",\n    \"searchKey\": sprintf(\"aws_ebs_volume[%s]\", [volumeName]),\n    \"keyExpectedValue\": sprintf(\"EBS Volume %v is not encrypted\",[volumeName]),\n    \"keyActualValue\": sprintf(\"EBS Volume %v should be encrypted\",[volumeName]),\n    \"resourceTags\": object.get(ebsVolumeResource, \"tags\", {}),\n  }\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_ebs_volume](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ebs_volume), [aws_ebs_encryption_by_default](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ebs_encryption_by_default)"
    type                     = "TERRAFORM"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tdocument := input.document\n\tresource = document[i].Resources[name]\n\tresource.Type == \"AWS::EC2::Volume\"\n\tproperties := resource.Properties\n\tnot common_lib.valid_key(properties, \"Encrypted\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.Encrypted should be defined and not null\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.Encrypted is undefined or null\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tdocument := input.document\n\tresource = document[i].Resources[name]\n\tresource.Type == \"AWS::EC2::Volume\"\n\tproperties := resource.Properties\n\tproperties.Encrypted == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.Encrypted\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"Resources.%s.Properties.Encrypted should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"Resources.%s.Properties.Encrypted is false\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
}


resource "wiz_control" "op-exp-8-r1-11" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor route tables configuration changes.\n\nIt is recommended to set an alarm that will be triggered for every route table configuration change (create, delete, or update). This helps detect modifications that may allow undesired access to AWS resources."
  enabled                   = false
  name                      = "Subscription with no CloudWatch monitoring for route tables"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 10\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_control" "op-exp-8-r1-18" {
  description               = "This S3 bucket object-level read events are not logged.\n\nEnabling CloudTrail events logging can assist in meeting data compliance requirements, performing comprehensive security analysis, monitoring specific patterns of user behavior within the AWS account, or taking immediate actions on any object-level activity."
  enabled                   = true
  name                      = "S3 Bucket with object level read events logging disabled"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"EQUALS\":[\"CloudTrail-010\"]},\"currentConfig\":{\"CONTAINS\":[\"All\",\"all\",\"ReadOnly\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"]}},{\"optional\":true,\"type\":[{\"reverse\":true,\"type\":\"CONTAINS\"}],\"with\":{\"select\":true,\"type\":[\"SUBSCRIPTION\"]}}],\"select\":true,\"type\":[\"BUCKET\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"bucket\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"BUCKET\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"bucket\"]}}}"
  security_sub_categories   = []
  severity                  = "MEDIUM"
}


resource "wiz_control" "op-exp-8-r1-9" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor VPCs configuration changes.  \n\nIt is recommended to set an alarm that will be triggered for every  VPC configuration change (create, delete, or update). This helps detect modifications that may allow undesired access to AWS resources."
  enabled                   = false
  name                      = "Subscription with no CloudWatch monitoring for VPCs"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 13\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_control" "op-exp-8-r1-1" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor security groups configuration changes.\n\nIt is recommended to set an alarm that will be triggered for every security group configuration change (create, delete, or update). This helps detect modifications that may allow undesired access to AWS resources."
  enabled                   = true
  name                      = "Subscription with no CloudWatch monitoring for security groups"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 11\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_cloud_configuration_rule" "op-exp-7-14" {
  description              = "This rule checks whether the AWS Account has an alternate security contact configured.  \nThis rule fails if `accountAlternateSecurityContact` does not exist.  \nProviding security contact information is crucial for AWS to contact the account owner in case of security incidents or other important issues.  \nIt is recommended to keep this information up to date to ensure timely communication."
  enabled                  = true
  function_as_control      = false
  name                     = "AWS Account security contact information should be provided"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"fail\" {\n\tnot input.accountAlternateSecurityContact\n}\n\ncurrentConfiguration := \"'accountAlternateSecurityContact' does not exist\"\nexpectedConfiguration := \"'accountAlternateSecurityContact' should exist\""
  remediation_instructions = "Perform the following command to update the security contact for your AWS account via AWS CLI:\n```\naws account put-alternate-contact \\\n    --alternate-contact-type=SECURITY \\\n    --email-address=<EMAIL> \\\n    --name=<NAME> \\\n    --phone-number=<NUMBER - For example: \"+1(206)555-1234\"> \\\n    --title=<Security Manager>\n```\nReplace the placeholders with the appropriate contact information."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["account"]
}


resource "wiz_cloud_configuration_rule" "mp-info-6-5" {
  description              = "This rule checks if the Backup Plan Rule includes an EBS volume resource.  \nThis rule fails if `Selections.BackupSelection.Resources` includes at least one `arn:aws:ec2*volume` resource or `*` - indicating that all resources are included. It does not take into account any other factors such as conditions, tags, schedule settings, etc.  \nYou can view the resources included in the plan rule and its settings by inspecting the resource JSON in Wiz under `Selections`.\n>**Note**  \nThis rule is informational and does not indicate a misconfiguration."
  enabled                  = true
  function_as_control      = false
  name                     = "Backup Plan Rule includes EBS resources"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"fail\" {\n\tregex.match(\"^arn:aws:ec2:.*:volume\", input.Selections[_].BackupSelection.Resources[_])\n}{\n\tinput.Selections[_].BackupSelection.Resources[_] == \"*\"\n}\n\ncurrentConfiguration := \"At least one EBS volume resource is included in the backup plan rule\"\nexpectedConfiguration := \"This rule is informational and does not indicate a misconfiguration\"\n"
  remediation_instructions = "Perform the following steps to create a new backup plan rule via AWS CLI:\n\n1. If you do not already have a Backup Plan that you want to use, you can create one using the command below, otherwise, skip to the next step.  \n1a. Use this template to create a JSON file with your required Backup Plan configuration:\n```\n{\n  \"BackupPlan\":{\n    \"BackupPlanName\":\"test-plan\",\n    \"Rules\":[\n      {\n        \"RuleName\":<\"rule-name\">,\n        \"TargetBackupVaultName\":<\"vault-name>\",\n        \"ScheduleExpression\":<\"cron(0 1 ? * * *)>\",\n        \"ScheduleExpressionTimezone\":<\"America/Los_Angeles\">,\n        \"StartWindowMinutes\":<value>, // Value is integer in minutes\n        \"CompletionWindowMinutes\":<value>, // Value is integer in minutes\n        \"Lifecycle\":{\n          \"DeleteAfterDays\":<value>, // Value is integer in days\n        }\n      }\n    ]\n  }\n}\n```\nStore your JSON document locally with a name you choose.\n\n1b. Use the following command to create the new Backup Plan:\n```\naws backup create-backup-plan --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```\n\n2. In this step we will assign resources to the Backup Plan.  \n2a. Use this template to create a JSON file with your required plan rule configuration:\n```\n{\n  \"BackupPlanId\":<\"BACKUP-PLAN-ID\">, // The plan ID created in the previous command\n  \"BackupSelection\":{\n    \"SelectionName\":<\"selection-name\">, \n    \"IamRoleArn\":<\"arn:aws:iam::ACCOUNT-ID:role/IAM-ROLE-ARN\">,\n    \"Resources\":[\n      <\"arn:aws:ec2:*:*:instance/*\">,\n    ]\n  }\n}\n```\nFor more JSON examples, click [here](https://docs.aws.amazon.com/aws-backup/latest/devguide/assigning-resources.html#assigning-resources-json).  \nStore your JSON document locally with a name you choose.\n\n2b. Use the following command to create the new Backup Plan Rule:\n```\naws backup create-backup-selection --cli-input-json file://<PATH-TO-FILE/FILE-NAME>.json\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "INFORMATIONAL"
  target_native_types      = ["backup#backuprule"]
}


resource "wiz_control" "op-exp-8-r1-2" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor network gateways configuration changes.\n\nIt is recommended to set an alarm that will be triggered for every network gateway configuration change (create, delete, or update). This helps detect modifications that may allow undesired access to AWS resources."
  enabled                   = true
  name                      = "Subscription wit no  CloudWatch monitoring for network gateways"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 5\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_cloud_configuration_rule" "op-exp-7-6" {
  description              = "This rule checks whether GuardDuty has DNS Logs enabled as a data source.  \nThis rule fails if the `DNS_LOGS` within the `Features` list in GuardDuty has `Status` set to `DISABLED`.  \nGuardDuty is a threat detection service that continuously monitors for malicious activity and unauthorized behavior to protect your AWS accounts, workloads, and data stored in Amazon S3. Enabling DNS logs as a data source allows GuardDuty to analyze DNS query logs for potential security threats, such as DNS exfiltration attempts or communication with known malicious domains. This enhances GuardDuty's ability to detect and alert on potential security issues in your AWS environment.  \nIt is recommended to enable DNS Logs in GuardDuty to improve threat detection capabilities and overall security posture.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty DNS Logs should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"DNS_LOGS\"\n\nfeatureDisabled {\n\tupper(input.Features[i].Name) == protection\n\tupper(input.Features[i].Status) == \"DISABLED\"\n}\n\nresult = \"fail\" {\n\tfeatureDisabled\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])\n"
  remediation_instructions = "Perform the following command to enable DNS Logs for GuardDuty via AWS CLI:\n\n```\naws guardduty update-detector \\\n    --detector-id {{detectorId}} \\\n    --data-sources '{\"DNSLogs\":{\"Status\":\"ENABLED\"}}'\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["guardduty"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tnot common_lib.valid_key(resource, \"datasources\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].datasources should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].datasources is undefined\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name], []),\n\t\t\"remediation\": \"datasources {\\n\\t\\tdns_logs {\\n\\t\\t\\tenable = true\\n\\t\\t}\\n\\t}\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tnot common_lib.valid_key(resource.datasources, \"dns_logs\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s].datasources\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].datasources.dns_logs should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].datasources.dns_logs is undefined\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name, \"datasources\"], []),\n\t\t\"remediation\": \"dns_logs {\\n\\t\\tenable = true\\n\\t}\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tnot common_lib.valid_key(resource.datasources.dns_logs, \"enable\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s].datasources.dns_logs\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].datasources.dns_logs.enable should be defined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].datasources.dns_logs.enable is undefined\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name, \"datasources\", \"dns_logs\"], []),\n\t\t\"remediation\": \"enable = true\",\n\t\t\"remediationType\": \"addition\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[name]\n\tresource.datasources.dns_logs.enable == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s].datasources.dns_logs.enable\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s].datasources.dns_logs.enable should be set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector[%s].datasources.dns_logs.enable is set to false\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_guardduty_detector\", name, \"datasources\", \"dns_logs\", \"enable\"], []),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"replacement\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "resource \"aws_guardduty_detector\" \"example_detector\" {\n  datasources {\n    dns_logs {\n      enable = true\n    }\n  }\n}"
    type                     = "TERRAFORM"
  }
}


resource "wiz_control" "op-exp-8-r1-19" {
  description               = "This S3 bucket object-level write events are not logged.\n\nEnabling CloudTrail events logging can assist in meeting data compliance requirements, performing comprehensive security analysis, monitoring specific patterns of user behavior within the AWS account, or taking immediate actions on any object-level activity."
  enabled                   = true
  name                      = "S3 Bucket with object level write events logging disabled"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"EQUALS\":[\"CloudTrail-010\"]},\"currentConfig\":{\"CONTAINS\":[\"All\",\"all\",\"WriteOnly\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"]}},{\"optional\":true,\"type\":[{\"reverse\":true,\"type\":\"CONTAINS\"}],\"with\":{\"select\":true,\"type\":[\"SUBSCRIPTION\"]}}],\"select\":true,\"type\":[\"BUCKET\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"bucket\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"BUCKET\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"bucket\"]}}}"
  security_sub_categories   = []
  severity                  = "MEDIUM"
}


resource "wiz_cloud_configuration_rule" "mp-com-4-1" {
  description              = "This rule checks whether a VPC has no resources attached to it (unused VPC).  \nThis rule fails if the field `VpcSubnet` is empty.  \nAn unused VPC might cause unnecessary additional charges; therefore, it is recommended to delete it."
  enabled                  = true
  function_as_control      = false
  name                     = "VPC should have subnets attached"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\"{\n\tcount(input.VpcSubnets) < 1\n}{\n\tis_null(input.VpcSubnets)\n}\n\ncurrentConfiguration := \"The VPC has no resources attached to it\"\nexpectedConfiguration := \"VPC with no resources attached to it should be removed\""
  remediation_instructions = "Perform the following commands in order to delete the unused VPC via AWS CLI:  \n```  \n aws ec2 delete-vpc vpc-id {{vpcId}}\n```  \n\n>**Note**  \nYou must detach or delete all gateways and resources that are associated with the VPC before you can delete it."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["vpc"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tdocs := input.document[i]\n\t[path, Resources] := walk(docs)\n\tresource := Resources[name]\n\tresource.Type == \"AWS::EC2::VPC\"\n\n\tnot attachedToResources(name)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"%s%s\", [cloudFormationLib.getPath(path), name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s' should be attached to resources\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s' is not attached to resources\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nattachedToResources(vpcName) {\n\tsome subnet\n\tresource := input.document[i].Resources[subnet]\n\tresource.Type == \"AWS::EC2::Subnet\"\n\trefers(resource.Properties.VpcId, vpcName)\n}\n\nrefers(obj, name) {\n\tobj.Ref == name\n}\n\nrefers(obj, name) {\n\tobj == name\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-4-9" {
  description              = "This rule checks whether the IAM policy allows actions for all traffic to a SageMaker Notebook instance.  \nThis rule fails if the policy contains at least one `Statement` that includes:\n* `Action` contains at least one `sagemaker` action, or a wildcard `*` (which contains all SageMaker actions)\n* `Condition` includes `aws:SourceIp` with `0.0.0.0/0` (all IPv4 addresses) or `::/0` (all IPv6 addresses) - allowing public access\n* `Effect` is set to `Allow`\n\nIt is recommended to follow the principle of least privilege (PoLP) and restrict the IAM policy so access is granted to the required IP addresses only."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM policy should not allow overly permissive access to all traffic for SageMaker Notebook instance"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nallInternet := {\"0.0.0.0/0\", \"::/0\"}\nactionsContainingSagemaker := {\"*\", \"sagemaker:\"}\n\n# This function checks if there is a condition in a statement in the policy that allows\n# connections from any source IP address (IPv4 or/and IPv6). The function checks both\n# allowed condition syntaxes: 'IpAddress' and 'ForAnyValue:IpAddress', as an array or a string. \n\nallInternetCondition(condition) {\n\tallInternet[condition.IpAddress[\"aws:SourceIp\"][_]]\n}{\n\tallInternet[condition.IpAddress[\"aws:SourceIp\"]]\n}{\n\tallInternet[condition[\"ForAnyValue:IpAddress\"][\"aws:SourceIp\"][_]]\n}{\n\tallInternet[condition[\"ForAnyValue:IpAddress\"][\"aws:SourceIp\"]]\n}\n\nsagemakerAction(statement) {\n\tstartswith(lower(statement.Action[_]), actionsContainingSagemaker[_])\n}{\n\tstartswith(lower(statement.Action), actionsContainingSagemaker[_])\n}\n\neffectAllow(statement) {\n\tlower(statement.Effect) == \"allow\"\n}\n\nresult = \"skip\" {\n\tnot input.Statement\n} else = \"fail\" {\t\n\tstatement := input.Statement[state]\n\tallInternetCondition(statement.Condition)\n\tsagemakerAction(statement)\n\teffectAllow(statement)\n}\n\ncurrentConfiguration := \"The policy allows overly-permissive public access to at least one 'sagemaker' action\"\nexpectedConfiguration := \"The overly permissive statement(s) should restrict IP access condition\""
  remediation_instructions = "Perform the following commands to delete or modify the IAM policy via AWS CLI:    \nIf the policy **is not in use**, it is recommended to delete it. Use the following command to delete the policy:  \n```  \naws iam delete-policy \\\n    --policy-arn <value>  \n```  \nIf the policy **is in use**, locate the overly permissive statement(s) in the policy, and create a new JSON file that excludes the permissive condition. Use the following command to create a new policy version and set it to default:  \n```  \naws iam create-policy-version \\\n    --policy-arn <value> \\\n    --policy-document file://<NewPolicyVersion.json> \\\n    --set-as-default  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["customerManagedPolicy", "inlinePolicy"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nWizPolicy[result] {\n\tresourceType := {\"aws_iam_role_policy\", \"aws_iam_user_policy\", \"aws_iam_group_policy\", \"aws_iam_policy\"}\n\tresource := input.document[i].resource[resourceType[idx]][name]\n\n\tpolicy := common_lib.json_unmarshal(resource.policy)\n\tst := common_lib.get_statement(policy)\n\tstatement := st[_]\n\n\tcommon_lib.is_allow_effect(statement)\n\tactionsContainingSageMaker(statement)\n\tallInternetCondition(statement.Condition)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"resourceType\": resourceType[idx],\n\t\t\"searchKey\": sprintf(\"%s[%s].policy\", [resourceType[idx], name]),\n\t\t\"keyActualValue\": \"'policy.Statement.Action' contains SageMaker (or wildcard) and 'policy.Statement.Condition' allows public access.\",\n\t\t\"keyExpectedValue\": \"'policy.Statement.Conditon' should be restricted to the required IP addresses only.\",\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", resourceType[idx], name, \"policy\"], []),\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nactionKeys := {\"Action\", \"Actions\"}\nallInternet := {\"0.0.0.0/0\", \"::/0\"}\n\nactionsContainingSageMaker(statement) {\n\tcommon_lib.equalsOrInArray(statement[actionKeys[_]], \"*\")\n}{\n\tstartswith(lower(statement[actionKeys[_]]), \"sagemaker:\")\n}{\n\tstartswith(lower(statement[actionKeys[_]][_]), \"sagemaker:\")\n}\n\nallInternetCondition(condition) {\n\tallInternet[condition.IpAddress[\"aws:SourceIp\"][_]]\n}{\n\tallInternet[condition.IpAddress[\"aws:SourceIp\"]]\n}{\n\tallInternet[condition[\"ForAnyValue:IpAddress\"][\"aws:SourceIp\"][_]]\n}{\n\tallInternet[condition[\"ForAnyValue:IpAddress\"][\"aws:SourceIp\"]]\n}"
    remediation_instructions = null
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-acc-6-4" {
  description              = "This rule checks whether IAM User has both console access and access keys.  \nThis rule fails if both `LoginProfile` and `AccessKeys` are set.\nIAM users having both console and key access can lead to increased chances of accidental exposure. It is recommended to ensure that every IAM user has only an access key or console login set."
  enabled                  = true
  function_as_control      = false
  name                     = "IAM User should not have both console access and access keys"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\n# Check if the user has console access\nhas_console_access {\n    lower(input.userCredentials.PasswordEnabled) == \"true\"\n}\n\n# Check if the user has active access keys\nhas_active_access_keys {\n    lower(input.userCredentials.AccessKey1Active) == \"true\"\n}\n\nhas_active_access_keys {\n    lower(input.userCredentials.AccessKey2Active) == \"true\"\n}\n\n# Fail if the user has both console access and active access keys\nresult = \"fail\" {\n    has_console_access\n    has_active_access_keys\n}\n\n# Skip if userCredentials is not present\nresult = \"skip\" {\n    not input.userCredentials\n}\n\ncurrentConfiguration := sprintf(\"Console access: %s, Access key 1 active: %s, Access key 2 active: %s\", [input.userCredentials.PasswordEnabled, input.userCredentials.AccessKey1Active, input.userCredentials.AccessKey2Active])\nexpectedConfiguration := \"The IAM user should have either console access or access keys, but not both\""
  remediation_instructions = null
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["user"]
}


resource "wiz_cloud_configuration_rule" "op-acc-6-r2-2" {
  description              = "This rule checks whether the IAM user, who has access to the AWS console, has Multi-Factor Authentication (MFA) enabled.  \nThis rule fails if the user has `PasswordEnabled` set to `true`, and `MfaActive` is set to `false`.  \nThis rule skips if the user has `PasswordEnabled` set to `false`.  \nMFA adds an extra layer of protection on top of a username and password. With MFA enabled, when a user signs in to an AWS website, they will be prompted for their username and password as well as for an authentication code from their AWS MFA device. Enabling MFA provides increased security for console access as it requires the authenticating principals to possess a device that emits a time-sensitive key and have knowledge of a credential.  \nIt is recommended to enforce that MFA will be enabled for all users who have console access.\n"
  enabled                  = true
  function_as_control      = false
  name                     = "IAM User with console access should have MFA enabled"
  opa_policy               = "package wiz\n\ndefault result := \"pass\"\n\nresult := \"skip\" {\n\tnot input.userCredentials\n} else := \"skip\"{\n\tlower(input.userCredentials.PasswordEnabled) == \"false\"\n} else := \"fail\" {\n\tlower(input.userCredentials.MfaActive) == \"false\"\n   \tlower(input.userCredentials.PasswordEnabled) == \"true\"\n}\n\ncurrentConfiguration := \"'MfaActive' is set to false\"\nexpectedConfiguration := \"Multi factor authentication should be enabled\"\n"
  remediation_instructions = "Perform the following commands to create and enable a virtual MFA for the user via AWS CLI:    \n1. Use the following command to create a virtual MFA command.    \nIn the `outfile` value, enter a file path destination on your machine, including the file name (for example: /home/{{userName}}-qr-code.txt).  \n```  \naws iam create-virtual-mfa-device \\\n--virtual-mfa-device-name {{userName}}-MFADevice \\\n--outfile <value> \\\n--bootstrap-method Base32StringSeed  \n```  \n2. Use the following command to enable the MFA for the user.    \nCopy the `SerialNumber` output from the previous step and retrieve the `authentication-codes` values from your MFA device. Click [here](https://aws.amazon.com/iam/features/mfa/?audit=2019q1) to see the list of AWS-supported virtual MFA applications.  \n```   \naws iam enable-mfa-device \\\n--user-name {{userName}} \\\n--serial-number <value> \\\n--authentication-code1 <value> \\\n--authentication-code2 <value>  \n```    \nIf successful, the command does not produce an output, and the user will be required to use MFA in their next login."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["user"]
}


resource "wiz_cloud_configuration_rule" "op-exp-8-r4-4" {
  description              = "This rule checks if MFA Delete is enabled on the S3 Bucket.  \nThis rule fails if `MFADelete` is not set to `Enabled`, or if the field does not exist.  \nThis rule skips buckets that have a lifecycle configuration.  \nUsing MFA-protected S3 buckets will enable an extra layer of protection to ensure that the S3 objects (files) cannot be accidentally or intentionally deleted by the AWS users who have access to the buckets.\n>**Note**  \n>While there are a number of benchmarks and guidances that still advise this feature, **Wiz does not**.  \n>This feature was created long ago and there are now better ways of accomplishing this.  \n>The consequences of using MFA Delete are:  \n>* To enable it, you must use the root user.\n>* You must create an access key for the root user so you can use the CLI, as there is no console functionality for this.\n>* You must use a TOTP MFA instead of FIDO for the root user.\n>* Then, to make use of it to delete a file, you must again use the root user with an access key, or use an IAM user with an access key.\n>* You again need to use a TOTP MFA when performing the operation.\n>Every one of these steps is a violation of best practices and is more likely to result in the type of breach that it is seeking to prevent."
  enabled                  = true
  function_as_control      = false
  name                     = "S3 Bucket MFA Delete should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"skip\" {\n\tinput.bucketLifecycleConfiguration.Rules[i].Status == \"Enabled\"\n} else = \"skip\" {\n\tnot input.WizMetadata.objectFetchStatus.bucketLifecycleConfiguration.result == \"Success\"\n} else = \"skip\" {\n\tnot input.WizMetadata.objectFetchStatus.bucketVersioning.result == \"Success\"\n} else = \"fail\" {\n\tnot input.bucketVersioning.MFADelete == \"Enabled\"\n}\n\ncurrentConfiguration := sprintf(\"S3 Bucket MFA Delete is set to 'Disabled'\", [])\nexpectedConfiguration := sprintf(\"S3 Bucket MFA Delete should be set to 'Enabled'\", [])"
  remediation_instructions = "Perform the following command in order to enable MFA Delete feature in S3 Bucket via AWS CLI:  \n```  \naws s3api put-bucket-versioning --profile <myRootProfile> --bucket {{bucketName}} --versioning-configuration Status=Enabled,MFADelete=Enabled --mfa <\"MFA-seriel-number-and-code\">  \n```\n>**Note**  \nPlease see the note on the rule's description on why Wiz does not recommed enabling this feature."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "LOW"
  target_native_types      = ["bucket"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as commonLib\nimport data.generic.terraform as terraLib\nimport future.keywords.in\n\n# This rule checks if the S3 Bucket does not have MFA Delete enabled.\n# This rule will pass if at least the 'aws_s3_bucket' or\n# its association configuration resource are properly configured.\n# MFA delete cannot be enabled through Terraform, it can be done by adding a MFA device\n# (https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_enable.html) and\n# enabling versioning and MFA delete by using AWS CLI (see remediation on the cloud matcher). \n# Also notice that MFA Delete can not be used with Lifecycle Configurations.\n\nisTrue := {true, \"true\"}\n\nlifecycleConfigurationResourceAssociatedOrConfigured(document, bucket, name) {\n\tlifecycleConfigurationResource := document.resource.aws_s3_bucket_lifecycle_configuration[lifecycleConfigurationName]\n\tterraLib.associatedResources(bucket, lifecycleConfigurationResource, name, lifecycleConfigurationName, \"bucket\", \"bucket\")\n}{\n\tterraLib.validKey(bucket, \"lifecycle_rule\")\n}\n\nbucketVersioningResourceAssociated(document, bucket, name) {\n\tbucketVersioningResource := document.resource.aws_s3_bucket_versioning[bucketVersioningName]\n\tterraLib.associatedResources(bucket, bucketVersioningResource, name, bucketVersioningName, \"bucket\", \"bucket\")\n}\n\ns3BucketMfaDeleteEnabled(document, bucket, name) {\n\t# Support for old TF versions\n\tterraLib.validKey(bucket, \"versioning\")\n\tversioning := terraLib.getValueArrayOrObject(bucket.versioning)\n\tterraLib.validKey(versioning, \"enabled\")\n\tversioning.enabled in isTrue\n\tterraLib.validKey(versioning, \"mfa_delete\")\n\tversioning.mfa_delete in isTrue\n}{\n\t# Support for new TF versions\n\tbucketVersioningResource := document.resource.aws_s3_bucket_versioning[bucketVersioningName]\n\tterraLib.associatedResources(bucket, bucketVersioningResource, name, bucketVersioningName, \"bucket\", \"bucket\")\n\tversioningConfiguration := terraLib.getValueArrayOrObject(bucketVersioningResource.versioning_configuration)\n \tlower(versioningConfiguration.mfa_delete) == \"enabled\"\n\tlower(versioningConfiguration.status) == \"enabled\"\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tbucket := document.resource.aws_s3_bucket[name]\n\n\tnot lifecycleConfigurationResourceAssociatedOrConfigured(document, bucket, name)\n\tnot s3BucketMfaDeleteEnabled(document, bucket, name)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceType\": \"aws_s3_bucket\",\n\t\t\"resourceName\": terraLib.get_resource_name(bucket, name),\n\t\t\"searchKey\": sprintf(\"aws_s3_bucket[%s]\", [name]),\n\t\t\"keyExpectedValue\": sprintf(\"'aws_s3_bucket[%s]' MFA Delete should be enabled\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_s3_bucket[%s]' MFA Delete is disabled\", [name]),\n\t\t\"resourceTags\": object.get(bucket, \"tags\", {}),\n\t\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_s3_bucket_lifecycle_configuration](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket_lifecycle_configuration), [aws_s3_bucket_versioning](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket_versioning), [aws_s3_bucket](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "mp-com-3-1" {
  description              = "This rule checks whether all the Application Load Balancer (ALB) listeners enforce TLS version 1.2 (or higher).\n\nThis rule fails if one of the following occurs:\n* At least one HTTPS listener uses a TLS version lower than 1.2\n* An HTTP listener of type `forward` exists\n\nOutdated TLS protocols are considered insecure as they might be vulnerable to man-in-the-middle exploits, allowing an attacker to decrypt and access encrypted data. Ensure the ALB supports TLSv1.2 or higher.\n>**Note**  \n>Use Cloud Configuration Rule `ELB-034` if you want to enforce TLS version 1.3 on your ALB."
  enabled                  = true
  function_as_control      = false
  name                     = "Application Load Balancer should use TLS version 1.2 or higher"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\noutdatedTlsVersions := {\"TLSv1.1\", \"TLSv1\"}\n\noutdatedSslPolicies[policies] {\n\tlistenersSslPolicy := input.loadBalancerListenerSslPolicies[policies]\n\toutdatedTlsVersions[listenersSslPolicy.SslProtocols[_]]\n}\n\nhttpForwardListeners[listeners] {\n\tlistener := input.loadBalancerListeners[listeners]\n\tupper(listener.Protocol) == \"HTTP\"\n\tlower(listener.DefaultActions[_].Type) == \"forward\"\n}\n\nresult = \"fail\" {\n\tcount(outdatedSslPolicies) > 0\n}{\n\tcount(httpForwardListeners) > 0\n}\n\ncurrentConfiguration := \"ALB contains HTTPS listeners that are not using TLSv1.2, and/or HTTP forward listeners\"\nexpectedConfiguration := \"All listeners should use TLSv1.2 (or higher)\""
  remediation_instructions = "Perform the following command to upgrade the ALB HTTPS listener's security policy via AWS CLI:\n```\naws elbv2 modify-listener \\\n\t--listener-arn <Listener ARN> \\\n\t--ssl-policy <Security Policy - for example: ELBSecurityPolicy-TLS13-1-2-2021-06> \\\n\t--region {{region}}\n```\nListed below are all the ALB HTTPS listener's ARNs with their current security policy, if any exist.  \n```\n{{displayResultHttps}}\n```\n{{displayResultHttp}}\n>**Note**  \nFor information on AWS ELB security policies and to choose the right one for your ALB, click [here](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies)."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["loadBalancerv2/application"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport future.keywords.in\n\nsecureProtocols := {\n\t\"elbsecuritypolicy-tls13-1-3-2021-06\",\n\t\"elbsecuritypolicy-tls13-1-2-2021-06\",\n\t\"elbsecuritypolicy-tls13-1-2-res-2021-06\",\n\t\"elbsecuritypolicy-tls13-1-2-ext2-2021-06\",\n\t\"elbsecuritypolicy-tls13-1-2-ext1-2021-06\",\n\t\"elbsecuritypolicy-tls-1-2-ext-2018-06\",\n\t\"elbsecuritypolicy-tls-1-2-2017-01\",\n\t\"elbsecuritypolicy-tls13-1-3-fips-2023-04\",\n\t\"elbsecuritypolicy-tls13-1-2-fips-2023-04\",\n\t\"elbsecuritypolicy-tls13-1-2-res-fips-2023-04\",\n\t\"elbsecuritypolicy-tls13-1-2-ext2-fips-2023-04\",\n\t\"elbsecuritypolicy-tls13-1-2-ext1-fips-2023-04\",\n\t\"elbsecuritypolicy-tls13-1-2-ext0-fips-2023-04\",\n\t\"elbsecuritypolicy-fs-1-2-res-2020-10\",\n\t\"elbsecuritypolicy-fs-1-2-res-2019-08\",\n\t\"elbsecuritypolicy-fs-1-2-2019-08\"\n}\n\nsecureSSLPolicy(listener) {\n\tlower(listener.ssl_policy) in secureProtocols\n}\n\nhasHttpForward(listener) {\n\tlower(listener.protocol) == \"http\"\n\taction := terraLib.getValueArrayOrObject(listener.default_action)\n\tlower(action.type) == \"forward\"\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tlbResources := {\"aws_lb\", \"aws_alb\"}\n\tlbResource := document.resource[lbResources[lb]][lbResourceName]\n\tlower(lbResource.load_balancer_type) == \"application\"\n\t\n\tlistener := document.resource.aws_lb_listener[listenerName]\n\tterraLib.associatedResources(lbResource, listener, lbResourceName, listenerName, null, \"load_balancer_arn\")\n\tlower(listener.protocol) == \"https\"\n\tnot secureSSLPolicy(listener)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": terraLib.get_resource_name(lbResource, lbResourceName),\n\t\t\"resourceType\": lbResources[lb],\n\t\t\"searchKey\": sprintf(\"%s[%s]\", [lbResources[lb], lbResourceName]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_lb_listener[%s].ssl_policy should use TLS 1.2 or higher\", [listenerName]),\n\t\t\"keyActualValue\": sprintf(\"aws_lb_listener[%s].ssl_policy is using an insecure SSL policy\", [listenerName]),\n\t\t\"resourceTags\": object.get(lbResource, \"tags\", {})\n\t}\n}\n\nWizPolicy[result] {\n\tdocument := input.document[i]\n\tlbResources := {\"aws_lb\", \"aws_alb\"}\n\tlbResource := document.resource[lbResources[lb]][lbResourceName]\n\tlower(lbResource.load_balancer_type) == \"application\"\n\t\n\tlistener := document.resource.aws_lb_listener[listenerName]\n\tterraLib.associatedResources(lbResource, listener, lbResourceName, listenerName, null, \"load_balancer_arn\")\n\thasHttpForward(listener)\n\n\tresult := {\n\t\t\"documentId\": document.id,\n\t\t\"resourceName\": terraLib.get_resource_name(lbResource, lbResourceName),\n\t\t\"searchKey\": sprintf(\"%s[%s]\", [lbResources[lb], lbResourceName]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_lb_listener[%s] should not use HTTP protocol with forward action\", [listenerName]),\n\t\t\"keyActualValue\": sprintf(\"aws_lb_listener[%s] uses HTTP protocol with forward action\", [listenerName]),\n\t\t\"resourceTags\": object.get(lbResource, \"tags\", {})\n\t}\n}"
    remediation_instructions = "resource \"aws_lb_listener\" \"example\" {\n  ssl_policy = \"<ssl_policy>\" // Replace with SSL policy\n}"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-10-9" {
  description              = "This rule checks whether the KMS key is disabled.  \nThis rule fails if `KeyState` is defined as `Disabled`.  \nEach KMS key that you create with Amazon KMS will be charged until you delete it, regardless of whether it is being used or not.   \nIt is recommended to safely delete all unused, disabled KMS keys, in order to lower billing costs.  \n>**Note**  \n> Deleting KMS keys can potentially be dangerous.  \nIt deletes the key material and all metadata associated with it and is irreversible.  \nAfter a key is deleted, you can no longer decrypt the data that was encrypted under that key, which means that data becomes unrecoverable.  \n**You should delete a key only when you are sure that you don't need it anymore.**  \n> This rule does not indicate a misconfiguration, and is only meant to notify of potential unnecessary expenses."
  enabled                  = true
  function_as_control      = false
  name                     = "Disabled KMS key should be safely deleted"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nresult = \"fail\" {\n\tlower(input.KeyState) == \"disabled\"\n}\n\ncurrentConfiguration := \"'KeyState' is 'Disabled'\"\nexpectedConfiguration := \"Disabled key should be enabled or safely deleted\""
  remediation_instructions = "Perform the following commands in order to delete the disabled KMS key via AWS CLI:\n```\naws kms schedule-key-deletion \\\n  --region {{region}} \\\n  --key-id {{keyID}}  \\\n  --pending-window-in-days <numberOfDaysToWait> \\\n```\n>**Note**   \n> Deleting KMS keys can potentially be dangerous.  \nIt deletes the key material and all metadata associated with it and is irreversible.  \nAfter a key is deleted, you can no longer decrypt the data that was encrypted under that key, which means that data becomes unrecoverable. For this reason, ensure the key is no longer needed prior to the deletion process.  \nIt is also recommended to add a `Pending Window` that is reasonable considering the circumstances, that will allow for a safe deletion, and will lower the chances of an irreversible data loss."
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "INFORMATIONAL"
  target_native_types      = ["encryptionKey"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.ansible as ansLib\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tkms := task[\"community.aws.aws_kms\"]\n\tansLib.checkState(kms)\n\n\tkms.enabled == false\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{community.aws.aws_kms}}.enabled\", [task.name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"community.aws.aws_kms.enabled should be set to true\",\n\t\t\"keyActualValue\": \"community.aws.aws_kms.enabled is set to false\",\n\t\t\"resourceTags\": object.get(kms, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\ttask := ansLib.tasks[id][t]\n\tkms := task[\"community.aws.aws_kms\"]\n\tansLib.checkState(kms)\n\n\tkms.pending_window\n\n\tresult := {\n\t\t\"documentId\": id,\n\t\t\"resourceName\": task.name,\n\t\t\"searchKey\": sprintf(\"name={{%s}}.{{community.aws.aws_kms}}.pending_window\", [task.name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": \"community.aws.aws_kms.pending_window should be undefined\",\n\t\t\"keyActualValue\": \"community.aws.aws_kms.pending_windowis is set\",\n\t\t\"resourceTags\": object.get(kms, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "ANSIBLE"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::KMS::Key\"\n\tresource.Properties.Enabled == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.Enabled\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.Enabled' should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.Enabled' is false\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::KMS::Key\"\n\tresource.Properties.PendingWindowInDays\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.PendingWindowInDays\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.PendingWindowInDays' should be undefined\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.PendingWindowInDays' is defined\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\nimport data.generic.common as common_lib\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_kms_key[name]\n\n\tresource.is_enabled == false\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceType\": \"aws_kms_key\",\n\t\t\"resourceName\": terraLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"aws_kms_key[%s].is_enabled\", [name]),\n\t\t\"searchLine\": common_lib.build_search_line([\"resource\", \"aws_kms_key\", name, \"is_enabled\"], []),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_kms_key[%s].is_enabled should be set to true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"aws_kms_key[%s].is_enabled is set to false\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_kms_key](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/kms_key)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_control" "op-exp-8-r1-14" {
  description               = "The subscription has no CloudWatch Log metric filter and alarm to monitor network ACLs configuration changes.\n\nIt is recommended to set an alarm that will be triggered for every network ACL configuration change (create, delete, or update). This helps detect modifications that may allow undesired access to AWS resources."
  enabled                   = false
  name                      = "Subscription with no CloudWatch monitoring for network access control lists (ACL)"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"negate\":true,\"type\":[{\"reverse\":true,\"type\":\"LOGS_DATA_FOR\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"USES\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudWatch-018\"]},\"currentConfig\":{\"CONTAINS\":[\"CloudWatch Filter 4\"]}}}},{\"type\":[{\"type\":\"SEND_MESSAGES_TO\"}],\"with\":{\"relationships\":[{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"SNS-008\"]}}}}],\"type\":[\"MESSAGING_SERVICE\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"sns\"]}}}}],\"type\":[\"MONITOR_ALERT\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"metricfilteralarm\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"logs#loggroup\"]}}}},{\"type\":[{\"reverse\":true,\"type\":\"ALERTED_ON\"}],\"with\":{\"type\":[\"CONFIGURATION_FINDING\"],\"where\":{\"configurationRuleShortName\":{\"CONTAINS\":[\"CloudTrail-013\"]}}}}],\"type\":[\"CLOUD_LOG_CONFIGURATION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"cloudtrail\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable logging wherever possible.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_control" "op-mon-2-1" {
  description               = "This AWS account has Security Hub disabled\n\nSecurity Hub provides centralized visibility into security findings and compliance status across AWS accounts. It automates compliance checks, prioritizes security findings, and offers insights into potential threats."
  enabled                   = false
  name                      = "Subscription with no AWS Security Hub"
  project_id                = "*"
  query                     = "{\"relationships\":[{\"type\":[{\"type\":\"CONTAINS\"}],\"with\":{\"relationships\":[{\"negate\":true,\"type\":[{\"type\":\"CONTAINS\"}],\"with\":{\"relationships\":[{\"type\":[{\"type\":\"HAS_TECH\"}],\"with\":{\"type\":[\"TECHNOLOGY\"],\"where\":{\"_externalID\":{\"EQUALS\":[\"11161\"]}}}}],\"type\":[\"MANAGEMENT_SERVICE\"]}}],\"select\":true,\"type\":[\"REGION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"region\"]}}}}],\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"cloudPlatform\":{\"EQUALS\":[\"AWS\"]}}}"
  resolution_recommendation = "### Monitor for suspicious activity\n* Enable security hub.\n* Use endpoint protection solutions on your resources."
  scope_query               = "{\"select\":true,\"type\":[\"SUBSCRIPTION\"],\"where\":{\"nativeType\":{\"EQUALS\":[\"account\"]}}}"
  security_sub_categories   = []
  severity                  = "INFORMATIONAL"
}


resource "wiz_cloud_configuration_rule" "op-exp-7-3" {
  description              = "This rule checks whether GuardDuty runtime monitoring is enabled.  \nThis rule fails if the `RUNTIME_MONITORING` feature within the GuardDuty service is set to `DISABLED`.  \nEnabling runtime monitoring in GuardDuty is crucial for detecting unexpected and potentially unauthorized or malicious activity within your AWS environment. It provides continuous security monitoring and threat detection, which helps you to protect your AWS accounts and workloads."
  enabled                  = true
  function_as_control      = false
  name                     = "GuardDuty runtime monitoring should be enabled"
  opa_policy               = "package wiz\n\ndefault result = \"pass\"\n\nprotection := \"RUNTIME_MONITORING\"\n\nresult = \"fail\" {\n\tupper(input.Features[feature].Name) == protection\n\tupper(input.Features[feature].Status) == \"DISABLED\"\n}\n\ncurrentConfiguration := sprintf(\"'%s' feature is disabled\", [protection])\nexpectedConfiguration := sprintf(\"'%s' feature should be enabled\", [protection])"
  remediation_instructions = "Perform the following command to enable runtime monitoring via AWS CLI:\n``` \naws guardduty update-detector\n/ --detector-id {{detectorID}}\n/ --features '[{\"Name\" : \"RUNTIME_MONITORING\", \"Status\" : \"ENABLED\"}]\n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "MEDIUM"
  target_native_types      = ["guardduty"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.terraform as terraLib\n\nrelatedFeature(document, resource, detectorName) = runtimeStatus {\n\tfeature := document.resource.aws_guardduty_detector_feature[featureName]\n    \tfeature.name == \"RUNTIME_MONITORING\"\n    \tterraLib.associatedResources(resource, feature, detectorName, featureName, null, \"detector_id\")\n    \truntimeStatus := [feature.status, featureName]\n}\n\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[detectorName]\n    not relatedFeature(input.document[i], resource, detectorName)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, detectorName),\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector[%s]\", [detectorName]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector[%s] should have aws_guardduty_detector_feature[runtime_monitoring] associated and enabled\", [detectorName]),\n\t\t\"keyActualValue\": \"there is no aws_guardduty_detector_feature[runtime_monitoring] associated\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].resource.aws_guardduty_detector[detectorName]\n\truntimeStatus := relatedFeature(input.document[j], resource, detectorName)\n\tfeatureName := runtimeStatus[1]\n\tupper(runtimeStatus[0]) != \"ENABLED\"\n\n\tresult := {\n\t\t\"documentId\": input.document[j].id,\n\t\t\"resourceName\": terraLib.get_resource_name(resource, detectorName),\n\t\t\"resourceType\": \"aws_guardduty_detector\",\n\t\t\"searchKey\": sprintf(\"aws_guardduty_detector_feature[%s].status\", [featureName]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"aws_guardduty_detector_feature[%s].status should be enabled\", [featureName]),\n\t\t\"keyActualValue\": sprintf(\"aws_guardduty_detector_feature[%s].status is disabled\", [featureName]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"DISABLED\",\n\t\t\t\"after\": \"ENABLED\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(resource, \"tags\", {}),\n\t}\n}"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_guardduty_detector_feature](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/guardduty_detector_feature), [aws_guardduty_detector](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/guardduty_detector)"
    type                     = "TERRAFORM"
  }
}


resource "wiz_cloud_configuration_rule" "op-exp-8-r1-17" {
  description              = "This rule checks whether CloudTrail at the account level is configured as multi-region, global service logging is enabled, and management events are configured for all read/write operations.  \nEnsuring that a multi-region trail exists assists with detecting when unexpected activity occurs.  \nWhen global service logging is enabled, events on AWS global services are recorded as well. In addition, to ensure management operations performed on all resources are recorded as well, management events should be configured for all read/write operations."
  enabled                  = true
  function_as_control      = false
  name                     = "CloudTrail logging should be enabled in all regions - Account level"
  opa_policy               = "package wiz\n\ndefault result = \"fail\"\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\tlower(readOrWrite.Field) == \"readonly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tlower(currSelector.Field) == lower(currField)\n\tlower(currSelector.Equals[_]) == lower(currValue)\n}\n\n#returns value if configuration is good\nselectors[event] {\n\t#basic\n\tevent := input.EventSelectors[i]\n\tevent.IncludeManagementEvents\n\tlower(event.ReadWriteType) == \"all\"\n}{\n\t#advanced\n\tevent := input.AdvancedEventSelectors[i]\n  \tcheckFieldSelector(event.FieldSelectors[_], \"eventCategory\", \"Management\")\n\tnot advanReadAndWrite(event.FieldSelectors)\n}\n\nresult = \"skip\" { #if organiztion level\n\tinput.IsOrganizationTrail\n}\nelse = \"pass\" {\n\tinput.IsMultiRegionTrail\n\tinput.CloudTrailStatus.IsLogging\n\tcount(selectors) > 0\n}\ncurrentConfiguration := sprintf(\"IsMultiRegionTrail setting is set to: %s. IsLogging is set to: %s. Required event selector exists: %s\", [input.IsMultiRegionTrail, input.CloudTrailStatus.IsLogging, count(selectors) > 0])\nexpectedConfiguration := \"IsMultiRegionTrail and IsLogging should be set to true. There should be at least one event selector with IncludeManagementEvents set to true and ReadWriteType set to 'All'\"\n"
  remediation_instructions = "Perform the following commands in order to modify CloudTrail via CLI:  \n1. Use the following command in order to enable Multi-region CloudTrail logging:  \n```  \naws cloudtrail update-trail --name {{trailName}} --is-multi-region-trail  \n```  \n2. Use the following command in order to start CloudTrail logging:  \n```  \naws cloudtrail start-logging --name {{trailName}}  \n```  \n3. Use the following command in order to modify CloudTrail event selectors:  \n```  \naws cloudtrail put-event-selectors --trail-name {{trailName}} --event-selectors '[{\"ReadWriteType\": \"All\",\"IncludeManagementEvents\": true}]'  \n```"
  scope_account_ids        = []
  scope_project_id         = null
  security_sub_categories  = []
  severity                 = "HIGH"
  target_native_types      = ["cloudtrail"]
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.cloudformation as cloudFormationLib\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tcommon_lib.valid_key(resource.Properties, \"IsMultiRegionTrail\")\n\tnot checkRegion(resource)\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties.IsMultiRegionTrail\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' should be true\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' is false\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\nWizPolicy[result] {\n\tresource := input.document[i].Resources[name]\n\tresource.Type == \"AWS::CloudTrail::Trail\"\n\tnot common_lib.valid_key(resource.Properties, \"IsMultiRegionTrail\")\n\n\tresult := {\n\t\t\"documentId\": input.document[i].id,\n\t\t\"resourceName\": cloudFormationLib.get_resource_name(resource, name),\n\t\t\"searchKey\": sprintf(\"Resources.%s.Properties\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' should exist\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'Resources.%s.Properties.IsMultiRegionTrail' is missing\", [name]),\n\t\t\"resourceTags\": cloudFormationLib.getCFTags(resource),\n\t}\n}\n\ncheckRegion(cltr) {\n\tcltr.Properties.IsMultiRegionTrail == true\n}\n"
    remediation_instructions = null
    type                     = "CLOUD_FORMATION"
  }
  iac_matchers {
    rego_code                = "package wiz\n\nimport data.generic.common as common_lib\nimport data.generic.terraform as terraLib\n\nisOrganizationLevel(cloudtrailResource) {\n\tcloudtrailResource.is_organization_trail == true\n}\n\nisMultiRegionTrail(cloudtrailResource) {\n\tcloudtrailResource.is_multi_region_trail == true\n}\n\n#check for read and write permissions in basic event selectors\nbasicReadAndWrite(eventSel) {\n\teventSel.read_write_type == \"All\"\n}\n\n#check for read and write permissions in advanced event selectors\nadvanReadAndWrite(currEventSel) {\n\treadOrWrite := currEventSel[_]\n\treadOrWrite.field == \"readOnly\"\n}\n\n#check field selector types in advanced event selectors\ncheckFieldSelector(currSelector, currField, currValue) {\n\tcurrSelector.field == currField\n\tcurrSelector.equals[_] == currValue\n}\n\nadvancedEventSelectorWithManagementEvents(currEventSel) {\n  \tcheckFieldSelector(currEventSel[_], \"eventCategory\", \"Management\")\n  \tnot advanReadAndWrite(currEventSel)\n}\n\nbasicResourcesWithManagementEvents(eventSel) {\n\teventSel.include_management_events == true\n}\n\n#seperate checks for advanced single and multi selectors\nadvancedEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.advanced_event_selector[_]\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.advanced_event_selector\n\tadvancedEventSelectorWithManagementEvents(eventSel.field_selector)\t\n}\n\n#seperate checks for basic single and multi event selectors\nbasicEventSelc(cloudtrailResource) {\n\t# Multi event selectors\n\teventSel := cloudtrailResource.event_selector[_]\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}{\n\t# Single event selectors\n\teventSel := cloudtrailResource.event_selector\n\tbasicResourcesWithManagementEvents(eventSel)\n\tbasicReadAndWrite(eventSel)\n}\n\n#check event selector for basic and advanced resources\nconfiguredWithManagementEvents(cloudtrailResource) {\n\t# Basic \n\tbasicEventSelc(cloudtrailResource)\n}{ \n\t# Advanced\n\tadvancedEventSelc(cloudtrailResource)\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[cloudtrailName]\n    \n\tnot configuredWithManagementEvents(cloudtrailResource)\n\tnot isOrganizationLevel(cloudtrailResource)\n\tisMultiRegionTrail(cloudtrailResource)\n\t\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, cloudtrailName),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [cloudtrailName]),\n\t\t\"keyExpectedValue\": sprintf(\"aws_cloudtrail[%s] should be configured with management events and multi region\",[cloudtrailName]),\n\t\t\"keyActualValue\": sprintf(\"aws_cloudtrail[%s] is not configured with management events and multi region\",[cloudtrailName]),\n  \t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {})\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\n\tnot common_lib.valid_key(cloudtrailResource, \"is_multi_region_trail\")\n\tnot isOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s]\", [name]),\n\t\t\"issueType\": \"MissingAttribute\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].is_multi_region_trail' should be defined (and not null)\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].is_multi_region_trail' is undefined or null\", [name]),\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\n\tcloudtrailResource.is_multi_region_trail == false\n\tnot isOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].is_multi_region_trail\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].is_multi_region_trail' should be 'true'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].is_multi_region_trail' is set to 'false'\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\n\tcloudtrailResource.enable_logging == false\n\tnot isOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].enable_logging\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].enable_logging' should be 'true'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].enable_logging' is set to 'false'\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n\nWizPolicy[result] {\n\tdoc := input.document[i]\n\tcloudtrailResource := doc.resource.aws_cloudtrail[name]\n\n\tcloudtrailResource.include_global_service_events == false\n\tnot isOrganizationLevel(cloudtrailResource)\n\n\tresult := {\n\t\t\"documentId\": doc.id,\n\t\t\"resourceType\": \"aws_cloudtrail\",\n\t\t\"resourceName\": terraLib.get_resource_name(cloudtrailResource, name),\n\t\t\"searchKey\": sprintf(\"aws_cloudtrail[%s].include_global_service_events\", [name]),\n\t\t\"issueType\": \"IncorrectValue\",\n\t\t\"keyExpectedValue\": sprintf(\"'aws_cloudtrail[%s].include_global_service_events' should be 'true'\", [name]),\n\t\t\"keyActualValue\": sprintf(\"'aws_cloudtrail[%s].include_global_service_events' is set to 'false'\", [name]),\n\t\t\"remediation\": json.marshal({\n\t\t\t\"before\": \"false\",\n\t\t\t\"after\": \"true\"\n\t\t}),\n\t\t\"remediationType\": \"update\",\n\t\t\"resourceTags\": object.get(cloudtrailResource, \"tags\", {}),\n\t}\n}\n"
    remediation_instructions = "Please refer to the following Terraform documentation for configuration details:  [aws_cloudtrail](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudtrail)"
    type                     = "TERRAFORM"
  }
}
